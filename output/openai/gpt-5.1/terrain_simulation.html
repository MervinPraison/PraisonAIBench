<!-- Save this file as: terrain_landscape.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Three.js Terrain Landscape</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: sans-serif;
            color: #fff;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.45);
            font-size: 13px;
            z-index: 10;
        }
        a {
            color: #8cf;
        }
    </style>
</head>
<body>
<div id="info">
    <div><b>3D Terrain Landscape</b></div>
    <div>W / S: move forward / backward</div>
    <div>A / D: strafe left / right</div>
    <div>Q / E: move down / up</div>
    <div>Mouse drag: look around</div>
</div>

<!-- Three.js and OrbitControls from CDN -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function () {
    // ----- Basic setup -----
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // sky color
    scene.fog = new THREE.Fog(0x87ceeb, 150, 900); // fog for depth

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
    );
    camera.position.set(0, 50, 150);

    // OrbitControls for looking around (mouse)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.25;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controls.target.set(0, 20, 0);

    // ----- Lighting -----
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x334433, 0.7);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(-100, 200, 100);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    // ----- Simple pseudo random (for noise) -----
    function mulberry32(seed) {
        return function () {
            let t = (seed += 0x6d2b79f5);
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    }

    const rand = mulberry32(123456);

    // ----- 2D value noise -----
    const NOISE_SIZE = 256;
    const noiseGrid = [];
    for (let y = 0; y < NOISE_SIZE; y++) {
        noiseGrid[y] = [];
        for (let x = 0; x < NOISE_SIZE; x++) {
            noiseGrid[y][x] = rand();
        }
    }

    function smoothstep(t) {
        return t * t * (3 - 2 * t);
    }

    function lerp(a, b, t) {
        return a + (b - a) * t;
    }

    function valueNoise2D(x, y) {
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const xf = x - xi;
        const yf = y - yi;

        const x0 = (xi % NOISE_SIZE + NOISE_SIZE) % NOISE_SIZE;
        const y0 = (yi % NOISE_SIZE + NOISE_SIZE) % NOISE_SIZE;
        const x1 = (x0 + 1) % NOISE_SIZE;
        const y1 = (y0 + 1) % NOISE_SIZE;

        const v00 = noiseGrid[y0][x0];
        const v10 = noiseGrid[y0][x1];
        const v01 = noiseGrid[y1][x0];
        const v11 = noiseGrid[y1][x1];

        const u = smoothstep(xf);
        const v = smoothstep(yf);

        const a = lerp(v00, v10, u);
        const b = lerp(v01, v11, u);
        return lerp(a, b, v);
    }

    // Fractal Brownian Motion (fbm) using valueNoise2D
    function fbm(x, y, octaves, lacunarity, gain) {
        let amp = 1;
        let freq = 1;
        let sum = 0;
        let norm = 0;
        for (let i = 0; i < octaves; i++) {
            sum += valueNoise2D(x * freq, y * freq) * amp;
            norm += amp;
            amp *= gain;
            freq *= lacunarity;
        }
        return sum / norm;
    }

    // ----- Terrain Geometry -----
    const terrainWidth = 800;
    const terrainDepth = 800;
    const segments = 256;

    const geometry = new THREE.PlaneGeometry(
        terrainWidth,
        terrainDepth,
        segments,
        segments
    );
    geometry.rotateX(-Math.PI / 2); // make it horizontal

    // Height map using fbm noise
    const vertices = geometry.attributes.position;
    const heights = [];

    for (let i = 0; i < vertices.count; i++) {
        const x = vertices.getX(i);
        const z = vertices.getZ(i);

        const nx = (x / terrainWidth) * 4;
        const nz = (z / terrainDepth) * 4;

        let h =
            fbm(nx, nz, 5, 2.0, 0.5) * 60 - 10; // base landscape
        // Add a larger scale variation for big hills
        h += fbm(nx * 0.3, nz * 0.3, 3, 2.0, 0.5) * 50;

        heights[i] = h;
        vertices.setY(i, h);
    }

    geometry.computeVertexNormals();

    // ----- Terrain Texture (procedural) -----
    // Create a gradient texture that blends from grass (low),
    // to rock/dirt (mid), to snow (high).
    function createTerrainTexture() {
        const size = 512;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");

        const grd = ctx.createLinearGradient(0, 0, 0, size);
        // Bottom (valleys) - dark green
        grd.addColorStop(0.0, "#1a3b1a");
        grd.addColorStop(0.25, "#2e5b2e");
        // Mid slopes - lighter / dry grass, some dirt
        grd.addColorStop(0.5, "#7b6a3d");
        grd.addColorStop(0.7, "#91856c");
        // High (peaks) - rock to snow
        grd.addColorStop(0.85, "#c7c7c7");
        grd.addColorStop(1.0, "#ffffff");

        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, size, size);

        // add some subtle noise
        const imgData = ctx.getImageData(0, 0, size, size);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            const n = (rand() - 0.5) * 18; // noise intensity
            data[i] = Math.min(255, Math.max(0, data[i] + n));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + n));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + n));
        }
        ctx.putImageData(imgData, 0, 0);

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(16, 16);
        texture.anisotropy = 8;

        return texture;
    }

    const terrainTexture = createTerrainTexture();

    const terrainMaterial = new THREE.MeshLambertMaterial({
        map: terrainTexture,
    });

    const terrain = new THREE.Mesh(geometry, terrainMaterial);
    terrain.receiveShadow = true;
    terrain.castShadow = false;
    scene.add(terrain);

    // ----- Simple sky dome (gradient) -----
    (function createSkyDome() {
        const skyGeo = new THREE.SphereGeometry(3000, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
            side: THREE.BackSide,
            uniforms: {
                topColor: { value: new THREE.Color(0x87ceeb) },
                bottomColor: { value: new THREE.Color(0xffffff) },
                offset: { value: 400 },
                exponent: { value: 0.7 },
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize( vWorldPosition + offset ).y;
                    float f = max( pow( max(h, 0.0), exponent ), 0.0 );
                    gl_FragColor = vec4( mix( bottomColor, topColor, f ), 1.0 );
                }
            `,
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);
    })();

    // ----- WASDQE Fly Controls (custom) -----
    const keys = {
        KeyW: false,
        KeyS: false,
        KeyA: false,
        KeyD: false,
        KeyQ: false,
        KeyE: false,
    };

    window.addEventListener("keydown", (e) => {
        if (e.code in keys) {
            keys[e.code] = true;
        }
    });

    window.addEventListener("keyup", (e) => {
        if (e.code in keys) {
            keys[e.code] = false;
        }
    });

    let lastTime = performance.now();

    function updateMovement(delta) {
        const speed = 80; // base movement speed units/sec
        // Forward/backward - along camera's local Z
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(forward, camera.up).normalize();

        let move = new THREE.Vector3();

        if (keys.KeyW) move.add(forward);
        if (keys.KeyS) move.sub(forward);
        if (keys.KeyA) move.sub(right);
        if (keys.KeyD) move.add(right);

        // Q/E for vertical
        if (keys.KeyE) move.y += 1;
        if (keys.KeyQ) move.y -= 1;

        if (move.lengthSq() > 0) {
            move.normalize();
            move.multiplyScalar(speed * delta);
            camera.position.add(move);
            controls.target.add(move); // so orbit center follows
        }

        // keep camera above terrain
        const terrainY = sampleHeightAt(camera.position.x, camera.position.z);
        const minHeightAbove = 8;
        if (camera.position.y < terrainY + minHeightAbove) {
            const diff = terrainY + minHeightAbove - camera.position.y;
            camera.position.y += diff;
            controls.target.y += diff;
        }
    }

    // ----- Sampling terrain height at (x,z) -----
    function sampleHeightAt(x, z) {
        // Transform world (x,z) into plane local coordinates
        // Plane centered at (0,0), width=terrainWidth, depth=terrainDepth
        const halfW = terrainWidth / 2;
        const halfD = terrainDepth / 2;

        const u = (x + halfW) / terrainWidth;
        const v = (z + halfD) / terrainDepth;

        if (u < 0 || u > 1 || v < 0 || v > 1) {
            // outside terrain; just use noise directly to approximate
            const nx = (x / terrainWidth) * 4;
            const nz = (z / terrainDepth) * 4;
            let h = fbm(nx, nz, 5, 2.0, 0.5) * 60 - 10;
            h += fbm(nx * 0.3, nz * 0.3, 3, 2.0, 0.5) * 50;
            return h;
        }

        const gridX = segments;
        const gridZ = segments;

        const gx = u * gridX;
        const gz = v * gridZ;

        const ix = Math.floor(gx);
        const iz = Math.floor(gz);

        const tx = gx - ix;
        const tz = gz - iz;

        function idx(i, j) {
            return j * (gridX + 1) + i;
        }

        const i0 = Math.min(gridX, Math.max(0, ix));
        const j0 = Math.min(gridZ, Math.max(0, iz));
        const i1 = Math.min(gridX, i0 + 1);
        const j1 = Math.min(gridZ, j0 + 1);

        const h00 = heights[idx(i0, j0)];
        const h10 = heights[idx(i1, j0)];
        const h01 = heights[idx(i0, j1)];
        const h11 = heights[idx(i1, j1)];

        const hx0 = h00 * (1 - tx) + h10 * tx;
        const hx1 = h01 * (1 - tx) + h11 * tx;
        const hFinal = hx0 * (1 - tz) + hx1 * tz;

        return hFinal;
    }

    // ----- Resize handling -----
    window.addEventListener("resize", onWindowResize);
    function onWindowResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
    }

    // ----- Animation loop -----
    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const delta = (now - lastTime) / 1000;
        lastTime = now;

        updateMovement(delta);
        controls.update();

        renderer.render(scene, camera);
    }

    animate();
})();
</script>
</body>
</html>