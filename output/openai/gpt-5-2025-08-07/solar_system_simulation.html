<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Simple Solar System - Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #ddd; font: 14px/1.3 system-ui, Arial, sans-serif;
      background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 6px; user-select: none;
    }
    a { color: #9cf; text-decoration: none; }
  </style>
</head>
<body>
  <div id="info">
    Simple Solar System (Three.js)<br>
    - Sun at center, Earth and Moon with realistic relative periods<br>
    - Drag to orbit view, scroll to zoom<br>
    Simulation speed: 10 days per second
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(60, 30, 60);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);

    // Constants (scaled)
    const SUN_RADIUS = 5;
    const EARTH_RADIUS = 1.0;              // ~1/5 of sun here (stylized)
    const MOON_RADIUS = 0.27;              // realistic ratio to Earth
    const EARTH_ORBIT_RADIUS = 40;         // distance from sun
    const MOON_ORBIT_RADIUS = 3;           // distance from earth

    // Time scaling (realistic relative periods, sped up)
    const DAYS_PER_SECOND = 10;            // simulation speed
    const EARTH_YEAR_DAYS = 365.256;       // sidereal year
    const MOON_ORBIT_DAYS = 27.321661;     // sidereal month
    const EARTH_DAY_DAYS = 1.0;

    // Angular speeds (radians per real second)
    const earthOrbitOmega = 2 * Math.PI * (DAYS_PER_SECOND / EARTH_YEAR_DAYS);
    const moonOrbitOmega  = 2 * Math.PI * (DAYS_PER_SECOND / MOON_ORBIT_DAYS);
    const earthSpinOmega  = 2 * Math.PI * (DAYS_PER_SECOND / EARTH_DAY_DAYS);
    const sunSpinOmega    = 2 * Math.PI * (DAYS_PER_SECOND / (25)); // ~25 days (equator), stylized

    // Lights
    const sunLight = new THREE.PointLight(0xffffff, 3, 0, 2); // bright point light at sun
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    const ambient = new THREE.AmbientLight(0x222222);
    scene.add(ambient);

    // Sun (emissive)
    const sunGeo = new THREE.SphereGeometry(SUN_RADIUS, 64, 64);
    const sunMat = new THREE.MeshStandardMaterial({
      color: 0xffdd66,
      emissive: 0xffcc44,
      emissiveIntensity: 1.5,
      roughness: 1.0,
      metalness: 0.0
    });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    sun.position.set(0, 0, 0);
    scene.add(sun);

    // Earth
    const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS, 48, 48);
    const earthMat = new THREE.MeshStandardMaterial({
      color: 0x2b6cff, // blue
      roughness: 0.9,
      metalness: 0.0
    });
    const earth = new THREE.Mesh(earthGeo, earthMat);

    // Moon
    const moonGeo = new THREE.SphereGeometry(MOON_RADIUS, 32, 32);
    const moonMat = new THREE.MeshStandardMaterial({
      color: 0xbfbfbf, // gray
      roughness: 1.0,
      metalness: 0.0
    });
    const moon = new THREE.Mesh(moonGeo, moonMat);

    // Orbit pivots
    const earthOrbit = new THREE.Object3D(); // revolves around sun
    scene.add(earthOrbit);

    earth.position.set(EARTH_ORBIT_RADIUS, 0, 0);
    earth.rotation.z = THREE.MathUtils.degToRad(23.5); // axial tilt
    earthOrbit.add(earth);

    const moonOrbit = new THREE.Object3D(); // revolves around earth
    moonOrbit.position.set(EARTH_ORBIT_RADIUS, 0, 0); // center at earth
    earthOrbit.add(moonOrbit);

    moon.position.set(MOON_ORBIT_RADIUS, 0, 0);
    moonOrbit.add(moon);

    // Orbit rings (visual guides)
    function makeOrbitRing(radius, color = 0x444444) {
      const segments = 256;
      const pts = [];
      for (let i = 0; i <= segments; i++) {
        const t = (i / segments) * Math.PI * 2;
        pts.push(new THREE.Vector3(Math.cos(t) * radius, 0, Math.sin(t) * radius));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.35 });
      const ring = new THREE.Line(geo, mat);
      return ring;
    }

    // Earth's orbital ring around the sun (world-centered)
    const earthRing = makeOrbitRing(EARTH_ORBIT_RADIUS, 0x555577);
    scene.add(earthRing);

    // Moon's orbital ring around the earth (attached to the earth's position)
    const moonRing = makeOrbitRing(MOON_ORBIT_RADIUS, 0x555555);
    moonRing.rotation.x = 0; // ecliptic plane; could tilt slightly if desired
    moonOrbit.add(moonRing);

    // Starfield
    function addStars(count = 4000, radius = 1200) {
      const positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        // Random point on a sphere shell
        const theta = Math.acos(THREE.MathUtils.randFloatSpread(2)); // 0..pi
        const phi = Math.random() * Math.PI * 2;
        const r = radius * (0.85 + Math.random() * 0.15); // slight variance
        const x = r * Math.sin(theta) * Math.cos(phi);
        const y = r * Math.cos(theta);
        const z = r * Math.sin(theta) * Math.sin(phi);
        positions.set([x, y, z], i * 3);
      }
      const starGeo = new THREE.BufferGeometry();
      starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.2,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.9
      });
      const stars = new THREE.Points(starGeo, starMat);
      scene.add(stars);
    }
    addStars();

    // Animation
    const clock = new THREE.Clock();

    function animate() {
      const dt = clock.getDelta();

      // Revolutions
      earthOrbit.rotation.y += earthOrbitOmega * dt;  // Earth around Sun
      moonOrbit.rotation.y  += moonOrbitOmega  * dt;  // Moon around Earth

      // Spins
      earth.rotation.y += earthSpinOmega * dt;        // Earth's day
      sun.rotation.y   += sunSpinOmega   * dt;        // Sun's rotation (stylized)

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>