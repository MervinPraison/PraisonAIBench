<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Data Dashboard - Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0f1a;
      --panel-bg: rgba(14, 23, 42, 0.6);
      --panel-border: rgba(255,255,255,0.08);
      --text: #e5e7eb;
      --accent: #60a5fa;
      --muted: #94a3b8;
      --btn-bg: rgba(255,255,255,0.06);
      --btn-bg-hover: rgba(255,255,255,0.12);
      --btn-border: rgba(255,255,255,0.12);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .light {
      --bg: #f5f7fb;
      --panel-bg: rgba(255,255,255,0.8);
      --panel-border: rgba(0,0,0,0.08);
      --text: #0f172a;
      --accent: #2563eb;
      --muted: #475569;
      --btn-bg: rgba(15, 23, 42, 0.04);
      --btn-bg-hover: rgba(15, 23, 42, 0.08);
      --btn-border: rgba(0,0,0,0.1);
      --shadow: 0 12px 36px rgba(0,0,0,0.15);
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
    }

    #app {
      position: fixed;
      inset: 0;
      display: block;
    }

    #ui {
      position: fixed;
      top: 16px;
      left: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
      user-select: none;
    }

    .panel {
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: var(--shadow);
      min-width: 280px;
    }

    .panel h2 {
      margin: 0 0 8px;
      font-size: 14px;
      letter-spacing: 0.02em;
      font-weight: 700;
      text-transform: uppercase;
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .row + .row {
      margin-top: 8px;
    }

    button, .toggle {
      appearance: none;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 13px;
      line-height: 1.2;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.06s ease;
    }
    button:hover, .toggle:hover {
      background: var(--btn-bg-hover);
    }
    button:active {
      transform: translateY(1px);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .toggle input {
      margin: 0;
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
    }

    .view-buttons button {
      flex: 1 1 auto;
    }

    #tooltip {
      position: fixed;
      pointer-events: none;
      z-index: 20;
      transform: translate(12px, 12px);
      background: rgba(17, 24, 39, 0.9);
      color: #e5e7eb;
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.35;
      max-width: 260px;
      opacity: 0;
      transition: opacity 0.12s ease;
      white-space: nowrap;
    }
    .light #tooltip {
      background: rgba(255,255,255,0.95);
      color: #0f172a;
      border-color: rgba(0,0,0,0.08);
    }

    .legend {
      display: flex;
      gap: 12px;
      font-size: 12px;
      align-items: center;
      flex-wrap: wrap;
      color: var(--muted);
    }
    .legend .key {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .legend .swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      border: 1px solid var(--panel-border);
    }

    .footer-note {
      position: fixed;
      right: 16px;
      bottom: 12px;
      z-index: 10;
      color: var(--muted);
      font-size: 12px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      padding: 8px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
  </style>
</head>
<body class="">
  <div id="app"></div>

  <div id="ui">
    <div class="panel">
      <h2>Scene Controls</h2>
      - Views
      <div class="row view-buttons">
        <button id="view-iso">Isometric</button>
        <button id="view-top">Top</button>
        <button id="view-front">Front</button>
        <button id="view-side">Side</button>
      </div>

      - Layers
      <div class="row">
        <label class="toggle"><input id="toggle-bars" type="checkbox" checked /> Bars</label>
        <label class="toggle"><input id="toggle-scatter" type="checkbox" checked /> Scatter</label>
        <label class="toggle"><input id="toggle-ribbons" type="checkbox" checked /> Ribbons</label>
      </div>

      - Actions
      <div class="row">
        <button id="regen">Regenerate Data</button>
        <button id="export">Export CSV</button>
        <button id="theme">Toggle Theme</button>
      </div>

      <div class="row legend" id="legend">
        <div class="key"><span class="swatch" id="swatch-bars"></span> Bars</div>
        <div class="key"><span class="swatch" id="swatch-scatter"></span> Scatter</div>
        <div class="key"><span class="swatch" id="swatch-ribbons"></span> Ribbons</div>
      </div>
    </div>
  </div>

  <div id="tooltip"></div>

  <div class="footer-note">Tip: Hover shapes for tooltips • Drag to orbit • Shift+Drag to pan • Wheel to zoom</div>

  <!-- Three.js and helpers -->
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>

  <script>
    (() => {
      // Core THREE elements
      let scene, camera, renderer, controls, raycaster;
      let gridHelper, axesHelper, ambientLight, dirLight;
      let app = document.getElementById('app');
      let tooltip = document.getElementById('tooltip');

      // Data + objects
      let dataValues = [];       // 2D array [xi][zi] -> value
      let scatterData = [];      // array of {x, y, z, label}
      let nx = 12, nz = 16;
      let step = 1.2;
      let yScale = 4.0;          // overall height scale
      let barsGroup, scatterGroup, ribbonsGroup;
      const pickables = [];      // meshes and lines for raycasting
      let hovered = null;

      // Themes
      let themeName = 'dark';
      const theme = {
        dark: {
          bg: 0x0b0f1a,
          grid: 0x1f2a44,
          axes: 0xaab1c5,
          bars: 0x60a5fa,
          barsEmissive: 0x123a6b,
          scatter: 0x34d399,
          ribbons: 0xf87171,
          lights: { ambient: 0x8899aa, dir: 0xffffff }
        },
        light: {
          bg: 0xf5f7fb,
          grid: 0xcbd5e1,
          axes: 0x1f2937,
          bars: 0x3b82f6,
          barsEmissive: 0x1d4ed8,
          scatter: 0x10b981,
          ribbons: 0xef4444,
          lights: { ambient: 0x8899aa, dir: 0xffffff }
        }
      };

      // Materials (created per object for highlight control)
      let barMaterials = [];
      let scatterMaterials = [];
      let ribbonMaterials = [];

      // UI
      const ui = {
        viewIso: document.getElementById('view-iso'),
        viewTop: document.getElementById('view-top'),
        viewFront: document.getElementById('view-front'),
        viewSide: document.getElementById('view-side'),
        toggleBars: document.getElementById('toggle-bars'),
        toggleScatter: document.getElementById('toggle-scatter'),
        toggleRibbons: document.getElementById('toggle-ribbons'),
        regen: document.getElementById('regen'),
        exportBtn: document.getElementById('export'),
        themeToggle: document.getElementById('theme'),
        swatchBars: document.getElementById('swatch-bars'),
        swatchScatter: document.getElementById('swatch-scatter'),
        swatchRibbons: document.getElementById('swatch-ribbons')
      };

      init();
      generateData();
      buildSceneFromData();
      animate();

      function init() {
        // Scene
        scene = new THREE.Scene();

        // Camera
        const fov = 50;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.1, far = 1000;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(10, 10, 10);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        app.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.07;
        controls.target.set(0, 0, 0);
        controls.maxPolarAngle = Math.PI * 0.49;
        controls.minDistance = 2;
        controls.maxDistance = 60;

        // Raycaster
        raycaster = new THREE.Raycaster();
        raycaster.params.Line = { threshold: 0.2 };

        // Grid + axes
        const size = Math.max(nx, nz) * step * 1.2;
        gridHelper = new THREE.GridHelper(size, Math.max(nx, nz), 0x444444, 0x444444);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        axesHelper = new THREE.AxesHelper(size * 0.6);
        axesHelper.position.y = 0.001; // slightly above grid to avoid z-fighting
        scene.add(axesHelper);

        // Lights
        ambientLight = new THREE.AmbientLight(theme.dark.lights.ambient, 0.7);
        scene.add(ambientLight);

        dirLight = new THREE.DirectionalLight(theme.dark.lights.dir, 1.0);
        dirLight.position.set(6, 10, 6);
        dirLight.castShadow = false;
        scene.add(dirLight);

        // Groups
        barsGroup = new THREE.Group();
        scatterGroup = new THREE.Group();
        ribbonsGroup = new THREE.Group();
        scene.add(barsGroup, scatterGroup, ribbonsGroup);

        // UI events
        ui.viewIso.addEventListener('click', () => gotoView('iso'));
        ui.viewTop.addEventListener('click', () => gotoView('top'));
        ui.viewFront.addEventListener('click', () => gotoView('front'));
        ui.viewSide.addEventListener('click', () => gotoView('side'));

        ui.toggleBars.addEventListener('change', () => { barsGroup.visible = ui.toggleBars.checked; });
        ui.toggleScatter.addEventListener('change', () => { scatterGroup.visible = ui.toggleScatter.checked; });
        ui.toggleRibbons.addEventListener('change', () => { ribbonsGroup.visible = ui.toggleRibbons.checked; });

        ui.regen.addEventListener('click', () => {
          generateData();
          rebuildVisuals();
        });

        ui.exportBtn.addEventListener('click', () => exportCSV());

        ui.themeToggle.addEventListener('click', () => {
          themeName = themeName === 'dark' ? 'light' : 'dark';
          document.body.classList.toggle('light', themeName === 'light');
          applyTheme();
        });

        // Pointer events
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('resize', onResize);

        // Initial theme
        applyTheme();

        // Initial camera view
        gotoView('iso', 0);
      }

      function applyTheme() {
        const t = theme[themeName];
        renderer.setClearColor(t.bg, 1);
        gridHelper.material.color.setHex(t.grid);
        for (let i = 0; i < gridHelper.geometry.attributes.color?.count || 0; i++) {
          // Not necessary but keep for consistency
        }
        // Axes material color is fixed per axis; can't change easily. We can tint by overlaying lines:
        axesHelper.material.color.setHex(t.axes);

        ambientLight.color.setHex(t.lights.ambient);
        dirLight.color.setHex(t.lights.dir);

        // Update all materials colors
        barMaterials.forEach(m => { m.color.setHex(t.bars); m.emissive.setHex(0x000000); });
        scatterMaterials.forEach(m => m.color.setHex(t.scatter));
        ribbonMaterials.forEach(m => m.color.setHex(t.ribbons));

        ui.swatchBars.style.background = '#' + t.bars.toString(16).padStart(6, '0');
        ui.swatchScatter.style.background = '#' + t.scatter.toString(16).padStart(6, '0');
        ui.swatchRibbons.style.background = '#' + t.ribbons.toString(16).padStart(6, '0');
      }

      function generateData() {
        // Produce a smooth, interesting surface using sin/cos + multi-octave noise
        dataValues = [];
        const seed = Math.random() * 1000;
        for (let xi = 0; xi < nx; xi++) {
          const col = [];
          for (let zi = 0; zi < nz; zi++) {
            const u = xi / (nx - 1 || 1);
            const v = zi / (nz - 1 || 1);

            const f1 = Math.sin((u * Math.PI * 2.0) + seed * 0.13) * 0.6 + 0.4;
            const f2 = Math.cos((v * Math.PI * 1.6) + seed * 0.17) * 0.5 + 0.5;
            // Smooth bumps
            const ridge = Math.sin((u + v) * Math.PI * 1.25 + seed * 0.07) * 0.35 + 0.35;
            // Gentle noise
            const n = perlin2(u * 2.0 + seed, v * 2.0 - seed) * 0.25 + 0.25;

            let value = (f1 * 0.45 + f2 * 0.35 + ridge * 0.2) * 0.9 + n * 0.6;
            value = Math.max(0, value);
            col.push(value);
          }
          dataValues.push(col);
        }

        // Scatter data aligned to the surface + random jitter
        scatterData = [];
        const scatterCount = Math.floor(nx * nz * 0.6);
        for (let i = 0; i < scatterCount; i++) {
          const xfi = Math.random() * (nx - 1);
          const zfi = Math.random() * (nz - 1);
          const xi = Math.floor(xfi);
          const zi = Math.floor(zfi);
          const xf = xfi - xi;
          const zf = zfi - zi;
          const v = bilinear(
            dataValues[clampIndex(xi, nx)][clampIndex(zi, nz)],
            dataValues[clampIndex(xi + 1, nx)][clampIndex(zi, nz)],
            dataValues[clampIndex(xi, nx)][clampIndex(zi + 1, nz)],
            dataValues[clampIndex(xi + 1, nx)][clampIndex(zi + 1, nz)],
            xf, zf
          );
          const jitterY = (Math.random() - 0.5) * 0.25;
          scatterData.push({
            x: (xfi - (nx - 1) / 2) * step + (Math.random() - 0.5) * step * 0.15,
            z: (zfi - (nz - 1) / 2) * step + (Math.random() - 0.5) * step * 0.15,
            y: (v + jitterY) * yScale,
            label: `P${i}`
          });
        }
      }

      function buildSceneFromData() {
        clearGroups();
        barMaterials.length = 0;
        scatterMaterials.length = 0;
        ribbonMaterials.length = 0;

        // Bars (grid)
        const barGeomBase = new THREE.BoxGeometry(step * 0.7, 1, step * 0.7); // height=1, scale later
        for (let xi = 0; xi < nx; xi++) {
          for (let zi = 0; zi < nz; zi++) {
            const value = dataValues[xi][zi];
            const h = Math.max(0.02, value * yScale);
            const gx = (xi - (nx - 1) / 2) * step;
            const gz = (zi - (nz - 1) / 2) * step;

            const mat = new THREE.MeshStandardMaterial({
              color: theme[themeName].bars,
              metalness: 0.1,
              roughness: 0.4
            });
            barMaterials.push(mat);

            const bar = new THREE.Mesh(barGeomBase.clone(), mat);
            bar.scale.y = h;           // scale height
            bar.position.set(gx, h / 2, gz);
            bar.castShadow = false;
            bar.receiveShadow = false;

            bar.userData = {
              type: 'bar',
              xi, zi,
              x: gx, z: gz,
              value: value
            };

            barsGroup.add(bar);
            pickables.push(bar);
          }
        }

        // Scatter (spheres)
        const sphereGeom = new THREE.SphereGeometry(step * 0.15, 16, 16);
        scatterData.forEach((p, idx) => {
          const mat = new THREE.MeshStandardMaterial({
            color: theme[themeName].scatter,
            metalness: 0.05,
            roughness: 0.35
          });
          scatterMaterials.push(mat);
          const s = new THREE.Mesh(sphereGeom, mat);
          s.position.set(p.x, Math.max(0.02, p.y), p.z);
          s.userData = { type: 'point', index: idx, ...p };
          scatterGroup.add(s);
          pickables.push(s);
        });

        // Ribbons (lines across Z for each X series)
        for (let xi = 0; xi < nx; xi++) {
          const points = [];
          for (let zi = 0; zi < nz; zi++) {
            const gx = (xi - (nx - 1) / 2) * step;
            const gz = (zi - (nz - 1) / 2) * step;
            const y = dataValues[xi][zi] * yScale;
            points.push(new THREE.Vector3(gx, Math.max(0.02, y), gz));
          }
          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const mat = new THREE.LineBasicMaterial({ color: theme[themeName].ribbons, transparent: true, opacity: 0.95 });
          ribbonMaterials.push(mat);
          const line = new THREE.Line(geom, mat);
          line.userData = { type: 'ribbon', xi, points };
          // Improve line raycasting sensitivity
          // The threshold is set globally in raycaster.params.Line
          ribbonsGroup.add(line);
          pickables.push(line);
        }
      }

      function rebuildVisuals() {
        // Clear pickables
        pickables.length = 0;
        buildSceneFromData();
      }

      function clearGroups() {
        // Remove all children from groups and dispose geometries/materials to prevent leaks
        [barsGroup, scatterGroup, ribbonsGroup].forEach(group => {
          while (group.children.length) {
            const obj = group.children.pop();
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
              else obj.material.dispose();
            }
          }
        });
      }

      function gotoView(name, duration = 1000) {
        // Compute extents
        const width = (nx - 1) * step;
        const depth = (nz - 1) * step;
        const maxY = yScale * 1.2;
        const center = new THREE.Vector3(0, 0.6 * maxY, 0);

        let camPos;
        switch (name) {
          case 'top':
            camPos = new THREE.Vector3(0, Math.max(8, Math.max(width, depth) * 1.4), 0.01);
            break;
          case 'front':
            camPos = new THREE.Vector3(0, maxY * 1.0, depth * 1.6);
            break;
          case 'side':
            camPos = new THREE.Vector3(width * 1.6, maxY * 1.0, 0);
            break;
          case 'iso':
          default:
            camPos = new THREE.Vector3(width * 0.9, maxY * 1.2, depth * 0.9);
            break;
        }

        tweenCamera(camPos, center, duration);
      }

      function tweenCamera(targetPos, targetLook, duration = 1000) {
        const start = { x: camera.position.x, y: camera.position.y, z: camera.position.z,
                        tx: controls.target.x, ty: controls.target.y, tz: controls.target.z };
        const end = { x: targetPos.x, y: targetPos.y, z: targetPos.z,
                      tx: targetLook.x, ty: targetLook.y, tz: targetLook.z };

        controls.enabled = false;

        new TWEEN.Tween(start)
          .to(end, duration)
          .easing(TWEEN.Easing.Quadratic.InOut)
          .onUpdate(() => {
            camera.position.set(start.x, start.y, start.z);
            controls.target.set(start.tx, start.ty, start.tz);
            camera.lookAt(controls.target);
          })
          .onComplete(() => {
            controls.enabled = true;
          })
          .start();
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onPointerMove(e) {
        // Update tooltip position
        tooltip.style.left = e.clientX + 'px';
        tooltip.style.top = e.clientY + 'px';

        // Raycast
        const rect = renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
          ((e.clientX - rect.left) / rect.width) * 2 - 1,
          -((e.clientY - rect.top) / rect.height) * 2 + 1
        );
        raycaster.setFromCamera(mouse, camera);
        raycaster.params.Line.threshold = Math.max(0.1, step * 0.35);

        const intersects = raycaster.intersectObjects([scatterGroup, barsGroup, ribbonsGroup], true);
        if (intersects.length) {
          const it = intersects[0];
          const obj = findPickable(it.object);
          if (hovered !== obj) {
            clearHover();
            setHover(obj, it);
          }
          updateTooltip(obj, it.point);
        } else {
          clearHover();
          hideTooltip();
        }
      }

      function findPickable(obj) {
        // Traverse up until direct child of one of the groups or with userData.type
        while (obj && !obj.userData?.type) obj = obj.parent;
        return obj || null;
      }

      function setHover(obj, intersect) {
        hovered = obj;
        if (!obj) return;

        const t = theme[themeName];
        if (obj.userData.type === 'bar') {
          // Emphasize bar
          obj.userData._origEmissive = obj.material.emissive.getHex();
          obj.userData._origScale = obj.scale.y;
          obj.material.emissive.setHex(t.barsEmissive);
          obj.scale.y = obj.userData._origScale * 1.06;
          obj.position.y = (obj.scale.y) / 2;
          showTooltip();
        } else if (obj.userData.type === 'point') {
          obj.userData._origScale3 = obj.scale.clone();
          obj.scale.multiplyScalar(1.35);
          showTooltip();
        } else if (obj.userData.type === 'ribbon') {
          obj.userData._origColor = obj.material.color.getHex();
          const hoverColor = lightenColor(t.ribbons, 0.35);
          obj.material.color.setHex(hoverColor);
          showTooltip();
        }
      }

      function clearHover() {
        if (!hovered) return;
        if (hovered.userData.type === 'bar') {
          if (hovered.userData._origEmissive !== undefined) {
            hovered.material.emissive.setHex(hovered.userData._origEmissive);
          }
          if (hovered.userData._origScale !== undefined) {
            hovered.scale.y = hovered.userData._origScale;
            hovered.position.y = hovered.scale.y / 2;
          }
        } else if (hovered.userData.type === 'point') {
          if (hovered.userData._origScale3) hovered.scale.copy(hovered.userData._origScale3);
        } else if (hovered.userData.type === 'ribbon') {
          if (hovered.userData._origColor !== undefined) {
            hovered.material.color.setHex(hovered.userData._origColor);
          }
        }
        hovered = null;
      }

      function showTooltip() {
        tooltip.style.opacity = '1';
      }

      function hideTooltip() {
        tooltip.style.opacity = '0';
      }

      function updateTooltip(obj, point) {
        if (!obj) return;
        if (obj.userData.type === 'bar') {
          const d = obj.userData;
          tooltip.innerHTML = [
            '<strong>Bar</strong>',
            `xIndex: ${d.xi}, zIndex: ${d.zi}`,
            `x: ${fmt(d.x)}, z: ${fmt(d.z)}, y: ${fmt(d.value * yScale)}`
          ].join('<br/>');
        } else if (obj.userData.type === 'point') {
          const p = obj.userData;
          tooltip.innerHTML = [
            '<strong>Point</strong>',
            `label: ${p.label}`,
            `x: ${fmt(p.x)}, z: ${fmt(p.z)}, y: ${fmt(p.y)}`
          ].join('<br/>');
        } else if (obj.userData.type === 'ribbon') {
          // Find nearest zi to intersection point
          const xi = obj.userData.xi;
          const zi = nearestZi(point.z);
          const value = dataValues[xi][zi];
          tooltip.innerHTML = [
            '<strong>Ribbon</strong>',
            `xIndex: ${xi}, near zIndex: ${zi}`,
            `y: ${fmt(value * yScale)}`
          ].join('<br/>');
        }
      }

      function nearestZi(zWorld) {
        const z0 = - (nz - 1) / 2 * step;
        const idx = Math.round((zWorld - z0) / step);
        return Math.min(nz - 1, Math.max(0, idx));
      }

      function animate(time) {
        requestAnimationFrame(animate);
        controls.update();
        TWEEN.update(time);
        renderer.render(scene, camera);
      }

      function exportCSV() {
        // Export grid data (bars)
        const rows = [];
        rows.push('xIndex,zIndex,x,z,value,height');
        for (let xi = 0; xi < nx; xi++) {
          for (let zi = 0; zi < nz; zi++) {
            const x = (xi - (nx - 1) / 2) * step;
            const z = (zi - (nz - 1) / 2) * step;
            const value = dataValues[xi][zi];
            rows.push([xi, zi, fmt(x), fmt(z), fmt(value), fmt(value * yScale)].join(','));
          }
        }
        const csv = rows.join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g, '-');
        a.download = `dataset_${stamp}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Utils

      function fmt(n) {
        return typeof n === 'number' ? n.toFixed(3) : n;
      }

      function clampIndex(i, n) {
        return Math.max(0, Math.min(n - 1, i));
      }

      function bilinear(v00, v10, v01, v11, u, v) {
        const a = v00 * (1 - u) + v10 * u;
        const b = v01 * (1 - u) + v11 * u;
        return a * (1 - v) + b * v;
      }

      function lightenColor(hex, amt) {
        // amt in [0..1]
        const c = new THREE.Color(hex);
        const hsl = { h: 0, s: 0, l: 0 };
        c.getHSL(hsl);
        hsl.l = Math.min(1, hsl.l + amt);
        c.setHSL(hsl.h, hsl.s, hsl.l);
        return c.getHex();
      }

      // Simple 2D perlin-like noise via value noise
      function perlin2(x, y) {
        function hash(n) {
          return Math.sin(n) * 43758.5453123 % 1;
        }
        function fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        }
        function lerp(a, b, t) {
          return a + (b - a) * t;
        }
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const xf = x - xi;
        const yf = y - yi;
        const tl = hash(xi * 49632 + yi * 325176);
        const tr = hash((xi + 1) * 49632 + yi * 325176);
        const bl = hash(xi * 49632 + (yi + 1) * 325176);
        const br = hash((xi + 1) * 49632 + (yi + 1) * 325176);
        const u = fade(xf);
        const v = fade(yf);
        const top = lerp(tl, tr, u);
        const bottom = lerp(bl, br, u);
        return lerp(top, bottom, v) * 2 - 1; // [-1..1]
      }

    })();
  </script>
</body>
</html>