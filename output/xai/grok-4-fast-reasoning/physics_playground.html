<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Playground</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #ui label { display: block; margin: 5px 0; }
        #ui input[type="range"] { width: 100px; }
        button { margin: 5px 0; padding: 5px 10px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui">
        <button id="reset">Reset</button>
        <label>Gravity: <input type="range" id="gravity" min="-20" max="0" step="0.1" value="-9.8"></label>
        <span id="gravityValue">-9.8</span>
        <label>Slow Motion: <input type="checkbox" id="slowmo"></label>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script type="module">
        import * as CANNON from 'https://cdn.skypack.dev/cannon-es';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Materials
        const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
        const ragdollMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

        // Arrays to sync
        const meshes = [];
        const bodies = [];

        // Mouse interaction
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let selectedBody = null;
        let selectedMesh = null;
        const dragForce = 100;
        const dragDistance = new THREE.Vector3();

        // UI
        const gravitySlider = document.getElementById('gravity');
        const gravityValue = document.getElementById('gravityValue');
        const slowmoCheckbox = document.getElementById('slowmo');
        const resetButton = document.getElementById('reset');

        gravitySlider.oninput = (e) => {
            const value = parseFloat(e.target.value);
            world.gravity.set(0, value, 0);
            gravityValue.textContent = value.toFixed(1);
        };
        slowmoCheckbox.onchange = (e) => {
            timeScale = e.target.checked ? 0.1 : 1;
        };
        resetButton.onclick = resetScene;

        // Event listeners for mouse
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshes.filter(m => m.userData.body.mass > 0)); // Only dynamic bodies

            if (intersects.length > 0) {
                selectedMesh = intersects[0].object;
                selectedBody = selectedMesh.userData.body;
                renderer.domElement.style.cursor = 'grabbing';
            }
        }

        function onMouseMove(event) {
            if (selectedBody) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // Intersect with a horizontal plane at the body's y position for dragging
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -selectedBody.position.y);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);

                if (intersectPoint) {
                    dragDistance.copy(intersectPoint).sub(selectedBody.position);
                    const force = dragDistance.normalize().multiplyScalar(dragForce);
                    selectedBody.applyForce(new CANNON.Vec3(force.x, force.y, force.z), selectedBody.position);
                }
            } else {
                // Update mouse for potential hover, but skip for simplicity
            }
        }

        function onMouseUp() {
            selectedBody = null;
            selectedMesh = null;
            renderer.domElement.style.cursor = 'default';
        }

        // Create ground
        function createGround() {
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            meshes.push(groundMesh);
            groundMesh.userData.body = groundBody; // Even static
        }

        // Create box
        function createBox(size, position, material = boxMaterial, mass = 1) {
            const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
            const body = new CANNON.Body({ mass });
            body.addShape(shape);
            body.position.set(position.x, position.y, position.z);
            world.addBody(body);
            bodies.push(body);

            const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(body.position);
            mesh.castShadow = true;
            scene.add(mesh);
            meshes.push(mesh);
            mesh.userData.body = body;
            return { body, mesh };
        }

        // Create sphere
        function createSphere(radius, position, material = sphereMaterial, mass = 1) {
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass });
            body.addShape(shape);
            body.position.set(position.x, position.y, position.z);
            world.addBody(body);
            bodies.push(body);

            const geometry = new THREE.SphereGeometry(radius);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(body.position);
            mesh.castShadow = true;
            scene.add(mesh);
            meshes.push(mesh);
            mesh.userData.body = body;
            return { body, mesh };
        }

        // Create hinge constraint
        function createHinge(bodyA, pivotA, bodyB, pivotB, axis = new CANNON.Vec3(0, 1, 0)) {
            const constraint = new CANNON.HingeConstraint(bodyA, pivotA, bodyB, pivotB, axis);
            world.addConstraint(constraint);
            return constraint;
        }

        // Create simple ragdoll
        function createRagdoll(x = -5, y = 1) {
            // Torso
            const torso = createBox({x: 1, y: 2, z: 0.5}, {x, y: y+1, z: 0}, ragdollMaterial, 1);
            torso.mesh.name = 'torso';

            // Head
            const head = createSphere(0.5, {x, y: y+3, z: 0}, ragdollMaterial, 0.5);
            head.mesh.name = 'head';
            // Hinge head to torso top
            createHinge(torso.body, new CANNON.Vec3(0, 1, 0), head.body, new CANNON.Vec3(0, -0.5, 0), new CANNON.Vec3(1, 0, 0));

            // Left arm
            const leftArm = createBox({x: 0.5, y: 2, z: 0.2}, {x: x-1.25, y: y+2, z: 0}, ragdollMaterial, 0.3);
            leftArm.mesh.name = 'leftArm';
            createHinge(torso.body, new CANNON.Vec3(-0.5, 0, 0), leftArm.body, new CANNON.Vec3(0.25, 0, 0), new CANNON.Vec3(0, 0, 1));

            // Right arm
            const rightArm = createBox({x: 0.5, y: 2, z: 0.2}, {x: x+1.25, y: y+2, z: 0}, ragdollMaterial, 0.3);
            rightArm.mesh.name = 'rightArm';
            createHinge(torso.body, new CANNON.Vec3(0.5, 0, 0), rightArm.body, new CANNON.Vec3(-0.25, 0, 0), new CANNON.Vec3(0, 0, 1));

            // Left leg
            const leftLeg = createBox({x: 0.5, y: 2, z: 0.2}, {x: x-0.25, y, z: 0}, ragdollMaterial, 0.5);
            leftLeg.mesh.name = 'leftLeg';
            createHinge(torso.body, new CANNON.Vec3(-0.25, -1, 0), leftLeg.body, new CANNON.Vec3(0.25, 1, 0), new CANNON.Vec3(0, 0, 1));

            // Right leg
            const rightLeg = createBox({x: 0.5, y: 2, z: 0.2}, {x: x+0.25, y, z: 0}, ragdollMaterial, 0.5);
            rightLeg.mesh.name = 'rightLeg';
            createHinge(torso.body, new CANNON.Vec3(0.25, -1, 0), rightLeg.body, new CANNON.Vec3(-0.25, 1, 0), new CANNON.Vec3(0, 0, 1));

            return { torso, head, leftArm, rightArm, leftLeg, rightLeg };
        }

        // Initial scene setup
        function initScene() {
            createGround();

            // Stackable boxes
            for (let i = 0; i < 5; i++) {
                createBox({x:1, y:1, z:1}, {x: 0, y: (i + 1), z: 0});
            }

            // Spheres
            createSphere(0.5, {x: 3, y: 5, z: 0});
            createSphere(0.5, {x: 4, y: 4, z: 2});
            createSphere(0.5, {x: 2, y: 3, z: -1});

            // Hinge joint example: two boxes connected
            const box1 = createBox({x:1, y:1, z:1}, {x: 5, y: 2, z: -0.5}, boxMaterial, 1);
            const box2 = createBox({x:1, y:1, z:1}, {x: 5, y: 2, z: 0.5}, boxMaterial, 1);
            createHinge(box1.body, new CANNON.Vec3(0.5, 0, 0), box2.body, new CANNON.Vec3(-0.5, 0, 0), new CANNON.Vec3(0, 1, 0));

            // Ragdoll
            createRagdoll(-5, 0.5);
        }

        // Reset function
        function resetScene() {
            // Remove all dynamic bodies and meshes
            bodies.forEach(body => world.removeBody(body));
            meshes.forEach(mesh => scene.remove(mesh));
            bodies.length = 0;
            meshes.length = 0;

            // Recreate ground and initial objects
            initScene();
        }

        // Animation
        const clock = new THREE.Clock();
        let timeScale = 1;

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            world.step(1 / 60, delta * timeScale, 3);

            // Sync meshes to bodies
            meshes.forEach((mesh, index) => {
                if (mesh.userData.body) {
                    mesh.position.copy(mesh.userData.body.position);
                    mesh.quaternion.copy(mesh.userData.body.quaternion);
                }
            });

            renderer.render(scene, camera);
        }

        // Initialize
        initScene();
        animate();
    </script>
</body>
</html>