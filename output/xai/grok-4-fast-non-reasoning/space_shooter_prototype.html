<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        #healthBar {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            width: 100%;
            transition: width 0.3s ease;
        }
        
        .score {
            font-size: 24px;
            text-shadow: 0 0 10px #00ff00;
            margin: 5px 0;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
        
        #controls.mobile {
            display: block;
        }
        
        #controls.desktop {
            display: block;
        }
        
        @media (max-width: 768px) {
            #controls.desktop {
                display: none;
            }
            #controls.mobile {
                display: block;
                font-size: 14px;
            }
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        
        #restartBtn {
            background: #00ff00;
            color: black;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        #restartBtn:hover {
            background: #00cc00;
        }
        
        .touch-zone {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            z-index: 50;
            opacity: 0;
        }
        
        #leftZone {
            left: 0;
        }
        
        #rightZone {
            right: 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div class="score">SCORE: <span id="score">0</span></div>
            <div class="score">HEALTH</div>
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
            <div class="score">WAVE: <span id="wave">1</span></div>
        </div>
        
        <div id="controls">
            <div class="desktop">Use A/D or Arrow Keys to move • SPACE to shoot</div>
            <div class="mobile">Swipe Left/Right to move • Tap to shoot</div>
        </div>
        
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <div class="score">Final Score: <span id="finalScore">0</span></div>
            <button id="restartBtn">Restart Game</button>
        </div>
        
        <!-- Mobile touch controls -->
        <div class="touch-zone" id="leftZone"></div>
        <div class="touch-zone" id="rightZone"></div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

    <script>
        class SpaceShooter {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.clock = new THREE.Clock();
                
                // Game state
                this.score = 0;
                this.health = 100;
                this.wave = 1;
                this.gameRunning = true;
                this.lastShotTime = 0;
                this.shotCooldown = 200;
                this.enemies = [];
                this.lasers = [];
                this.particles = [];
                this.enemyPool = [];
                this.laserPool = [];
                this.particlePool = [];
                
                // Difficulty scaling
                this.baseEnemySpeed = 2;
                this.enemySpawnRate = 0.02;
                this.waveEnemies = 5;
                
                // Player
                this.player = {
                    mesh: null,
                    position: new THREE.Vector3(0, 0, 0),
                    speed: 10,
                    width: 2,
                    height: 2
                };
                
                // Controls
                this.keys = {};
                this.touchActive = false;
                this.touchStartX = 0;
                this.targetX = 0;
                
                this.init();
                this.setupControls();
                this.createStarfield();
                this.createPlayer();
                this.setupPostProcessing();
                this.animate();
            }
            
            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000011);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                this.camera.position.z = 50;
                
                // Create pools
                this.createPools();
            }
            
            setupPostProcessing() {
                this.composer = new THREE.EffectComposer(this.renderer);
                this.renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(this.renderPass);
                
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, // strength
                    0.4, // radius
                    0.85 // threshold
                );
                this.composer.addPass(bloomPass);
            }
            
            createStarfield() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsCount = 10000;
                const positions = new Float32Array(starsCount * 3);
                
                for (let i = 0; i < starsCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 2000;
                    positions[i + 1] = (Math.random() - 0.5) * 2000;
                    positions[i + 2] = (Math.random() - 0.5) * 2000;
                }
                
                starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2,
                    sizeAttenuation: false
                });
                
                this.starfield = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(this.starfield);
            }
            
            createPlayer() {
                const geometry = new THREE.BoxGeometry(this.player.width, this.player.height, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                this.player.mesh = new THREE.Mesh(geometry, material);
                this.player.mesh.position.copy(this.player.position);
                this.scene.add(this.player.mesh);
                
                // Add lights
                const pointLight = new THREE.PointLight(0x00ff00, 1, 50);
                pointLight.position.set(0, 0, 0);
                this.player.mesh.add(pointLight);
                
                // Player glow
                const glowGeometry = new THREE.SphereGeometry(3, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3
                });
                this.playerGlow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.scene.add(this.playerGlow);
            }
            
            createPools() {
                // Enemy pool
                const enemyGeometry = new THREE.ConeGeometry(1, 3, 8);
                const enemyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0x440000
                });
                
                for (let i = 0; i < 50; i++) {
                    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    enemy.visible = false;
                    enemy.userData = { health: 1, speed: this.baseEnemySpeed };
                    this.scene.add(enemy);
                    this.enemyPool.push(enemy);
                }
                
                // Laser pool
                const laserGeometry = new THREE.BoxGeometry(0.2, 2, 0.2);
                const laserMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                
                for (let i = 0; i < 100; i++) {
                    const laser = new THREE.Mesh(laserGeometry, laserMaterial);
                    laser.visible = false;
                    this.scene.add(laser);
                    this.laserPool.push(laser);
                }
                
                // Particle pool for hit effects
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true
                });
                
                for (let i = 0; i < 200; i++) {
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.visible = false;
                    particle.userData = { velocity: new THREE.Vector3(), life: 0, maxLife: 30 };
                    this.scene.add(particle);
                    this.particlePool.push(particle);
                }
            }
            
            getEnemyFromPool() {
                for (let enemy of this.enemyPool) {
                    if (!enemy.visible) {
                        return enemy;
                    }
                }
                return null;
            }
            
            getLaserFromPool() {
                for (let laser of this.laserPool) {
                    if (!laser.visible) {
                        return laser;
                    }
                }
                return null;
            }
            
            getParticleFromPool() {
                for (let particle of this.particlePool) {
                    if (!particle.visible) {
                        return particle;
                    }
                }
                return null;
            }
            
            createEnemy() {
                const enemy = this.getEnemyFromPool();
                if (!enemy) return;
                
                const x = (Math.random() - 0.5) * 80;
                const y = 40 + Math.random() * 20;
                const z = -200 - Math.random() * 100;
                
                enemy.position.set(x, y, z);
                enemy.rotation.set(0, 0, 0);
                enemy.userData.health = Math.min(1 + this.wave * 0.5, 3);
                enemy.userData.speed = this.baseEnemySpeed + this.wave * 0.5;
                enemy.visible = true;
                
                this.enemies.push(enemy);
            }
            
            shootLaser() {
                const now = Date.now();
                if (now - this.lastShotTime < this.shotCooldown) return;
                
                this.lastShotTime = now;
                const laser = this.getLaserFromPool();
                if (!laser) return;
                
                laser.position.copy(this.player.mesh.position);
                laser.position.z -= 2;
                laser.visible = true;
                laser.userData.velocity = 15;
                laser.userData.life = 60;
                
                this.lasers.push(laser);
                
                // Laser sound effect (visual)
                this.createLaserEffect(laser.position);
            }
            
            createLaserEffect(pos) {
                for (let i = 0; i < 5; i++) {
                    const particle = this.getParticleFromPool();
                    if (!particle) continue;
                    
                    particle.position.copy(pos);
                    particle.userData.velocity.set(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        Math.random() * 5
                    );
                    particle.userData.life = 15;
                    particle.userData.maxLife = 15;
                    particle.material.color.setHex(0x00ffff);
                    particle.visible = true;
                    this.particles.push(particle);
                }
            }
            
            createHitEffect(position) {
                // Explosion effect
                for (let i = 0; i < 20; i++) {
                    const particle = this.getParticleFromPool();
                    if (!particle) continue;
                    
                    particle.position.copy(position);
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 5
                    );
                    particle.userData.velocity.copy(velocity);
                    particle.userData.life = 30 + Math.random() * 20;
                    particle.userData.maxLife = particle.userData.life;
                    
                    // Color based on enemy type
                    const colors = [0xff6600, 0xff0000, 0xffff00];
                    particle.material.color.setHex(colors[Math.floor(Math.random() * colors.length)]);
                    particle.scale.setScalar(0.5 + Math.random());
                    particle.visible = true;
                    this.particles.push(particle);
                }
            }
            
            updatePlayer(delta) {
                // Movement
                const moveX = this.targetX - this.player.position.x;
                this.player.position.x += moveX * this.player.speed * delta * 2;
                
                // Boundaries
                this.player.position.x = Math.max(-40, Math.min(40, this.player.position.x));
                
                this.player.mesh.position.copy(this.player.position);
                this.playerGlow.position.copy(this.player.position);
                
                // Player glow animation
                const time = this.clock.getElapsedTime();
                this.playerGlow.scale.setScalar(1 + Math.sin(time * 5) * 0.1);
                this.playerGlow.material.opacity = 0.2 + Math.sin(time * 3) * 0.1;
            }
            
            updateEnemies(delta) {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    
                    // Move enemy
                    enemy.position.z += enemy.userData.speed;
                    enemy.rotation.z += 0.05;
                    
                    // Simple sin wave movement
                    enemy.position.y += Math.sin(this.clock.getElapsedTime() * 2 + i) * 0.5 * delta;
                    
                    // Remove if past player
                    if (enemy.position.z > 10) {
                        enemy.visible = false;
                        this.enemies.splice(i, 1);
                        this.onEnemyMiss();
                        continue;
                    }
                    
                    // Collision with player
                    const distance = enemy.position.distanceTo(this.player.position);
                    if (distance < 3) {
                        this.takeDamage(25);
                        enemy.visible = false;
                        this.enemies.splice(i, 1);
                        this.createHitEffect(enemy.position);
                        continue;
                    }
                }
            }
            
            updateLasers(delta) {
                for (let i = this.lasers.length - 1; i >= 0; i--) {
                    const laser = this.lasers[i];
                    
                    laser.position.z -= laser.userData.velocity;
                    laser.userData.life--;
                    
                    if (laser.userData.life <= 0 || laser.position.z < -300) {
                        laser.visible = false;
                        this.lasers.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with enemies
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        if (laser.position.distanceTo(enemy.position) < 2) {
                            // Hit!
                            enemy.userData.health--;
                            if (enemy.userData.health <= 0) {
                                enemy.visible = false;
                                this.enemies.splice(j, 1);
                                this.createHitEffect(enemy.position);
                                this.addScore(100 * this.wave);
                            } else {
                                this.createHitEffect(enemy.position);
                            }
                            
                            laser.visible = false;
                            this.lasers.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            updateParticles(delta) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.multiplyScalar(0.98); // Damping
                    particle.userData.life--;
                    
                    // Fade out
                    const alpha = particle.userData.life / particle.userData.maxLife;
                    particle.material.opacity = alpha;
                    particle.scale.setScalar(alpha);
                    
                    if (particle.userData.life <= 0) {
                        particle.visible = false;
                        particle.material.opacity = 1;
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            spawnWave() {
                if (this.enemies.length === 0) {
                    this.wave++;
                    this.waveEnemies = Math.min(5 + this.wave * 2, 20);
                    
                    // Update UI
                    document.getElementById('wave').textContent = this.wave;
                    
                    // Scale difficulty
                    this.enemySpawnRate = Math.max(0.005, 0.02 - this.wave * 0.001);
                    this.shotCooldown = Math.max(100, 200 - this.wave * 10);
                }
            }
            
            addScore(points) {
                this.score += points;
                document.getElementById('score').textContent = this.score;
            }
            
            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                this.updateHealthUI();
                
                if (this.health <= 0) {
                    this.gameOver();
                }
            }
            
            onEnemyMiss() {
                this.takeDamage(5); // Light damage for missing enemies
            }
            
            updateHealthUI() {
                const percentage = (this.health / 100) * 100;
                document.getElementById('healthFill').style.width = percentage + '%';
            }
            
            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            restart() {
                this.gameRunning = true;
                this.score = 0;
                this.health = 100;
                this.wave = 1;
                this.enemies = [];
                this.lasers = [];
                this.particles = [];
                this.targetX = 0;
                this.shotCooldown = 200;
                this.enemySpawnRate = 0.02;
                
                // Reset pools
                this.enemyPool.forEach(enemy => {
                    enemy.visible = false;
                    enemy.userData.health = 1;
                    enemy.userData.speed = this.baseEnemySpeed;
                });
                
                this.laserPool.forEach(laser => laser.visible = false);
                this.particlePool.forEach(particle => {
                    particle.visible = false;
                    particle.material.opacity = 1;
                });
                
                // Reset UI
                document.getElementById('score').textContent = '0';
                document.getElementById('wave').textContent = '1';
                this.updateHealthUI();
                document.getElementById('gameOver').style.display = 'none';
                
                // Reset player
                this.player.position.set(0, 0, 0);
            }
            
            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (this.gameRunning) this.shootLaser();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse/touch controls
                const leftZone = document.getElementById('leftZone');
                const rightZone = document.getElementById('rightZone');
                
                // Touch movement
                leftZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchActive = true;
                    this.targetX -= 15;
                });
                
                rightZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchActive = true;
                    this.targetX += 15;
                });
                
                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.touchActive) {
                        this.touchActive = false;
                        this.targetX = 0;
                    }
                });
                
                // Touch shooting (tap anywhere)
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.gameRunning) this.shootLaser();
                }, { passive: false });
                
                // Mouse controls for desktop
                document.addEventListener('mousemove', (e) => {
                    if (!this.gameRunning) return;
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width - 0.5) * 80;
                    this.targetX = x;
                });
                
                // Prevent context menu on right click
                document.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            update(delta) {
                if (!this.gameRunning) return;
                
                this.updatePlayer(delta);
                this.updateEnemies(delta);
                this.updateLasers(delta);
                this.updateParticles(delta);
                
                // Spawn enemies
                if (this.enemies.length < this.waveEnemies && Math.random() < this.enemySpawnRate) {
                    this.createEnemy();
                }
                
                // Check for wave completion
                this.spawnWave();
                
                // Move starfield
                this.starfield.rotation.y += 0.001;
                this.starfield.position.z += 0.5;
                if (this.starfield.position.z > 50) {
                    this.starfield.position.z = -50;
                }
                
                // Camera follows player slightly
                this.camera.position.x += (this.player.position.x * 0.1 - this.camera.position.x) * 0.1;
                this.camera.position.y += (this.player.position.y * 0.1 - this.camera.position.y) * 0.1;
                this.camera.lookAt(this.player.position);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                
                // Handle keyboard input
                if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
                    this.targetX -= 15 * delta;
                }
                if (this.keys['KeyD'] || this.keys['ArrowRight']) {
                    this.targetX += 15 * delta;
                }
                
                this.update(delta);
                this.composer.render();
            }
        }
        
        // Initialize game
        let game;
        
        function initGame() {
            game = new SpaceShooter();
        }
        
        // Restart button
        document.getElementById('restartBtn').addEventListener('click', () => {
            if (game) {
                game.restart();
            }
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            if (game) {
                game.camera.aspect = window.innerWidth / window.innerHeight;
                game.camera.updateProjectionMatrix();
                game.renderer.setSize(window.innerWidth, window.innerHeight);
                game.composer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Start game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>