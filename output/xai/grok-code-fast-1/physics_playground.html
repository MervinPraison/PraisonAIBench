<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Playground</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        #canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #000;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            z-index: 1;
        }
        #controls input, button {
            margin: 5px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="resetBtn">Reset</button><br>
        <label>Gravity: <input type="range" id="gravitySlider" min="-50" max="0" value="-10" step="1"></label><br>
        <label>Slow-Motion: <input type="checkbox" id="slowMotionToggle"></label>
    </div>
    <canvas id="canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, world, controls;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedBody = null;
        let intersectPoint = new THREE.Vector3();
        let dragging = false;
        let dragConstraint = null;
        let objects = [];
        let initialObjects = [];
        const fixedTimeStep = 1.0 / 60.0;
        let slowMotion = false;

        // Initialize scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 5);
            light.castShadow = true;
            light.shadow.mapSize.width = 2048;
            light.shadow.mapSize.height = 2048;
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Physics world
            world = new CANNON.World();
            world.gravity.set(0, -10, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.defaultContactMaterial.friction = 0.4;
            world.defaultContactMaterial.restitution = 0.3;

            // Ground
            const groundShape = new CANNON.Box(new CANNON.Vec3(50, 0.5, 50));
            const groundBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
            groundBody.addShape(groundShape);
            groundBody.position.set(0, -0.5, 0);
            world.addBody(groundBody);

            const groundMesh = new THREE.Mesh(new THREE.BoxGeometry(100, 1, 100), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Create initial objects
            createObjects();

            // Mouse interaction
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            // UI
            document.getElementById('resetBtn').addEventListener('click', reset);
            document.getElementById('gravitySlider').addEventListener('input', updateGravity);
            document.getElementById('slowMotionToggle').addEventListener('change', toggleSlowMotion);

            // Animation loop
            animate();
        }

        function createObjects() {
            // Stackable boxes
            for (let i = 0; i < 5; i++) {
                const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
                const boxBody = new CANNON.Body({ mass: 1 });
                boxBody.addShape(boxShape);
                boxBody.position.set(0, i * 1.2 + 1, 0);
                world.addBody(boxBody);

                const boxMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                boxMesh.position.copy(boxBody.position);
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                scene.add(boxMesh);

                objects.push({ mesh: boxMesh, body: boxBody });
                initialObjects.push({ mesh: boxMesh, body: boxBody, pos: boxBody.position.clone(), quat: boxBody.quaternion.clone() });
            }

            // Spheres
            for (let i = 0; i < 3; i++) {
                const sphereShape = new CANNON.Sphere(0.5);
                const sphereBody = new CANNON.Body({ mass: 1 });
                sphereBody.addShape(sphereShape);
                sphereBody.position.set(i * 1.5 - 2, 5, i * 1.5);
                world.addBody(sphereBody);

                const sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                sphereMesh.position.copy(sphereBody.position);
                sphereMesh.castShadow = true;
                scene.add(sphereMesh);

                objects.push({ mesh: sphereMesh, body: sphereBody });
                initialObjects.push({ mesh: sphereMesh, body: sphereBody, pos: sphereBody.position.clone(), quat: sphereBody.quaternion.clone() });
            }

            // Hinge joint
            const hingeBox1Shape = new CANNON.Box(new CANNON.Vec3(0.2, 1, 0.2));
            const hingeBox1Body = new CANNON.Body({ mass: 1 });
            hingeBox1Body.addShape(hingeBox1Shape);
            hingeBox1Body.position.set(3, 5, 3);
            world.addBody(hingeBox1Body);

            const hingeBox2Shape = new CANNON.Box(new CANNON.Vec3(0.2, 1, 0.2));
            const hingeBox2Body = new CANNON.Body({ mass: 1 });
            hingeBox2Body.addShape(hingeBox2Shape);
            hingeBox2Body.position.set(3, 3, 3);
            world.addBody(hingeBox2Body);

            const hinge = new CANNON.HingeConstraint(hingeBox1Body, hingeBox2Body, {
                pivotA: new CANNON.Vec3(0, -1, 0),
                pivotB: new CANNON.Vec3(0, 1, 0),
                axisA: new CANNON.Vec3(0, 1, 0),
                axisB: new CANNON.Vec3(0, 1, 0)
            });
            world.addConstraint(hinge);

            const hingeMesh1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2, 0.4), new THREE.MeshLambertMaterial({ color: 0xff0000 }));
            hingeMesh1.position.copy(hingeBox1Body.position);
            hingeMesh1.castShadow = true;
            scene.add(hingeMesh1);

            const hingeMesh2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2, 0.4), new THREE.MeshLambertMaterial({ color: 0x00ff00 }));
            hingeMesh2.position.copy(hingeBox2Body.position);
            hingeMesh2.castShadow = true;
            scene.add(hingeMesh2);

            objects.push({ mesh: hingeMesh1, body: hingeBox1Body }, { mesh: hingeMesh2, body: hingeBox2Body });
            initialObjects.push(
                { mesh: hingeMesh1, body: hingeBox1Body, pos: hingeBox1Body.position.clone(), quat: hingeBox1Body.quaternion.clone() },
                { mesh: hingeMesh2, body: hingeBox2Body, pos: hingeBox2Body.position.clone(), quat: hingeBox2Body.quaternion.clone() }
            );

            // Simple Ragdoll
            const torsoShape = new CANNON.Box(new CANNON.Vec3(0.3, 0.8, 0.2));
            const torsoBody = new CANNON.Body({ mass: 1 });
            torsoBody.addShape(torsoShape);
            torsoBody.position.set(-3, 5, 3);
            world.addBody(torsoBody);

            const headShape = new CANNON.Sphere(0.2);
            const headBody = new CANNON.Body({ mass: 0.5 });
            headBody.addShape(headShape);
            headBody.position.set(-3, 6, 3);
            world.addBody(headBody);

            const neckJoint = new CANNON.PointToPointConstraint(torsoBody, new CANNON.Vec3(0, 0.8, 0), headBody, new CANNON.Vec3(0, -0.2, 0));
            world.addConstraint(neckJoint);

            const armShape = new CANNON.Box(new CANNON.Vec3(0.1, 0.6, 0.1));
            const leftArmBody = new CANNON.Body({ mass: 0.3 });
            leftArmBody.addShape(armShape);
            leftArmBody.position.set(-3.5, 5, 3);
            world.addBody(leftArmBody);

            const shoulderJoint = new CANNON.HingeConstraint(torsoBody, leftArmBody, {
                pivotA: new CANNON.Vec3(-0.3, 0.5, 0),
                pivotB: new CANNON.Vec3(0, 0.3, 0),
                axisA: new CANNON.Vec3(0, 0, 1),
                axisB: new CANNON.Vec3(0, 0, 1)
            });
            world.addConstraint(shoulderJoint);

            // Meshes for ragdoll
            const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.6, 0.4), new THREE.MeshLambertMaterial({ color: 0x0000ff }));
            torsoMesh.position.copy(torsoBody.position);
            torsoMesh.castShadow = true;
            scene.add(torsoMesh);

            const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshLambertMaterial({ color: 0xffff00 }));
            headMesh.position.copy(headBody.position);
            headMesh.castShadow = true;
            scene.add(headMesh);

            const leftArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.2, 0.2), new THREE.MeshLambertMaterial({ color: 0xff00ff }));
            leftArmMesh.position.copy(leftArmBody.position);
            leftArmMesh.castShadow = true;
            scene.add(leftArmMesh);

            objects.push(
                { mesh: torsoMesh, body: torsoBody },
                { mesh: headMesh, body: headBody },
                { mesh: leftArmMesh, body: leftArmBody }
            );
            initialObjects.push(
                { mesh: torsoMesh, body: torsoBody, pos: torsoBody.position.clone(), quat: torsoBody.quaternion.clone() },
                { mesh: headMesh, body: headBody, pos: headBody.position.clone(), quat: headBody.quaternion.clone() },
                { mesh: leftArmMesh, body: leftArmBody, pos: leftArmBody.position.clone(), quat: leftArmBody.quaternion.clone() }
            );
        }

        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const meshes = objects.map(obj => obj.mesh);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                selectedBody = objects.find(obj => obj.mesh === intersect.object).body;
                intersectPoint.copy(intersect.point);

                dragConstraint = new CANNON.PointToPointConstraint(selectedBody, intersectPoint, new CANNON.Body({ mass: 0 }), new THREE.Vector3(mouse.x * 10, mouse.y * 10, 0));
                world.addConstraint(dragConstraint);
                dragging = true;
            }
        }

        function onMouseMove(event) {
            if (!dragging) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const planeNormal = new THREE.Vector3(0, 0, 1);
            const planePoint = new THREE.Vector3(0, 0, 0);
            const ray = new THREE.Ray();
            ray.origin.setFromMatrixPosition(camera.matrixWorld);
            ray.direction.set(mouse.x, mouse.y, 0.5).unproject(camera).sub(ray.origin).normalize();

            const denominator = planeNormal.dot(ray.direction);
            const t = (planePoint.sub(ray.origin).dot(planeNormal)) / denominator;
            const intersection = ray.origin.clone().add(ray.direction.clone().multiplyScalar(t));

            dragConstraint.pivotB.copy(intersection);
        }

        function onMouseUp() {
            if (dragging) {
                world.removeConstraint(dragConstraint);
                dragConstraint = null;
                selectedBody = null;
                dragging = false;
            }
        }

        function reset() {
            objects.forEach((obj, index) => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            objects = [];
            createObjects();
        }

        function updateGravity() {
            world.gravity.y = parseFloat(document.getElementById('gravitySlider').value);
        }

        function toggleSlowMotion() {
            slowMotion = document.getElementById('slowMotionToggle').checked;
        }

        function animate() {
            requestAnimationFrame(animate);

            const timeStep = slowMotion ? fixedTimeStep / 4 : fixedTimeStep;
            world.step(timeStep);

            objects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>