<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Particle System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="container"></div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Particle count (at least 1000)
        const particleCount = 2000;

        // Create particle geometry
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const originalPositions = new Float32Array(particleCount * 3); // For resetting to fountain base

        // Initialize particles (fountain pattern from base at (0, -20, 0))
        const baseY = -20;
        for (let i = 0; i < particleCount; i++) {
            // Random initial positions around base
            positions[i * 3] = (Math.random() - 0.5) * 10; // x
            positions[i * 3 + 1] = baseY + Math.random() * 5; // y
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10; // z

            // Random velocities upwards for fountain
            velocities[i * 3] = (Math.random() - 0.5) * 2; // vx
            velocities[i * 3 + 1] = 5 + Math.random() * 5; // vy upward
            velocities[i * 3 + 2] = (Math.random() - 0.5) * 2; // vz

            // Initial colors (blue-green base)
            colors[i * 3] = 0.0; // r
            colors[i * 3 + 1] = 1.0; // g
            colors[i * 3 + 2] = 1.0; // b

            // Store original for respawn
            originalPositions[i * 3] = positions[i * 3];
            originalPositions[i * 3 + 1] = positions[i * 3 + 1];
            originalPositions[i * 3 + 2] = positions[i * 3 + 2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material for particles (points with colors)
        const material = new THREE.PointsMaterial({ size: 2, vertexColors: true, blending: THREE.AdditiveBlending });

        // Create the particle system
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Mouse interaction
        let mouseX = 0, mouseY = 0;
        const onMouseMove = (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        };
        window.addEventListener('mousemove', onMouseMove);

        // Convert mouse to world coordinates for force application
        const mouseForceStrength = 0.01;
        const repulsionRadius = 10;

        // Animation loop
        const clock = new THREE.Clock();
        let time = 0;

        const animate = () => {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            time += delta;

            const posArray = geometry.attributes.position.array;
            const velArray = velocities;
            const colArray = geometry.attributes.color.array;

            for (let i = 0; i < particleCount; i++) {
                let px = posArray[i * 3];
                let py = posArray[i * 3 + 1];
                let pz = posArray[i * 3 + 2];

                // Apply gravity (realistic physics)
                velArray[i * 3 + 1] -= 9.81 * delta * 0.5; // Gravity down on y

                // Add some damping
                velArray[i * 3] *= 0.99;
                velArray[i * 3 + 1] *= 0.99;
                velArray[i * 3 + 2] *= 0.99;

                // Mouse interaction (repulsion/attraction based on distance)
                const mouseWorldX = mouseX * 50; // Approximate world coord from normalized
                const mouseWorldY = mouseY * 50;
                const distX = px - mouseWorldX;
                const distY = py - mouseWorldY;
                const distZ = pz - 0; // Mouse is at z=0 plane
                const distance = Math.sqrt(distX * distX + distY * distY + distZ * distZ);

                if (distance < repulsionRadius && distance > 0) {
                    const force = (repulsionRadius - distance) / repulsionRadius;
                    velArray[i * 3] += distX / distance * force * mouseForceStrength;
                    velArray[i * 3 + 1] += distY / distance * force * mouseForceStrength;
                    velArray[i * 3 + 2] += distZ / distance * force * mouseForceStrength;
                }

                // Update positions
                posArray[i * 3] += velArray[i * 3] * delta;
                posArray[i * 3 + 1] += velArray[i * 3 + 1] * delta;
                posArray[i * 3 + 2] += velArray[i * 3 + 2] * delta;

                // Reset particle if it falls too low (respawn in fountain pattern)
                if (py < baseY - 30) {
                    posArray[i * 3] = originalPositions[i * 3] + (Math.random() - 0.5) * 5;
                    posArray[i * 3 + 1] = baseY + Math.random() * 5;
                    posArray[i * 3 + 2] = originalPositions[i * 3 + 2] + (Math.random() - 0.5) * 5;

                    velArray[i * 3] = (Math.random() - 0.5) * 2;
                    velArray[i * 3 + 1] = 5 + Math.random() * 5;
                    velArray[i * 3 + 2] = (Math.random() - 0.5) * 2;
                }

                // Color change over time (cyclic hue shift)
                const hue = (time * 0.1 + i * 0.001) % 1; // Vary per particle
                const rgb = new THREE.Color().setHSL(hue, 0.7, 0.5);
                colArray[i * 3] = rgb.r;
                colArray[i * 3 + 1] = rgb.g;
                colArray[i * 3 + 2] = rgb.b;
            }

            // Notify Three.js of attribute changes
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            // Rotate camera slightly for dynamic view
            camera.position.x = Math.sin(time * 0.1) * 20;
            camera.position.z = 50 + Math.cos(time * 0.1) * 10;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        };

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>