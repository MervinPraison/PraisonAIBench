<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Gallery</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #vr-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
        }
        #vr-button:hover {
            background: #0056b3;
        }
        #info-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 200;
            max-width: 400px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="three-canvas"></canvas>
        <button id="vr-button">Enter VR</button>
    </div>
    <div id="info-panel" style="display: none;">
        <h2 id="art-title">Artwork Title</h2>
        <p id="art-description">Description of the artwork.</p>
        <button id="close-info">Close</button>
    </div>
    <script>
        // Global variables
        let scene, camera, renderer, controls, listener, audioLoader;
        let isVR = false;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let intersectPoint = new THREE.Vector3();
        let controller1, controller2, rayGeometry1, rayGeometry2;
        let teleportMarker;
        let artworks = [];
        let spatialAudios = [];
        let selectedArtwork = null;
        const clock = new THREE.Clock();

        // Initialize the scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5); // Eye height

            // Renderer
            const canvas = document.getElementById('three-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding; // For better colors
            renderer.physicallyCorrectLights = true; // For realistic lighting
            renderer.xr.enabled = true; // Enable WebXR

            // Audio Listener
            listener = new THREE.AudioListener();
            camera.add(listener);

            // Lighting (simulating lightmapping with baked shadows and ambient)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; // Low-res for performance
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            // Room geometry (simple box with lightmapped feel via textures)
            const roomSize = { width: 20, height: 10, depth: 20 };
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.BackSide });
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const roomGeometry = new THREE.BoxGeometry(roomSize.width, roomSize.height, roomSize.depth);
            const room = new THREE.Mesh(roomGeometry, wallMaterial);
            room.receiveShadow = true;
            scene.add(room);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(roomSize.width, roomSize.depth);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Add artworks (simple planes)
            addArtworks();

            // Add spatial audio
            addSpatialAudio();

            // Teleport marker
            const markerGeometry = new THREE.RingGeometry(0.1, 0.15, 32);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            teleportMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            teleportMarker.rotation.x = -Math.PI / 2;
            teleportMarker.visible = false;
            scene.add(teleportMarker);

            // Controls for non-VR (OrbitControls)
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
            }

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('mousedown', onMouseDown);
            document.getElementById('close-info').addEventListener('click', closeInfo);

            // VR Button
            document.getElementById('vr-button').addEventListener('click', enterVR);

            // Initialize XR controllers
            initXRControllers();

            // Start render loop
            renderer.setAnimationLoop(render);
        }

        function addArtworks() {
            // Simple artwork data
            const artData = [
                { position: [-8, 2, -9], title: 'Sunset Over Mountains', description: 'A beautiful landscape painting.' },
                { position: [8, 2, -9], title: 'Abstract Waves', description: 'Modern art piece.' },
                { position: [0, 2, 9], title: 'Cityscape at Night', description: 'Urban skyline illustration.' }
            ];

            artData.forEach(data => {
                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Placeholder color
                const artwork = new THREE.Mesh(geometry, material);
                artwork.position.set(...data.position);
                artwork.userData = data; // Store info
                artwork.castShadow = false; // No shadows for performance
                scene.add(artwork);
                artworks.push(artwork);
            });
        }

        function addSpatialAudio() {
            audioLoader = new THREE.AudioLoader();

            // Example: Ambient sound at center
            const ambientAudio = new THREE.PositionalAudio(listener);
            audioLoader.load('https://www.soundjay.com/misc/sounds/bell-ringing-05.wav', function(buffer) { // Placeholder URL
                ambientAudio.setBuffer(buffer);
                ambientAudio.setLoop(true);
                ambientAudio.setVolume(0.3);
                ambientAudio.play();
            });
            const audioPos = new THREE.Object3D();
            audioPos.position.set(0, 1, 0);
            audioPos.add(ambientAudio);
            scene.add(audioPos);
            spatialAudios.push(audioPos);
        }

        function initXRControllers() {
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            scene.add(controller1);
            scene.add(controller2);

            // Rays for controllers (for pointing)
            rayGeometry1 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const rayMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const ray1 = new THREE.Line(rayGeometry1, rayMaterial);
            controller1.add(ray1);

            rayGeometry2 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const ray2 = new THREE.Line(rayGeometry2, rayMaterial);
            controller2.add(ray2);

            // Controller grip events
            controller1.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectstart', onSelectStart);
        }

        function onSelectStart(event) {
            const controller = event.target;
            const direction = new THREE.Vector3();
            controller.getWorldDirection(direction);
            raycaster.set(controller.position, direction);

            // Check for teleport (hit floor)
            const floorIntersects = raycaster.intersectObject(scene.children.find(obj => obj.geometry instanceof THREE.PlaneGeometry), true);
            if (floorIntersects.length > 0) {
                teleportTo(floorIntersects[0].point);
                return;
            }

            // Check for artwork selection
            artworks.forEach(artwork => {
                const intersects = raycaster.intersectObject(artwork);
                if (intersects.length > 0) {
                    showInfo(artwork.userData);
                }
            });
        }

        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Teleport with mouse
            const floor = scene.children.find(obj => obj.geometry instanceof THREE.PlaneGeometry);
            const intersects = raycaster.intersectObject(floor, true);
            if (intersects.length > 0) {
                teleportTo(intersects[0].point);
            }

            // Select artwork
            artworks.forEach(artwork => {
                const artIntersects = raycaster.intersectObject(artwork);
                if (artIntersects.length > 0) {
                    showInfo(artwork.userData);
                }
            });
        }

        function teleportTo(point) {
            camera.position.set(point.x, camera.position.y, point.z);
            teleportMarker.position.copy(point);
            teleportMarker.visible = false; // Hide after teleport
        }

        function showInfo(data) {
            document.getElementById('art-title').textContent = data.title;
            document.getElementById('art-description').textContent = data.description;
            document.getElementById('info-panel').style.display = 'block';
        }

        function closeInfo() {
            document.getElementById('info-panel').style.display = 'none';
        }

        async function enterVR() {
            if (navigator.xr) {
                try {
                    const session = await navigator.xr.requestSession('immersive-vr');
                    renderer.xr.setSession(session);
                    isVR = true;
                } catch (error) {
                    console.log('VR not supported or denied:', error);
                }
            } else {
                alert('WebXR not supported in this browser.');
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function render() {
            const delta = clock.getDelta();

            // Update controls if non-VR
            if (!isVR && controls) {
                controls.update();
            }

            // Performance: Limit updates to necessary objects
            // (Artworks are static, so no animation needed)

            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>