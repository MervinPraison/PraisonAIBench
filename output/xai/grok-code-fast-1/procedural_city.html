<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural 3D City</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; z-index: 10; }
        #minimap { position: absolute; bottom: 10px; right: 10px; width: 200px; height: 200px; background: rgba(0,0,0,0.5); z-index: 10; }
        #seed { width: 150px; }
    </style>
</head>
<body>
    <div id="ui">
        <label for="seed">Seed:</label>
        <input type="text" id="seed" value="12345">
        <button onclick="regenerateCity()">Regenerate</button>
        <br>
        <label for="time">Time:</label>
        <input type="range" id="time" min="0" max="1" step="0.01" value="0.5" oninput="updateTime()">
    </div>
    <canvas id="minimap"></canvas>
    <script>
        // Inline seeded random generator (simple Linear Congruential Generator)
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
                this.a = 1103515245;
                this.c = 12345;
                this.m = 2147483648;
            }
            next() {
                this.seed = (this.a * this.seed + this.c) % this.m;
                return this.seed / this.m;
            }
            random() { return this.next(); }
            int(max) { return Math.floor(this.next() * max); }
        }

        // Global variables
        let scene, camera, renderer, controls, sky, sun;
        let cityGroup = new THREE.Group();
        let random;
        let minimapCanvas = document.getElementById('minimap').getContext('2d');

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 20, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040));
            sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 50, 25);
            sun.castShadow = true;
            sun.shadow.mapSize.width = sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // Sky (procedural HDRI-like using inline Sky object)
            initSky();

            // Controls (free-fly using FlyControls - inline from Three.js examples)
            controls = new FlyControls(camera, renderer.domElement);
            controls.movementSpeed = 10;
            controls.rollSpeed = Math.PI / 24;

            // Generate initial city
            regenerateCity();

            // Animation loop
            animate();
        }

        // Inline Sky object (adapted from Three.js examples for self-containment)
        function initSky() {
            // This is a simplified inline version of Sky.js from Three.js examples
            sky = new THREE.ShaderMaterial({
                uniforms: {
                    turbidity: { value: 10 },
                    rayleigh: { value: 2 },
                    mieCoefficient: { value: 0.005 },
                    mieDirectionalG: { value: 0.8 },
                    sunPosition: { value: new THREE.Vector3() }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vWorldPosition;
                    uniform vec3 sunPosition;
                    uniform float turbidity;
                    uniform float rayleigh;
                    uniform float mieCoefficient;
                    uniform float mieDirectionalG;

                    const float pi = 3.14159265359;

                    vec3 sunDirection = normalize(sunPosition);
                    vec3 sunE = vec3(1000.0);

                    vec3 totalRayleigh(vec3 lambda) {
                        return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));
                    }

                    vec3 totalMie(vec3 lambda, vec3 K, float T) {
                        return 0.434 * c * (0.2 * T) * 10E-18; // Simplified
                    }

                    void main() {
                        vec3 eyeDirection = normalize(vWorldPosition - cameraPosition);
                        float sunfade = 1.0 - clamp(1.0 - exp((sunPosition.y / 450000.0)), 0.0, 1.0);
                        float rayleighPhase = 3.0 / (16.0 * pi) * (1.0 + pow(cos(dot(sunDirection, eyeDirection)), 2.0));
                        float miePhase = 1.0 / (2.0 * pi) * (1.0 - pow(mieDirectionalG, 2.0)) / pow(1.0 + pow(mieDirectionalG, 2.0) - 2.0 * mieDirectionalG * cos(dot(sunDirection, eyeDirection)), 1.5);

                        vec3 primaryRayleigh = vec3(5.5e-6, 13.0e-6, 22.4e-6);
                        vec3 primaryMie = vec3(21e-6);

                        vec3 attenuation;
                        solarRadianceToIrradiance(sunE, attenuation);
                        vec3 betaR = totalRayleigh(primaryRayleigh) * rayleigh;
                        vec3 betaM = totalMie(primaryMie, vec3(0.686), turbidity) * mieCoefficient;

                        vec3 Fex = exp(-(betaR + betaM) * 1.0); // Simplified extinction
                        vec3 Lin = rayleighPhase * betaR + miePhase * betaM;
                        vec3 L0 = Fex * Lin;

                        gl_FragColor = vec4(skyColor, 1.0); // Simplified, use L0
                    }
                `,
                side: THREE.BackSide
            });

            let skyMesh = new THREE.Mesh(new THREE.SphereGeometry(500, 32, 32), sky);
            scene.add(skyMesh);
        }

        // Function to regenerate city based on seed
        function regenerateCity() {
            let seed = parseInt(document.getElementById('seed').value) || 12345;
            random = new SeededRandom(seed);

            // Clear old city
            scene.remove(cityGroup);
            cityGroup = new THREE.Group();
            scene.add(cityGroup);

            let gridSize = 20;
            let blockSize = 10;
            let roadWidth = 2;

            // Generate buildings and roads
            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    let posX = (x - gridSize / 2) * blockSize;
                    let posZ = (z - gridSize / 2) * blockSize;

                    // Random building
                    let height = random.next() * 30 + 5;
                    let building = new THREE.Mesh(
                        new THREE.BoxGeometry(blockSize * 0.8, height, blockSize * 0.8),
                        new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff })
                    );
                    building.position.set(posX, height / 2, posZ);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    cityGroup.add(building);

                    // Random texture (simple checker pattern inline)
                    let texture = new THREE.DataTexture(new Uint8Array([
                        255,255,255, 0,0,0,
                        0,0,0, 255,255,255
                    ]), 2, 2, THREE.RGBFormat);
                    texture.needsUpdate = true;
                    building.material.map = texture;
                }
            }

            // Roads (simple planes)
            for (let i = 0; i <= gridSize; i++) {
                let road = new THREE.Mesh(
                    new THREE.PlaneGeometry(gridSize * blockSize, roadWidth),
                    new THREE.MeshLambertMaterial({ color: 0x222222 })
                );
                road.rotation.x = -Math.PI / 2;
                road.position.set(0, 0.1, (i - gridSize / 2) * blockSize);
                cityGroup.add(road);

                road = new THREE.Mesh(
                    new THREE.PlaneGeometry(roadWidth, gridSize * blockSize),
                    new THREE.MeshLambertMaterial({ color: 0x222222 })
                );
                road.rotation.x = -Math.PI / 2;
                road.position.set((i - gridSize / 2) * blockSize, 0.1, 0);
                cityGroup.add(road);
            }

            // Traffic lights at intersections
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (random.next() > 0.5) addTrafficLight((i - gridSize / 2) * blockSize, (j - gridSize / 2) * blockSize);
                }
            }

            updateMinimap();
        }

        // Add animated traffic light
        function addTrafficLight(x, z) {
            let pole = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 15), new THREE.MeshLambertMaterial({ color: 0x555555 }));
            pole.position.set(x, 7.5, z);
            cityGroup.add(pole);

            let lights = ['red', 'yellow', 'green'];
            let lightsMeshes = [];
            lights.forEach((color, index) => {
                let light = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({ color: color === 'red' ? 0xff0000 : color === 'yellow' ? 0xffff00 : 0x00ff00, emissive: true }));
                light.position.set(x, 15 + index * 2, z);
                cityGroup.add(light);
                lightsMeshes.push(light);
            });

            // Animate lights
            setInterval(() => {
                lightsMeshes.forEach((mesh, index) => {
                    mesh.visible = false;
                });
                let current = Math.floor(Date.now() / 2000) % 3;
                lightsMeshes[current].visible = true;
            }, 100);
        }

        // Inline FlyControls (simplified version for self-containment)
        function FlyControls(object, domElement) {
            this.object = object;
            this.domElement = domElement;
            this.movementSpeed = 1.0;
            this.rollSpeed = 0.005;

            let moveVector = new THREE.Vector3();
            let rotationVector = new THREE.Vector3();

            this.update = function(delta) {
                this.object.translateX(moveVector.x * delta);
                this.object.translateY(moveVector.y * delta);
                this.object.translateZ(moveVector.z * delta);
                this.object.rotation.y += rotationVector.y * delta;
            };

            // Basic movement (use keyboard)
            let keys = {};
            document.addEventListener('keydown', (e) => keys[e.code] = true);
            document.addEventListener('keyup', (e) => keys[e.code] = false);

            this.update = function(delta) {
                moveVector.set(0,0,0);
                if (keys['KeyW']) moveVector.z -= 1;
                if (keys['KeyS']) moveVector.z += 1;
                if (keys['KeyA']) moveVector.x -= 1;
                if (keys['KeyD']) moveVector.x += 1;
                if (keys['Space']) moveVector.y += 1;
                if (keys['ShiftLeft']) moveVector.y -= 1;

                moveVector.multiplyScalar(this.movementSpeed);
                this.object.translateOnAxis(this.object.getWorldDirection(new THREE.Vector3()), moveVector.z * delta);
                this.object.translateX(moveVector.x * delta);
                this.object.translateY(moveVector.y * delta);
            };
        }

        // Update time for day/night cycle
        function updateTime() {
            let time = parseFloat(document.getElementById('time').value);
            sun.position.x = 50 * Math.cos(time * Math.PI * 2);
            sun.position.y = 50 * Math.sin(time * Math.PI * 2);
            sun.intensity = Math.max(0.1, Math.sin(time * Math.PI));
            sky.uniforms.sunPosition.value.copy(sun.position);
        }

        // Mini-map update
        function updateMinimap() {
            minimapCanvas.clearRect(0,0,200,200);
            minimapCanvas.fillStyle = '#00ff00';
            cityGroup.children.forEach(child => {
                if (child.type === 'Mesh' && child.geometry.type === 'BoxGeometry') {
                    let x = (child.position.x + 100) / 2 + 100;
                    let z = (child.position.z + 100) / 2 + 100;
                    minimapCanvas.fillRect(x - 2, z - 2, 4, 4);
                }
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(0.016); // ~60fps delta
            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        init();
        updateTime();
    </script>
</body>
</html>