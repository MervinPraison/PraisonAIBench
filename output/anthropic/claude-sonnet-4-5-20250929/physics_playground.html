<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 250px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        #controls h2 {
            margin-bottom: 15px;
            font-size: 20px;
            color: #4CAF50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .toggle-btn {
            background: #2196F3;
        }
        
        .toggle-btn:hover {
            background: #0b7dda;
        }
        
        .toggle-btn.active {
            background: #ff9800;
        }
        
        .value-display {
            display: inline-block;
            float: right;
            font-weight: bold;
            color: #4CAF50;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            max-width: 300px;
        }
        
        #spawn-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 200px;
        }
        
        #spawn-controls h3 {
            margin-bottom: 10px;
            color: #2196F3;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>‚öôÔ∏è Physics Controls</h2>
        
        <div class="control-group">
            <label>
                Gravity: <span class="value-display" id="gravity-value">-9.82</span>
            </label>
            <input type="range" id="gravity-slider" min="-30" max="0" step="0.1" value="-9.82">
        </div>
        
        <div class="control-group">
            <button id="slow-motion-btn" class="toggle-btn">üêå Slow Motion: OFF</button>
        </div>
        
        <div class="control-group">
            <button id="reset-btn">üîÑ Reset Scene</button>
        </div>
    </div>
    
    <div id="spawn-controls">
        <h3>üéÆ Spawn Objects</h3>
        <button id="spawn-box-btn">üì¶ Add Box</button>
        <button id="spawn-sphere-btn">‚öΩ Add Sphere</button>
        <button id="spawn-stack-btn">üèóÔ∏è Add Stack</button>
        <button id="spawn-ragdoll-btn">ü§∏ Add Ragdoll</button>
        <button id="spawn-chain-btn">‚õìÔ∏è Add Chain</button>
    </div>
    
    <div id="info">
        <strong>üéØ Controls:</strong><br>
        ‚Ä¢ Click and drag objects with mouse<br>
        ‚Ä¢ Scroll to zoom in/out<br>
        ‚Ä¢ Right-click drag to rotate camera<br>
        ‚Ä¢ Use controls to adjust physics<br>
        ‚Ä¢ Spawn different objects to play!
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Load Cannon.js from CDN
        const CANNON = await import('https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Orbit Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x545454, 0.5);
        scene.add(hemisphereLight);

        // Physics World
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;
        world.defaultContactMaterial.contactEquationStiffness = 1e8;
        world.defaultContactMaterial.contactEquationRelaxation = 3;

        // Materials
        const groundMaterial = new CANNON.Material('ground');
        const objectMaterial = new CANNON.Material('object');
        
        const groundObjectContact = new CANNON.ContactMaterial(
            groundMaterial,
            objectMaterial,
            { friction: 0.4, restitution: 0.3 }
        );
        world.addContactMaterial(groundObjectContact);

        // Arrays to store objects
        const bodies = [];
        const meshes = [];
        const constraints = [];

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterialThree = new THREE.MeshStandardMaterial({ 
            color: 0x228b22,
            roughness: 0.8,
            metalness: 0.2
        });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterialThree);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // Add walls
        function createWall(width, height, depth, position, rotation = [0, 0, 0]) {
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                transparent: true,
                opacity: 0.3
            });
            const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
            wallMesh.position.copy(position);
            wallMesh.receiveShadow = true;
            scene.add(wallMesh);

            const wallShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
            const wallBody = new CANNON.Body({ mass: 0 });
            wallBody.addShape(wallShape);
            wallBody.position.copy(position);
            world.addBody(wallBody);
        }

        createWall(100, 20, 1, new THREE.Vector3(0, 10, -20));
        createWall(100, 20, 1, new THREE.Vector3(0, 10, 20));
        createWall(1, 20, 40, new THREE.Vector3(-20, 10, 0));
        createWall(1, 20, 40, new THREE.Vector3(20, 10, 0));

        // Helper function to create box
        function createBox(size, position, color = Math.random() * 0xffffff) {
            const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.5,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
            const body = new CANNON.Body({ 
                mass: 1,
                material: objectMaterial,
                linearDamping: 0.1,
                angularDamping: 0.1
            });
            body.addShape(shape);
            body.position.copy(position);
            world.addBody(body);

            meshes.push(mesh);
            bodies.push(body);

            return { mesh, body };
        }

        // Helper function to create sphere
        function createSphere(radius, position, color = Math.random() * 0xffffff) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.4,
                metalness: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ 
                mass: 1,
                material: objectMaterial,
                linearDamping: 0.1,
                angularDamping: 0.1
            });
            body.addShape(shape);
            body.position.copy(position);
            world.addBody(body);

            meshes.push(mesh);
            bodies.push(body);

            return { mesh, body };
        }

        // Create ragdoll
        function createRagdoll(position) {
            const parts = [];
            
            // Head
            const head = createSphere(0.5, new THREE.Vector3(position.x, position.y + 3, position.z), 0xffdbac);
            parts.push(head);

            // Torso
            const torso = createBox(
                { x: 1.2, y: 1.5, z: 0.6 },
                new THREE.Vector3(position.x, position.y + 1.5, position.z),
                0x4169e1
            );
            parts.push(torso);

            // Arms
            const leftUpperArm = createBox(
                { x: 0.3, y: 0.8, z: 0.3 },
                new THREE.Vector3(position.x - 0.8, position.y + 2, position.z),
                0xff6347
            );
            parts.push(leftUpperArm);

            const rightUpperArm = createBox(
                { x: 0.3, y: 0.8, z: 0.3 },
                new THREE.Vector3(position.x + 0.8, position.y + 2, position.z),
                0xff6347
            );
            parts.push(rightUpperArm);

            const leftLowerArm = createBox(
                { x: 0.3, y: 0.8, z: 0.3 },
                new THREE.Vector3(position.x - 0.8, position.y + 0.8, position.z),
                0xffa07a
            );
            parts.push(leftLowerArm);

            const rightLowerArm = createBox(
                { x: 0.3, y: 0.8, z: 0.3 },
                new THREE.Vector3(position.x + 0.8, position.y + 0.8, position.z),
                0xffa07a
            );
            parts.push(rightLowerArm);

            // Legs
            const leftUpperLeg = createBox(
                { x: 0.4, y: 0.9, z: 0.4 },
                new THREE.Vector3(position.x - 0.4, position.y + 0.2, position.z),
                0x2f4f4f
            );
            parts.push(leftUpperLeg);

            const rightUpperLeg = createBox(
                { x: 0.4, y: 0.9, z: 0.4 },
                new THREE.Vector3(position.x + 0.4, position.y + 0.2, position.z),
                0x2f4f4f
            );
            parts.push(rightUpperLeg);

            const leftLowerLeg = createBox(
                { x: 0.35, y: 0.9, z: 0.35 },
                new THREE.Vector3(position.x - 0.4, position.y - 1, position.z),
                0x696969
            );
            parts.push(leftLowerLeg);

            const rightLowerLeg = createBox(
                { x: 0.35, y: 0.9, z: 0.35 },
                new THREE.Vector3(position.x + 0.4, position.y - 1, position.z),
                0x696969
            );
            parts.push(rightLowerLeg);

            // Create joints
            // Neck
            const neckConstraint = new CANNON.ConeTwistConstraint(
                head.body,
                torso.body,
                {
                    pivotA: new CANNON.Vec3(0, -0.5, 0),
                    pivotB: new CANNON.Vec3(0, 0.75, 0),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                    angle: Math.PI / 6,
                    twistAngle: Math.PI / 8
                }
            );
            world.addConstraint(neckConstraint);
            constraints.push(neckConstraint);

            // Shoulders
            const leftShoulderConstraint = new CANNON.ConeTwistConstraint(
                leftUpperArm.body,
                torso.body,
                {
                    pivotA: new CANNON.Vec3(0, 0.4, 0),
                    pivotB: new CANNON.Vec3(-0.6, 0.6, 0),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                    angle: Math.PI / 3
                }
            );
            world.addConstraint(leftShoulderConstraint);
            constraints.push(leftShoulderConstraint);

            const rightShoulderConstraint = new CANNON.ConeTwistConstraint(
                rightUpperArm.body,
                torso.body,
                {
                    pivotA: new CANNON.Vec3(0, 0.4, 0),
                    pivotB: new CANNON.Vec3(0.6, 0.6, 0),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                    angle: Math.PI / 3
                }
            );
            world.addConstraint(rightShoulderConstraint);
            constraints.push(rightShoulderConstraint);

            // Elbows
            const leftElbowConstraint = new CANNON.HingeConstraint(
                leftUpperArm.body,
                leftLowerArm.body,
                {
                    pivotA: new CANNON.Vec3(0, -0.4, 0),
                    pivotB: new CANNON.Vec3(0, 0.4, 0),
                    axisA: new CANNON.Vec3(1, 0, 0),
                    axisB: new CANNON.Vec3(1, 0, 0)
                }
            );
            world.addConstraint(leftElbowConstraint);
            constraints.push(leftElbowConstraint);

            const rightElbowConstraint = new CANNON.HingeConstraint(
                rightUpperArm.body,
                rightLowerArm.body,
                {
                    pivotA: new CANNON.Vec3(0, -0.4, 0),
                    pivotB: new CANNON.Vec3(0, 0.4, 0),
                    axisA: new CANNON.Vec3(1, 0, 0),
                    axisB: new CANNON.Vec3(1, 0, 0)
                }
            );
            world.addConstraint(rightElbowConstraint);
            constraints.push(rightElbowConstraint);

            // Hips
            const leftHipConstraint = new CANNON.ConeTwistConstraint(
                leftUpperLeg.body,
                torso.body,
                {
                    pivotA: new CANNON.Vec3(0, 0.45, 0),
                    pivotB: new CANNON.Vec3(-0.4, -0.75, 0),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                    angle: Math.PI / 3
                }
            );
            world.addConstraint(leftHipConstraint);
            constraints.push(leftHipConstraint);

            const rightHipConstraint = new CANNON.ConeTwistConstraint(
                rightUpperLeg.body,
                torso.body,
                {
                    pivotA: new CANNON.Vec3(0, 0.45, 0),
                    pivotB: new CANNON.Vec3(0.4, -0.75, 0),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                    angle: Math.PI / 3
                }
            );
            world.addConstraint(rightHipConstraint);
            constraints.push(rightHipConstraint);

            // Knees
            const leftKneeConstraint = new CANNON.HingeConstraint(
                leftUpperLeg.body,
                leftLowerLeg.body,
                {
                    pivotA: new CANNON.Vec3(0, -0.45, 0),
                    pivotB: new CANNON.Vec3(0, 0.45, 0),
                    axisA: new CANNON.Vec3(1, 0, 0),
                    axisB: new CANNON.Vec3(1, 0, 0)
                }
            );
            world.addConstraint(leftKneeConstraint);
            constraints.push(leftKneeConstraint);

            const rightKneeConstraint = new CANNON.HingeConstraint(
                rightUpperLeg.body,
                rightLowerLeg.body,
                {
                    pivotA: new CANNON.Vec3(0, -0.45, 0),
                    pivotB: new CANNON.Vec3(0, 0.45, 0),
                    axisA: new CANNON.Vec3(1, 0, 0),
                    axisB: new CANNON.Vec3(1, 0, 0)
                }
            );
            world.addConstraint(rightKneeConstraint);
            constraints.push(rightKneeConstraint);
        }

        // Create chain with hinge joints
        function createChain(position, numLinks = 8) {
            const linkSize = { x: 0.3, y: 1.0, z: 0.3 };
            let previousBody = null;

            for (let i = 0; i < numLinks; i++) {
                const linkPosition = new THREE.Vector3(
                    position.x,
                    position.y - i * linkSize.y,
                    position.z
                );

                const link = createBox(linkSize, linkPosition, 0xffd700);

                if (i === 0) {
                    // Fix first link
                    link.body.mass = 0;
                    link.body.updateMassProperties();
                }

                if (previousBody) {
                    const constraint = new CANNON.HingeConstraint(
                        previousBody,
                        link.body,
                        {
                            pivotA: new CANNON.Vec3(0, -linkSize.y / 2, 0),
                            pivotB: new CANNON.Vec3(0, linkSize.y / 2, 0),
                            axisA: new CANNON.Vec3(1, 0, 0),
                            axisB: new CANNON.Vec3(1, 0, 0)
                        }
                    );
                    world.addConstraint(constraint);
                    constraints.push(constraint);
                }

                previousBody = link.body;
            }
        }

        // Create initial stack
        function createStack(basePosition) {
            const boxSize = { x: 1, y: 1, z: 1 };
            const levels = 5;

            for (let level = 0; level < levels; level++) {
                for (let x = 0; x < levels - level; x++) {
                    const position = new THREE.Vector3(
                        basePosition.x + (x - (levels - level - 1) / 2) * boxSize.x * 1.1,
                        basePosition.y + level * boxSize.y * 1.1,
                        basePosition.z
                    );
                    createBox(boxSize, position);
                }
            }
        }

        // Initialize scene
        createStack(new THREE.Vector3(-5, 0.5, -5));
        createSphere(1, new THREE.Vector3(5, 5, 5), 0xff0000);
        createSphere(0.8, new THREE.Vector3(3, 5, 3), 0x00ff00);
        createRagdoll(new THREE.Vector3(0, 5, 0));
        createChain(new THREE.Vector3(8, 15, -5), 6);

        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedBody = null;
        let mouseConstraint = null;
        const mouseBody = new CANNON.Body({ mass: 0 });
        world.addBody(mouseBody);

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (selectedBody && mouseConstraint) {
                raycaster.setFromCamera(mouse, camera);
                const distance = selectedBody.position.distanceTo(camera.position);
                const direction = raycaster.ray.direction;
                const targetPosition = camera.position.clone().add(direction.multiplyScalar(distance));
                mouseBody.position.copy(targetPosition);
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                const selectedMesh = intersects[0].object;
                const index = meshes.indexOf(selectedMesh);
                
                if (index !== -1) {
                    selectedBody = bodies[index];
                    controls.enabled = false;

                    const distance = selectedBody.position.distanceTo(camera.position);
                    const direction = raycaster.ray.direction;
                    const targetPosition = camera.position.clone().add(direction.multiplyScalar(distance));
                    mouseBody.position.copy(targetPosition);

                    mouseConstraint = new CANNON.PointToPointConstraint(
                        selectedBody,
                        intersects[0].point,
                        mouseBody,
                        new CANNON.Vec3()
                    );
                    world.addConstraint(mouseConstraint);
                }
            }
        }

        function onMouseUp() {
            if (mouseConstraint) {
                world.removeConstraint(mouseConstraint);
                mouseConstraint = null;
            }
            selectedBody = null;
            controls.enabled = true;
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);

        // Controls
        let isSlowMotion = false;
        let timeScale = 1.0;

        const gravitySlider = document.getElementById('gravity-slider');
        const gravityValue = document.getElementById('gravity-value');
        const slowMotionBtn = document.getElementById('slow-motion-btn');
        const resetBtn = document.getElementById('reset-btn');

        gravitySlider.addEventListener('input', (e) => {
            const gravity = parseFloat(e.target.value);
            world.gravity.y = gravity;
            gravityValue.textContent = gravity.toFixed(2);
        });

        slowMotionBtn.addEventListener('click', () => {
            isSlowMotion = !isSlowMotion;
            timeScale = isSlowMotion ? 0.3 : 1.0;
            slowMotionBtn.textContent = isSlowMotion ? 'üêå Slow Motion: ON' : 'üêå Slow Motion: OFF';
            slowMotionBtn.classList.toggle('active');
        });

        resetBtn.addEventListener('click', () => {
            // Remove all bodies and meshes
            bodies.forEach(body => world.removeBody(body));
            meshes.forEach(mesh => scene.remove(mesh));
            constraints.forEach(constraint => world.removeConstraint(constraint));
            
            bodies.length = 0;
            meshes.length = 0;
            constraints.length = 0;

            // Recreate initial scene
            createStack(new THREE.Vector3(-5, 0.5, -5));
            createSphere(1, new THREE.Vector3(5, 5, 5), 0xff0000);
            createSphere(0.8, new THREE.Vector3(3, 5, 3), 0x00ff00);
            createRagdoll(new THREE.Vector3(0, 5, 0));
            createChain(new THREE.Vector3(8, 15, -5), 6);
        });

        // Spawn buttons
        document.getElementById('spawn-box-btn').addEventListener('click', () => {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                10,
                (Math.random() - 0.5) * 10
            );
            createBox({ x: 1, y: 1, z: 1 }, position);
        });

        document.getElementById('spawn-sphere-btn').addEventListener('click', () => {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                10,
                (Math.random() - 0.5) * 10
            );
            createSphere(0.8, position);
        });

        document.getElementById('spawn-stack-btn').addEventListener('click', () => {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                0.5,
                (Math.random() - 0.5) * 10
            );
            createStack(position);
        });

        document.getElementById('spawn-ragdoll-btn').addEventListener('click', () => {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                10,
                (Math.random() - 0.5) * 10
            );
            createRagdoll(position);
        });

        document.getElementById('spawn-chain-btn').addEventListener('click', () => {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                15,
                (Math.random() - 0.5) * 10
            );
            createChain(position, 6);
        });

        // Animation loop
        const clock = new THREE.Clock();
        const fixedTimeStep = 1 / 60;

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta() * timeScale;
            world.step(fixedTimeStep, deltaTime, 3);

            // Update meshes
            for (let i = 0; i < meshes.length; i++) {
                meshes[i].position.copy(bodies[i].position);
                meshes[i].quaternion.copy(bodies[i].quaternion);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>