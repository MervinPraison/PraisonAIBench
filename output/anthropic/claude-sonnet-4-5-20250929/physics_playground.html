<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 250px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .value-display {
            display: inline-block;
            float: right;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .toggle-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .toggle-btn.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            max-width: 300px;
        }
        
        #spawn-buttons {
            margin-top: 10px;
        }
        
        .spawn-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        
        h3 {
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h3>Physics Playground</h3>
        
        <div class="control-group">
            <label>
                Gravity: <span class="value-display" id="gravity-value">-9.82</span>
            </label>
            <input type="range" id="gravity-slider" min="-20" max="0" step="0.1" value="-9.82">
        </div>
        
        <div class="control-group">
            <button id="slowmo-btn" class="toggle-btn">Slow Motion: OFF</button>
        </div>
        
        <div class="control-group">
            <button id="reset-btn">Reset Scene</button>
        </div>
        
        <div id="spawn-buttons">
            <button class="spawn-btn" id="spawn-box">Add Box</button>
            <button class="spawn-btn" id="spawn-sphere">Add Sphere</button>
            <button class="spawn-btn" id="spawn-ragdoll">Add Ragdoll</button>
            <button class="spawn-btn" id="spawn-chain">Add Chain</button>
        </div>
    </div>
    
    <div id="info">
        <strong>Controls:</strong><br>
        • Click and drag objects to move them<br>
        • Use spawn buttons to add objects<br>
        • Adjust gravity and time scale<br>
        • Objects: Boxes, Spheres, Ragdolls, Chains
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 20, 100);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;
        world.defaultContactMaterial.contactEquationStiffness = 1e8;
        world.defaultContactMaterial.contactEquationRelaxation = 3;
        
        // Materials
        const groundMaterial = new CANNON.Material('groundMaterial');
        const objectMaterial = new CANNON.Material('objectMaterial');
        const contactMaterial = new CANNON.ContactMaterial(groundMaterial, objectMaterial, {
            friction: 0.4,
            restitution: 0.3
        });
        world.addContactMaterial(contactMaterial);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMesh = new THREE.Mesh(
            groundGeometry,
            new THREE.MeshStandardMaterial({ 
                color: 0x3a8c3a,
                roughness: 0.8,
                metalness: 0.2
            })
        );
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
        
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);
        
        // Arrays to keep track of objects
        const objects = [];
        const constraints = [];
        
        // Box creation
        function createBox(x, y, z, width = 1, height = 1, depth = 1, mass = 1) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: Math.random() * 0xffffff,
                roughness: 0.5,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            const shape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
            const body = new CANNON.Body({ mass, material: objectMaterial });
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);
            
            objects.push({ mesh, body });
            return { mesh, body };
        }
        
        // Sphere creation
        function createSphere(x, y, z, radius = 0.5, mass = 1) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: Math.random() * 0xffffff,
                roughness: 0.3,
                metalness: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass, material: objectMaterial });
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);
            
            objects.push({ mesh, body });
            return { mesh, body };
        }
        
        // Create ragdoll
        function createRagdoll(x, y, z) {
            const parts = [];
            
            // Head
            const head = createSphere(x, y + 2.3, z, 0.3, 1);
            parts.push(head);
            
            // Torso
            const torso = createBox(x, y + 1.5, z, 0.5, 0.8, 0.3, 2);
            parts.push(torso);
            
            // Upper arms
            const leftUpperArm = createBox(x - 0.5, y + 1.7, z, 0.5, 0.2, 0.2, 0.3);
            const rightUpperArm = createBox(x + 0.5, y + 1.7, z, 0.5, 0.2, 0.2, 0.3);
            parts.push(leftUpperArm, rightUpperArm);
            
            // Lower arms
            const leftLowerArm = createBox(x - 1, y + 1.7, z, 0.5, 0.2, 0.2, 0.3);
            const rightLowerArm = createBox(x + 1, y + 1.7, z, 0.5, 0.2, 0.2, 0.3);
            parts.push(leftLowerArm, rightLowerArm);
            
            // Upper legs
            const leftUpperLeg = createBox(x - 0.15, y + 0.6, z, 0.2, 0.6, 0.2, 0.5);
            const rightUpperLeg = createBox(x + 0.15, y + 0.6, z, 0.2, 0.6, 0.2, 0.5);
            parts.push(leftUpperLeg, rightUpperLeg);
            
            // Lower legs
            const leftLowerLeg = createBox(x - 0.15, y + 0.1, z, 0.2, 0.5, 0.2, 0.5);
            const rightLowerLeg = createBox(x + 0.15, y + 0.1, z, 0.2, 0.5, 0.2, 0.5);
            parts.push(leftLowerLeg, rightLowerLeg);
            
            // Joints
            // Head to torso
            const headConstraint = new CANNON.ConeTwistConstraint(torso.body, head.body, {
                pivotA: new CANNON.Vec3(0, 0.5, 0),
                pivotB: new CANNON.Vec3(0, -0.3, 0),
                axisA: new CANNON.Vec3(0, 1, 0),
                axisB: new CANNON.Vec3(0, 1, 0),
                angle: Math.PI / 6,
                twistAngle: Math.PI / 6
            });
            world.addConstraint(headConstraint);
            constraints.push(headConstraint);
            
            // Arms to torso
            const leftShoulderConstraint = new CANNON.ConeTwistConstraint(torso.body, leftUpperArm.body, {
                pivotA: new CANNON.Vec3(-0.3, 0.3, 0),
                pivotB: new CANNON.Vec3(0.25, 0, 0),
                axisA: new CANNON.Vec3(1, 0, 0),
                axisB: new CANNON.Vec3(1, 0, 0),
                angle: Math.PI / 3
            });
            world.addConstraint(leftShoulderConstraint);
            constraints.push(leftShoulderConstraint);
            
            const rightShoulderConstraint = new CANNON.ConeTwistConstraint(torso.body, rightUpperArm.body, {
                pivotA: new CANNON.Vec3(0.3, 0.3, 0),
                pivotB: new CANNON.Vec3(-0.25, 0, 0),
                axisA: new CANNON.Vec3(-1, 0, 0),
                axisB: new CANNON.Vec3(-1, 0, 0),
                angle: Math.PI / 3
            });
            world.addConstraint(rightShoulderConstraint);
            constraints.push(rightShoulderConstraint);
            
            // Elbow joints
            const leftElbowConstraint = new CANNON.HingeConstraint(leftUpperArm.body, leftLowerArm.body, {
                pivotA: new CANNON.Vec3(-0.25, 0, 0),
                pivotB: new CANNON.Vec3(0.25, 0, 0),
                axisA: new CANNON.Vec3(0, 0, 1),
                axisB: new CANNON.Vec3(0, 0, 1)
            });
            world.addConstraint(leftElbowConstraint);
            constraints.push(leftElbowConstraint);
            
            const rightElbowConstraint = new CANNON.HingeConstraint(rightUpperArm.body, rightLowerArm.body, {
                pivotA: new CANNON.Vec3(0.25, 0, 0),
                pivotB: new CANNON.Vec3(-0.25, 0, 0),
                axisA: new CANNON.Vec3(0, 0, 1),
                axisB: new CANNON.Vec3(0, 0, 1)
            });
            world.addConstraint(rightElbowConstraint);
            constraints.push(rightElbowConstraint);
            
            // Hip joints
            const leftHipConstraint = new CANNON.ConeTwistConstraint(torso.body, leftUpperLeg.body, {
                pivotA: new CANNON.Vec3(-0.15, -0.5, 0),
                pivotB: new CANNON.Vec3(0, 0.3, 0),
                axisA: new CANNON.Vec3(0, -1, 0),
                axisB: new CANNON.Vec3(0, 1, 0),
                angle: Math.PI / 4
            });
            world.addConstraint(leftHipConstraint);
            constraints.push(leftHipConstraint);
            
            const rightHipConstraint = new CANNON.ConeTwistConstraint(torso.body, rightUpperLeg.body, {
                pivotA: new CANNON.Vec3(0.15, -0.5, 0),
                pivotB: new CANNON.Vec3(0, 0.3, 0),
                axisA: new CANNON.Vec3(0, -1, 0),
                axisB: new CANNON.Vec3(0, 1, 0),
                angle: Math.PI / 4
            });
            world.addConstraint(rightHipConstraint);
            constraints.push(rightHipConstraint);
            
            // Knee joints
            const leftKneeConstraint = new CANNON.HingeConstraint(leftUpperLeg.body, leftLowerLeg.body, {
                pivotA: new CANNON.Vec3(0, -0.3, 0),
                pivotB: new CANNON.Vec3(0, 0.25, 0),
                axisA: new CANNON.Vec3(1, 0, 0),
                axisB: new CANNON.Vec3(1, 0, 0)
            });
            world.addConstraint(leftKneeConstraint);
            constraints.push(leftKneeConstraint);
            
            const rightKneeConstraint = new CANNON.HingeConstraint(rightUpperLeg.body, rightLowerLeg.body, {
                pivotA: new CANNON.Vec3(0, -0.3, 0),
                pivotB: new CANNON.Vec3(0, 0.25, 0),
                axisA: new CANNON.Vec3(1, 0, 0),
                axisB: new CANNON.Vec3(1, 0, 0)
            });
            world.addConstraint(rightKneeConstraint);
            constraints.push(rightKneeConstraint);
            
            return parts;
        }
        
        // Create chain with hinge joints
        function createChain(x, y, z, length = 5) {
            const links = [];
            const linkSize = 0.3;
            const linkSpacing = 0.4;
            
            for (let i = 0; i < length; i++) {
                const link = createBox(
                    x,
                    y - i * linkSpacing,
                    z,
                    linkSize,
                    linkSize,
                    linkSize,
                    i === 0 ? 0 : 0.5
                );
                links.push(link);
                
                if (i > 0) {
                    const constraint = new CANNON.HingeConstraint(links[i - 1].body, link.body, {
                        pivotA: new CANNON.Vec3(0, -linkSize / 2, 0),
                        pivotB: new CANNON.Vec3(0, linkSize / 2, 0),
                        axisA: new CANNON.Vec3(1, 0, 0),
                        axisB: new CANNON.Vec3(1, 0, 0)
                    });
                    world.addConstraint(constraint);
                    constraints.push(constraint);
                }
            }
            
            return links;
        }
        
        // Initial objects
        createBox(0, 5, 0, 1, 1, 1, 1);
        createBox(0, 6.5, 0, 1, 1, 1, 1);
        createSphere(2, 5, 0, 0.5, 1);
        createSphere(2, 6.5, 0, 0.5, 1);
        createChain(-3, 8, 0, 6);
        
        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedBody = null;
        let mouseConstraint = null;
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const intersection = new THREE.Vector3();
        
        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const meshes = objects.map(obj => obj.mesh);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const obj = objects.find(o => o.mesh === intersects[0].object);
                if (obj && obj.body.mass > 0) {
                    selectedBody = obj.body;
                    
                    // Update drag plane to face camera
                    const normal = new THREE.Vector3();
                    normal.subVectors(camera.position, intersects[0].point).normalize();
                    dragPlane.setFromNormalAndCoplanarPoint(normal, intersects[0].point);
                    
                    // Create constraint
                    const pivot = new CANNON.Vec3();
                    selectedBody.pointToLocalFrame(
                        new CANNON.Vec3(
                            intersects[0].point.x,
                            intersects[0].point.y,
                            intersects[0].point.z
                        ),
                        pivot
                    );
                    
                    const mouseBody = new CANNON.Body({ mass: 0 });
                    mouseBody.position.set(
                        intersects[0].point.x,
                        intersects[0].point.y,
                        intersects[0].point.z
                    );
                    world.addBody(mouseBody);
                    
                    mouseConstraint = new CANNON.PointToPointConstraint(
                        selectedBody,
                        pivot,
                        mouseBody,
                        new CANNON.Vec3(0, 0, 0)
                    );
                    world.addConstraint(mouseConstraint);
                    mouseConstraint.mouseBody = mouseBody;
                }
            }
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (mouseConstraint) {
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(dragPlane, intersection);
                
                mouseConstraint.mouseBody.position.copy(intersection);
            }
        }
        
        function onMouseUp() {
            if (mouseConstraint) {
                world.removeConstraint(mouseConstraint);
                world.removeBody(mouseConstraint.mouseBody);
                mouseConstraint = null;
                selectedBody = null;
            }
        }
        
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        
        // Controls
        let slowMotion = false;
        let timeScale = 1;
        
        document.getElementById('gravity-slider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            world.gravity.y = value;
            document.getElementById('gravity-value').textContent = value.toFixed(2);
        });
        
        document.getElementById('slowmo-btn').addEventListener('click', (e) => {
            slowMotion = !slowMotion;
            timeScale = slowMotion ? 0.2 : 1;
            e.target.textContent = `Slow Motion: ${slowMotion ? 'ON' : 'OFF'}`;
            e.target.classList.toggle('active');
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            // Remove all objects
            objects.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            objects.length = 0;
            
            // Remove all constraints
            constraints.forEach(constraint => {
                world.removeConstraint(constraint);
            });
            constraints.length = 0;
            
            // Add initial objects
            createBox(0, 5, 0, 1, 1, 1, 1);
            createBox(0, 6.5, 0, 1, 1, 1, 1);
            createSphere(2, 5, 0, 0.5, 1);
            createSphere(2, 6.5, 0, 0.5, 1);
            createChain(-3, 8, 0, 6);
        });
        
        document.getElementById('spawn-box').addEventListener('click', () => {
            createBox(
                Math.random() * 4 - 2,
                8 + Math.random() * 2,
                Math.random() * 4 - 2,
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5,
                1
            );
        });
        
        document.getElementById('spawn-sphere').addEventListener('click', () => {
            createSphere(
                Math.random() * 4 - 2,
                8 + Math.random() * 2,
                Math.random() * 4 - 2,
                Math.random() * 0.3 + 0.3,
                1
            );
        });
        
        document.getElementById('spawn-ragdoll').addEventListener('click', () => {
            createRagdoll(
                Math.random() * 4 - 2,
                8,
                Math.random() * 4 - 2
            );
        });
        
        document.getElementById('spawn-chain').addEventListener('click', () => {
            createChain(
                Math.random() * 4 - 2,
                10,
                Math.random() * 4 - 2,
                Math.floor(Math.random() * 3) + 4
            );
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            world.step(deltaTime * timeScale);
            
            // Update mesh positions
            objects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });
            
            // Camera orbit
            const time = Date.now() * 0.0001;
            camera.position.x = Math.cos(time) * 15;
            camera.position.z = Math.sin(time) * 15;
            camera.position.y = 10;
            camera.lookAt(0, 2, 0);
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>