<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Landscape</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        #info h3 {
            margin: 0 0 10px 0;
        }
        #info p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>3D Terrain Landscape</h3>
        <p><strong>Controls:</strong></p>
        <p>W/S - Move Forward/Backward</p>
        <p>A/D - Move Left/Right</p>
        <p>Q/E - Move Up/Down</p>
        <p>Arrow Keys - Look Around</p>
        <p>Mouse - Look Around (Click to enable)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 10, 300);
        scene.background = new THREE.Color(0x87CEEB);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Simplex noise implementation
        class SimplexNoise {
            constructor() {
                this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                             [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                             [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                this.p = [];
                for(let i=0; i<256; i++) {
                    this.p[i] = Math.floor(Math.random()*256);
                }
                this.perm = [];
                for(let i=0; i<512; i++) {
                    this.perm[i]=this.p[i & 255];
                }
            }

            dot(g, x, y) {
                return g[0]*x + g[1]*y;
            }

            noise(xin, yin) {
                let n0, n1, n2;
                const F2 = 0.5*(Math.sqrt(3.0)-1.0);
                const s = (xin+yin)*F2;
                const i = Math.floor(xin+s);
                const j = Math.floor(yin+s);
                const G2 = (3.0-Math.sqrt(3.0))/6.0;
                const t = (i+j)*G2;
                const X0 = i-t;
                const Y0 = j-t;
                const x0 = xin-X0;
                const y0 = yin-Y0;
                let i1, j1;
                if(x0>y0) {i1=1; j1=0;}
                else {i1=0; j1=1;}
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii+this.perm[jj]] % 12;
                const gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
                const gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
                let t0 = 0.5 - x0*x0-y0*y0;
                if(t0<0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                let t1 = 0.5 - x1*x1-y1*y1;
                if(t1<0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                let t2 = 0.5 - x2*x2-y2*y2;
                if(t2<0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                return 70.0 * (n0 + n1 + n2);
            }
        }

        const simplex = new SimplexNoise();

        // Generate terrain
        function generateTerrain() {
            const width = 200;
            const depth = 200;
            const segments = 100;
            
            const geometry = new THREE.PlaneGeometry(width, depth, segments, segments);
            const vertices = geometry.attributes.position.array;

            // Apply noise to create terrain
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                
                let height = 0;
                let amplitude = 15;
                let frequency = 0.02;
                
                // Multiple octaves of noise
                for (let octave = 0; octave < 4; octave++) {
                    height += simplex.noise(x * frequency, y * frequency) * amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                
                vertices[i + 2] = height;
            }

            geometry.computeVertexNormals();

            // Create texture based on height
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Create gradient texture
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#8B7355');    // Rock (high)
            gradient.addColorStop(0.3, '#6B5344');  // Dark rock
            gradient.addColorStop(0.5, '#4A7C2E');  // Grass (medium)
            gradient.addColorStop(0.7, '#3A6B25');  // Dark grass
            gradient.addColorStop(1, '#2F5A1F');    // Deep grass (low)
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some noise to texture
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 20;
                imageData.data[i] += noise;
                imageData.data[i + 1] += noise;
                imageData.data[i + 2] += noise;
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);

            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.9,
                metalness: 0.1
            });

            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            
            return terrain;
        }

        const terrain = generateTerrain();
        scene.add(terrain);

        // Add some trees/objects
        function addTrees() {
            const treeGeometry = new THREE.ConeGeometry(1, 4, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2511 });

            for (let i = 0; i < 50; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                
                // Get terrain height at this position
                let height = 0;
                let amplitude = 15;
                let frequency = 0.02;
                for (let octave = 0; octave < 4; octave++) {
                    height += simplex.noise(x * frequency, z * frequency) * amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }

                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, height + 1, z);
                trunk.castShadow = true;
                scene.add(trunk);

                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.set(x, height + 3, z);
                tree.castShadow = true;
                scene.add(tree);
            }
        }

        addTrees();

        // Camera controls
        const moveSpeed = 0.5;
        const lookSpeed = 0.02;
        const keys = {};
        let pitch = 0;
        let yaw = 0;

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse controls
        let isPointerLocked = false;
        
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }
        });

        function updateCamera() {
            const forward = new THREE.Vector3(
                Math.sin(yaw) * Math.cos(pitch),
                Math.sin(pitch),
                Math.cos(yaw) * Math.cos(pitch)
            ).normalize();

            const right = new THREE.Vector3(
                Math.sin(yaw - Math.PI / 2),
                0,
                Math.cos(yaw - Math.PI / 2)
            ).normalize();

            // Movement
            if (keys['w']) {
                camera.position.add(forward.clone().multiplyScalar(moveSpeed));
            }
            if (keys['s']) {
                camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['a']) {
                camera.position.add(right.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['d']) {
                camera.position.add(right.clone().multiplyScalar(moveSpeed));
            }
            if (keys['q']) {
                camera.position.y -= moveSpeed;
            }
            if (keys['e']) {
                camera.position.y += moveSpeed;
            }

            // Arrow key looking
            if (keys['arrowleft']) yaw += lookSpeed;
            if (keys['arrowright']) yaw -= lookSpeed;
            if (keys['arrowup']) pitch = Math.min(pitch + lookSpeed, Math.PI / 2);
            if (keys['arrowdown']) pitch = Math.max(pitch - lookSpeed, -Math.PI / 2);

            // Update camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;

            // Keep camera above terrain minimum
            camera.position.y = Math.max(camera.position.y, 2);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updateCamera();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>