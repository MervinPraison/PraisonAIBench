<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR VR Gallery</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
        }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #vrButton:hover {
            background: #45a049;
        }
        #vrButton:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.95);
            color: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            display: none;
            z-index: 200;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        #modal.active {
            display: block;
        }
        #modal h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #modal button {
            margin-top: 20px;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        #modal button:hover {
            background: #45a049;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 150;
        }
        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #4CAF50;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>WebXR VR Gallery</strong><br>
        <span id="vrStatus">VR Mode: Disabled</span><br><br>
        <strong>Desktop Controls:</strong><br>
        • WASD / Arrow Keys: Move<br>
        • Mouse: Look Around<br>
        • Click: Select Artwork<br><br>
        <strong>VR Controls:</strong><br>
        • Thumbstick/Touchpad: Teleport<br>
        • Trigger: Select Artwork<br>
        • Point at floor to teleport
    </div>
    <div class="fps-counter">
        FPS: <span id="fps">0</span>
    </div>
    <button id="vrButton">ENTER VR</button>
    <div id="modal">
        <h2 id="modalTitle">Artwork Title</h2>
        <p id="modalDescription">Description goes here...</p>
        <button onclick="closeModal()">Close</button>
    </div>
    <div id="loading">Loading Gallery...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ==================== GLOBAL VARIABLES ====================
        let camera, scene, renderer, controls;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let raycaster, intersected = [];
        let teleportMarker, reticle;
        let artworks = [];
        let audioListener, ambientSound;
        let clock, frameCount = 0, fps = 0, lastTime = 0;
        let isVRMode = false;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const desktopSpeed = 5.0;
        let mouseRaycaster, mouse = new THREE.Vector2();

        // Performance budget
        const TARGET_FPS = 90;
        const MIN_FPS = 72;

        // ==================== ARTWORK DATA ====================
        const artworkData = [
            {
                position: [3, 1.5, -3],
                rotation: [0, -Math.PI / 2, 0],
                title: "Abstract Sunset",
                artist: "Digital Dreams",
                description: "A mesmerizing blend of warm colors representing the transition between day and night. This piece explores the emotional depth of natural phenomena.",
                color: 0xff6b35,
                audioFile: null
            },
            {
                position: [-3, 1.5, -3],
                rotation: [0, Math.PI / 2, 0],
                title: "Geometric Harmony",
                artist: "Pixel Artisan",
                description: "Sharp lines and perfect shapes create a sense of order and balance. This work challenges our perception of space and dimension.",
                color: 0x4ecdc4,
                audioFile: null
            },
            {
                position: [0, 1.5, -4.9],
                rotation: [0, 0, 0],
                title: "Ocean Dreams",
                artist: "Wave Walker",
                description: "Deep blues and flowing forms evoke the mystery and power of the ocean. Let yourself drift into the aquatic realm.",
                color: 0x1a535c,
                audioFile: null
            },
            {
                position: [3, 1.5, 0],
                rotation: [0, -Math.PI / 2, 0],
                title: "Urban Energy",
                artist: "City Lights",
                description: "Capturing the vibrant pulse of metropolitan life through bold colors and dynamic composition.",
                color: 0xf7931e,
                audioFile: null
            },
            {
                position: [-3, 1.5, 0],
                rotation: [0, Math.PI / 2, 0],
                title: "Serenity",
                artist: "Zen Master",
                description: "Minimalist expression of peace and tranquility. This piece invites meditation and inner reflection.",
                color: 0x9b59b6,
                audioFile: null
            },
            {
                position: [0, 1.5, 4.9],
                rotation: [0, Math.PI, 0],
                title: "Fire Dance",
                artist: "Flame Keeper",
                description: "Dynamic reds and oranges capture the raw energy and transformative power of fire.",
                color: 0xe74c3c,
                audioFile: null
            }
        ];

        // ==================== INITIALIZATION ====================
        function init() {
            const container = document.getElementById('container');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 1, 20);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 1.6, 5);

            // Clock
            clock = new THREE.Clock();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Audio setup
            audioListener = new THREE.AudioListener();
            camera.add(audioListener);

            // Ambient audio
            ambientSound = new THREE.Audio(audioListener);
            const audioLoader = new THREE.AudioLoader();
            // Note: Using a silent audio context for demo - replace with actual ambient sound URL
            
            // Desktop controls
            controls = new PointerLockControls(camera, renderer.domElement);
            
            renderer.domElement.addEventListener('click', () => {
                if (!isVRMode) {
                    controls.lock();
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Mouse controls for selection
            mouseRaycaster = new THREE.Raycaster();
            document.addEventListener('click', onMouseClick);
            document.addEventListener('mousemove', onMouseMove);

            // VR Button
            const vrButton = document.getElementById('vrButton');
            
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.addEventListener('click', onVRButtonClick);
                    } else {
                        vrButton.textContent = 'VR NOT SUPPORTED';
                        vrButton.disabled = true;
                    }
                });
            } else {
                vrButton.textContent = 'WebXR NOT AVAILABLE';
                vrButton.disabled = true;
            }

            // VR Controllers setup
            setupVRControllers();

            // Raycaster for VR interaction
            raycaster = new THREE.Raycaster();

            // Build the scene
            createGalleryRoom();
            createArtworks();
            createLighting();
            createTeleportMarker();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);

            // Hide loading
            document.getElementById('loading').style.display = 'none';
        }

        // ==================== VR CONTROLLERS ====================
        function setupVRControllers() {
            const controllerModelFactory = new XRControllerModelFactory();

            // Controller 1
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('connected', function(event) {
                this.add(buildController(event.data));
            });
            controller1.addEventListener('disconnected', function() {
                this.remove(this.children[0]);
            });
            scene.add(controller1);

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            // Controller 2
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('connected', function(event) {
                this.add(buildController(event.data));
            });
            controller2.addEventListener('disconnected', function() {
                this.remove(this.children[0]);
            });
            scene.add(controller2);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            // Reticle for controller ray
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x4CAF50,
                linewidth: 2
            });
            
            reticle = new THREE.Line(geometry, material);
            reticle.name = 'reticle';
            reticle.scale.z = 5;
        }

        function buildController(data) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);

            const material = new THREE.LineBasicMaterial({ 
                color: 0x4CAF50,
                linewidth: 3
            });

            return new THREE.Line(geometry, material);
        }

        // ==================== GALLERY ROOM ====================
        function createGalleryRoom() {
            // Floor with baked lighting effect
            const floorGeometry = new THREE.PlaneGeometry(12, 12);
            const floorTexture = createBakedFloorTexture();
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.name = 'floor';
            scene.add(floor);

            // Walls with baked lighting
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                roughness: 0.9,
                metalness: 0.1
            });

            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 4),
                wallMaterial
            );
            backWall.position.set(0, 2, -6);
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Front wall
            const frontWall = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 4),
                wallMaterial
            );
            frontWall.position.set(0, 2, 6);
            frontWall.rotation.y = Math.PI;
            frontWall.receiveShadow = true;
            scene.add(frontWall);

            // Left wall
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 4),
                wallMaterial
            );
            leftWall.position.set(-6, 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 4),
                wallMaterial
            );
            rightWall.position.set(6, 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            // Ceiling
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 12),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a2e,
                    roughness: 0.9
                })
            );
            ceiling.position.y = 4;
            ceiling.rotation.x = Math.PI / 2;
            scene.add(ceiling);

            // Add decorative elements
            addDecorativeElements();
        }

        function createBakedFloorTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Create gradient for baked lighting effect
            const gradient = ctx.createRadialGradient(256, 256, 50, 256, 256, 256);
            gradient.addColorStop(0, '#3a3a3a');
            gradient.addColorStop(0.5, '#2a2a2a');
            gradient.addColorStop(1, '#1a1a1a');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // Add tile pattern
            ctx.strokeStyle = '#252525';
            ctx.lineWidth = 2;
            for (let i = 0; i < 512; i += 64) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 512);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(512, i);
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function addDecorativeElements() {
            // Add some pedestals
            const pedestalGeometry = new THREE.CylinderGeometry(0.3, 0.35, 0.8, 16);
            const pedestalMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x34495e,
                roughness: 0.7,
                metalness: 0.3
            });

            const pedestalPositions = [
                [2, 0.4, 2],
                [-2, 0.4, 2],
                [2, 0.4, -2],
                [-2, 0.4, -2]
            ];

            pedestalPositions.forEach(pos => {
                const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
                pedestal.position.set(...pos);
                pedestal.castShadow = true;
                pedestal.receiveShadow = true;
                scene.add(pedestal);

                // Add decorative sphere on top
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xe74c3c,
                        roughness: 0.3,
                        metalness: 0.7,
                        emissive: 0xe74c3c,
                        emissiveIntensity: 0.2
                    })
                );
                sphere.position.set(pos[0], 1.0, pos[2]);
                sphere.castShadow = true;
                scene.add(sphere);
            });
        }

        // ==================== ARTWORKS ====================
        function createArtworks() {
            artworkData.forEach((data, index) => {
                // Frame
                const frameGeometry = new THREE.BoxGeometry(1.8, 1.3, 0.1);
                const frameMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8b4513,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.set(...data.position);
                frame.rotation.set(...data.rotation);
                frame.castShadow = true;
                frame.receiveShadow = true;
                scene.add(frame);

                // Canvas
                const canvasTexture = createArtworkTexture(data.color, index);
                const canvasGeometry = new THREE.PlaneGeometry(1.6, 1.1);
                const canvasMaterial = new THREE.MeshStandardMaterial({ 
                    map: canvasTexture,
                    roughness: 0.7
                });
                const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
                canvas.position.set(...data.position);
                canvas.position.z += data.rotation[1] === 0 ? -0.06 : 
                                     (data.rotation[1] === Math.PI ? 0.06 : 0);
                canvas.position.x += data.rotation[1] === -Math.PI / 2 ? -0.06 : 
                                     (data.rotation[1] === Math.PI / 2 ? 0.06 : 0);
                canvas.rotation.set(...data.rotation);
                canvas.userData = { 
                    type: 'artwork', 
                    index: index,
                    data: data
                };
                scene.add(canvas);

                artworks.push(canvas);

                // Spotlight for artwork
                const spotlight = new THREE.SpotLight(0xffffff, 0.8);
                spotlight.position.set(
                    data.position[0],
                    3.5,
                    data.position[2]
                );
                spotlight.target = canvas;
                spotlight.angle = Math.PI / 6;
                spotlight.penumbra = 0.3;
                spotlight.decay = 2;
                spotlight.distance = 10;
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 512;
                spotlight.shadow.mapSize.height = 512;
                scene.add(spotlight);

                // Add positional audio to artwork
                const sound = new THREE.PositionalAudio(audioListener);
                canvas.add(sound);
                
                // Info label
                createInfoLabel(canvas, data);
            });
        }

        function createArtworkTexture(baseColor, index) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = `#${baseColor.toString(16).padStart(6, '0')}`;
            ctx.fillRect(0, 0, 512, 512);

            // Create different patterns for each artwork
            ctx.globalAlpha = 0.6;
            
            switch(index % 6) {
                case 0: // Circles
                    for (let i = 0; i < 10; i++) {
                        ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 60%)`;
                        ctx.beginPath();
                        ctx.arc(
                            Math.random() * 512,
                            Math.random() * 512,
                            Math.random() * 80 + 20,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                    break;
                case 1: // Rectangles
                    for (let i = 0; i < 15; i++) {
                        ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 60%)`;
                        ctx.fillRect(
                            Math.random() * 512,
                            Math.random() * 512,
                            Math.random() * 100 + 30,
                            Math.random() * 100 + 30
                        );
                    }
                    break;
                case 2: // Lines
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 5;
                    for (let i = 0; i < 20; i++) {
                        ctx.beginPath();
                        ctx.moveTo(Math.random() * 512, Math.random() * 512);
                        ctx.lineTo(Math.random() * 512, Math.random() * 512);
                        ctx.stroke();
                    }
                    break;
                case 3: // Gradient
                    const grad = ctx.createLinearGradient(0, 0, 512, 512);
                    grad.addColorStop(0, '#ff6b35');
                    grad.addColorStop(0.5, '#f7931e');
                    grad.addColorStop(1, '#4ecdc4');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 4: // Triangles
                    for (let i = 0; i < 10; i++) {
                        ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 60%)`;
                        ctx.beginPath();
                        ctx.moveTo(Math.random() * 512, Math.random() * 512);
                        ctx.lineTo(Math.random() * 512, Math.random() * 512);
                        ctx.lineTo(Math.random() * 512, Math.random() * 512);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;
                case 5: // Dots
                    for (let i = 0; i < 100; i++) {
                        ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 60%)`;
                        ctx.beginPath();
                        ctx.arc(
                            Math.random() * 512,
                            Math.random() * 512,
                            Math.random() * 15 + 5,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                    break;
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createInfoLabel(artwork, data) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, 512, 128);

            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(data.title, 256, 50);

            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.fillText(data.artist, 256, 90);

            const texture = new THREE.CanvasTexture(canvas);
            const labelGeometry = new THREE.PlaneGeometry(1.6, 0.4);
            const labelMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true
            });
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            
            label.position.copy(artwork.position);
            label.position.y -= 0.9;
            label.rotation.copy(artwork.rotation);
            
            scene.add(label);
        }

        // ==================== LIGHTING ====================
        function createLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Main ceiling lights
            const ceilingLights = [
                [-2, 3.8, -2],
                [2, 3.8, -2],
                [-2, 3.8, 2],
                [2, 3.8, 2],
                [0, 3.8, 0]
            ];

            ceilingLights.forEach(pos => {
                const light = new THREE.PointLight(0xfff5e1, 0.6, 8);
                light.position.set(...pos);
                light.castShadow = true;
                light.shadow.mapSize.width = 256;
                light.shadow.mapSize.height = 256;
                scene.add(light);

                // Add visible light fixture
                const fixture = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xfff5e1,
                        emissive: 0xfff5e1
                    })
                );
                fixture.position.set(...pos);
                scene.add(fixture);
            });

            // Hemisphere light for better overall illumination
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
            scene.add(hemiLight);
        }

        // ==================== TELEPORT MARKER ====================
        function createTeleportMarker() {
            const geometry = new THREE.RingGeometry(0.3, 0.35, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x4CAF50,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            teleportMarker = new THREE.Mesh(geometry, material);
            teleportMarker.rotation.x = -Math.PI / 2;
            teleportMarker.visible = false;
            scene.add(teleportMarker);
        }

        // ==================== VR INTERACTION ====================
        function onSelectStart(event) {
            const controller = event.target;
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);

            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const intersects = raycaster.intersectObjects(artworks, false);

            if (intersects.length > 0) {
                const artwork = intersects[0].object;
                if (artwork.userData.type === 'artwork') {
                    showModal(artwork.userData.data);
                    // Haptic feedback
                    if (controller.gamepad && controller.gamepad.hapticActuators && controller.gamepad.hapticActuators.length > 0) {
                        controller.gamepad.hapticActuators[0].pulse(0.5, 100);
                    }
                }
            }
        }

        function onSelectEnd(event) {
            // Handle select end if needed
        }

        // ==================== DESKTOP INTERACTION ====================
        function onKeyDown(event) {
            switch(event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch(event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
            if (!isVRMode && controls.isLocked) {
                mouseRaycaster.setFromCamera(mouse, camera);
                const intersects = mouseRaycaster.intersectObjects(artworks, false);

                if (intersects.length > 0) {
                    const artwork = intersects[0].object;
                    if (artwork.userData.type === 'artwork') {
                        controls.unlock();
                        showModal(artwork.userData.data);
                    }
                }
            }
        }

        // ==================== MODAL ====================
        function showModal(data) {
            const modal = document.getElementById('modal');
            document.getElementById('modalTitle').textContent = data.title;
            document.getElementById('modalDescription').innerHTML = `
                <strong>Artist:</strong> ${data.artist}<br><br>
                ${data.description}
            `;
            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('modal').classList.remove('active');
        }
        window.closeModal = closeModal; // Make it globally accessible

        // ==================== VR SESSION ====================
        function onVRButtonClick() {
            if (renderer.xr.isPresenting) {
                renderer.xr.getSession().end();
            } else {
                navigator.xr.requestSession('immersive-vr', {
                    optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                }).then((session) => {
                    renderer.xr.setSession(session);
                });
            }
        }

        function onSessionStart() {
            isVRMode = true;
            document.getElementById('vrStatus').textContent = 'VR Mode: Active';
            document.getElementById('vrButton').textContent = 'EXIT VR';
            
            // Disable desktop controls
            controls.unlock();
        }

        function onSessionEnd() {
            isVRMode = false;
            document.getElementById('vrStatus').textContent = 'VR Mode: Disabled';
            document.getElementById('vrButton').textContent = 'ENTER VR';
        }

        // ==================== TELEPORTATION ====================
        function handleTeleportation() {
            if (!renderer.xr.isPresenting) return;

            [controller1, controller2].forEach(controller => {
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);

                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                const intersects = raycaster.intersectObject(scene.getObjectByName('floor'), false);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    teleportMarker.position.copy(intersect.point);
                    teleportMarker.visible = true;

                    // Check for teleport trigger (using thumbstick/touchpad)
                    const session = renderer.xr.getSession();
                    if (session) {
                        const inputSources = session.inputSources;
                        inputSources.forEach((inputSource, index) => {
                            if (inputSource.gamepad) {
                                const axes = inputSource.gamepad.axes;
                                // Check if thumbstick is pushed forward (Y-axis < -0.5)
                                if (axes.length >= 2 && axes[1] < -0.5) {
                                    // Teleport player
                                    const offset = new THREE.Vector3();
                                    offset.copy(intersect.point);
                                    offset.y = 0; // Keep on ground level
                                    
                                    const baseReferenceSpace = renderer.xr.getReferenceSpace();
                                    const offsetPosition = { 
                                        x: -offset.x, 
                                        y: -offset.y, 
                                        z: -offset.z,
                                        w: 1 
                                    };
                                    const offsetRotation = { x: 0, y: 0, z: 0, w: 1 };
                                    const transform = new XRRigidTransform(offsetPosition, offsetRotation);
                                    const teleportSpace = baseReferenceSpace.getOffsetReferenceSpace(transform);
                                    renderer.xr.setReferenceSpace(teleportSpace);
                                    
                                    teleportMarker.visible = false;
                                }
                            }
                        });
                    }
                } else {
                    teleportMarker.visible = false;
                }
            });
        }

        // ==================== DESKTOP MOVEMENT ====================
        function updateDesktopMovement(delta) {
            if (!controls.isLocked) return;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * desktopSpeed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * desktopSpeed * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Keep player within bounds
            camera.position.x = Math.max(-5, Math.min(5, camera.position.x));
            camera.position.z = Math.max(-5, Math.min(5, camera.position.z));
            camera.position.y = 1.6; // Fixed height
        }

        // ==================== FPS COUNTER ====================
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                
                // Performance warning
                if (fps < MIN_FPS) {
                    console.warn(`Performance below target: ${fps} FPS`);
                }
                
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // ==================== WINDOW RESIZE ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== ANIMATION LOOP ====================
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            const delta = clock.getDelta();

            // Update FPS counter
            updateFPS();

            // Handle VR interactions
            if (renderer.xr.isPresenting) {
                handleTeleportation();
                
                // Highlight intersected artworks in VR
                [controller1, controller2].forEach(controller => {
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.identity().extractRotation(controller.matrixWorld);

                    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                    const intersects = raycaster.intersectObjects(artworks, false);

                    if (intersects.length > 0) {
                        const artwork = intersects[0].object;
                        if (artwork.userData.type === 'artwork') {
                            artwork.material.emissive.setHex(0x333333);
                        }
                    }

                    // Reset emissive
                    artworks.forEach(artwork => {
                        if (!intersects.find(i => i.object === artwork)) {
                            artwork.material.emissive.setHex(0x000000);
                        }
                    });
                });
            } else {
                // Desktop movement
                updateDesktopMovement(delta);

                // Desktop mouse hover effect
                if (controls.isLocked) {
                    mouseRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = mouseRaycaster.intersectObjects(artworks, false);

                    artworks.forEach(artwork => {
                        artwork.material.emissive.setHex(0x000000);
                    });

                    if (intersects.length > 0) {
                        const artwork = intersects[0].object;
                        if (artwork.userData.type === 'artwork') {
                            artwork.material.emissive.setHex(0x333333);
                        }
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // ==================== START ====================
        init();
        animate();
    </script>
</body>
</html>