<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Flight Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.6;
            pointer-events: none;
            text-shadow: 0 0 5px #0f0;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.8;
            text-shadow: 0 0 5px #0ff;
        }
        .key {
            display: inline-block;
            background: rgba(0, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            border: 1px solid #0ff;
        }
    </style>
</head>
<body>
    <div id="info">
        <div>ALTITUDE: <span id="altitude">0</span>m</div>
        <div>SPEED: <span id="speed">0</span>m/s</div>
        <div>PITCH: <span id="pitch">0</span>°</div>
        <div>ROLL: <span id="roll">0</span>°</div>
        <div>YAW: <span id="yaw">0</span>°</div>
        <div>TERRAIN HEIGHT: <span id="terrain">0</span>m</div>
    </div>
    <div id="controls">
        <div><span class="key">W/S</span> Pitch | <span class="key">A/D</span> Roll | <span class="key">Q/E</span> Yaw</div>
        <div><span class="key">↑/↓</span> Throttle | <span class="key">SHIFT</span> Boost | <span class="key">SPACE</span> Stabilize</div>
        <div><span class="key">R</span> Reset Position</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================
        // PERLIN NOISE IMPLEMENTATION
        // ============================================
        class PerlinNoise {
            constructor(seed = 0) {
                this.permutation = [];
                this.p = [];
                
                // Initialize permutation table with seed
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = i;
                }
                
                // Shuffle with seed
                this.shuffle(seed);
                
                // Duplicate permutation
                for (let i = 0; i < 512; i++) {
                    this.p[i] = this.permutation[i % 256];
                }
            }
            
            shuffle(seed) {
                const random = this.seededRandom(seed);
                for (let i = this.permutation.length - 1; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
            }
            
            seededRandom(seed) {
                return function() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };
            }
            
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            
            lerp(t, a, b) {
                return a + t * (b - a);
            }
            
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                
                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                
                const A = this.p[X] + Y;
                const AA = this.p[A] + Z;
                const AB = this.p[A + 1] + Z;
                const B = this.p[X + 1] + Y;
                const BA = this.p[B] + Z;
                const BB = this.p[B + 1] + Z;
                
                return this.lerp(w,
                    this.lerp(v,
                        this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)),
                        this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))
                    ),
                    this.lerp(v,
                        this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))
                    )
                );
            }
            
            octaveNoise(x, y, z, octaves, persistence) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;
                
                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency, z * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }
                
                return total / maxValue;
            }
        }

        // ============================================
        // SCENE SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.0015);
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ============================================
        // LIGHTING
        // ============================================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffee, 0.8);
        sunLight.position.set(500, 800, 300);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -500;
        sunLight.shadow.camera.right = 500;
        sunLight.shadow.camera.top = 500;
        sunLight.shadow.camera.bottom = -500;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 2000;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // ============================================
        // TERRAIN GENERATION
        // ============================================
        const perlin = new PerlinNoise(42);
        const terrainSize = 200;
        const terrainSegments = 128;
        const heightScale = 60;
        const riverLevel = 8;

        function getTerrainHeight(x, z) {
            const scale = 0.01;
            let height = perlin.octaveNoise(x * scale, z * scale, 0, 6, 0.5);
            height = height * 0.5 + 0.5; // Normalize to 0-1
            height = Math.pow(height, 1.5); // Add some variation
            
            // Create valleys for rivers
            const riverNoise = perlin.octaveNoise(x * 0.005, z * 0.005, 100, 3, 0.5);
            const riverMask = Math.abs(riverNoise);
            
            if (riverMask < 0.15) {
                height = Math.max(0, height - (0.15 - riverMask) * 3);
            }
            
            return height * heightScale;
        }

        const terrainGeometry = new THREE.PlaneGeometry(
            terrainSize, 
            terrainSize, 
            terrainSegments, 
            terrainSegments
        );

        const vertices = terrainGeometry.attributes.position.array;
        const colors = [];
        const heightMap = [];

        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 1];
            const height = getTerrainHeight(x, z);
            vertices[i + 2] = height;
            
            // Store height for collision detection
            heightMap.push({ x, z, height });
            
            // Color based on height
            let color;
            if (height < riverLevel) {
                color = new THREE.Color(0x1e5fa8); // Water
            } else if (height < 15) {
                color = new THREE.Color(0x8db360); // Grass
            } else if (height < 30) {
                color = new THREE.Color(0x6b8e23); // Dark grass
            } else if (height < 45) {
                color = new THREE.Color(0x8b7355); // Mountain
            } else {
                color = new THREE.Color(0xe0e0e0); // Snow
            }
            
            colors.push(color.r, color.g, color.b);
        }

        terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        terrainGeometry.computeVertexNormals();

        const terrainMaterial = new THREE.MeshStandardMaterial({
            vertexColors: true,
            flatShading: false,
            roughness: 0.8,
            metalness: 0.2
        });

        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.receiveShadow = true;
        scene.add(terrain);

        // ============================================
        // WATER PLANE
        // ============================================
        const waterGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x1e90ff,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1,
            metalness: 0.8
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = riverLevel;
        scene.add(water);

        // ============================================
        // INSTANCED TREES
        // ============================================
        const treeCount = 800;
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 4, 6);
        const foliageGeometry = new THREE.ConeGeometry(2.5, 6, 6);
        
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2511 });
        const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
        
        const trunks = new THREE.InstancedMesh(trunkGeometry, trunkMaterial, treeCount);
        const foliages = new THREE.InstancedMesh(foliageGeometry, foliageMaterial, treeCount);
        
        trunks.castShadow = true;
        foliages.castShadow = true;
        
        const dummy = new THREE.Object3D();
        let treeIndex = 0;
        
        for (let i = 0; i < treeCount * 3 && treeIndex < treeCount; i++) {
            const x = (Math.random() - 0.5) * terrainSize * 0.9;
            const z = (Math.random() - 0.5) * terrainSize * 0.9;
            const height = getTerrainHeight(x, z);
            
            // Only place trees on suitable terrain
            if (height > riverLevel + 2 && height < 40) {
                const scale = 0.7 + Math.random() * 0.6;
                
                // Trunk
                dummy.position.set(x, height + 2, z);
                dummy.scale.set(scale, scale, scale);
                dummy.rotation.y = Math.random() * Math.PI * 2;
                dummy.updateMatrix();
                trunks.setMatrixAt(treeIndex, dummy.matrix);
                
                // Foliage
                dummy.position.set(x, height + 5 * scale, z);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                foliages.setMatrixAt(treeIndex, dummy.matrix);
                
                treeIndex++;
            }
        }
        
        scene.add(trunks);
        scene.add(foliages);

        // ============================================
        // DRONE/PLANE CONTROLLER
        // ============================================
        const drone = {
            position: new THREE.Vector3(0, 50, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: new THREE.Euler(0, 0, 0),
            angularVelocity: new THREE.Vector3(0, 0, 0),
            baseSpeed: 30,
            currentSpeed: 30,
            boostMultiplier: 2.5,
            minHeight: 5,
            maxSpeed: 100
        };

        const controls = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            yawLeft: false,
            yawRight: false,
            throttleUp: false,
            throttleDown: false,
            boost: false,
            stabilize: false
        };

        window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': controls.forward = true; break;
                case 's': controls.backward = true; break;
                case 'a': controls.left = true; break;
                case 'd': controls.right = true; break;
                case 'q': controls.yawLeft = true; break;
                case 'e': controls.yawRight = true; break;
                case 'arrowup': controls.throttleUp = true; break;
                case 'arrowdown': controls.throttleDown = true; break;
                case 'shift': controls.boost = true; break;
                case ' ': controls.stabilize = true; e.preventDefault(); break;
                case 'r': resetDrone(); break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': controls.forward = false; break;
                case 's': controls.backward = false; break;
                case 'a': controls.left = false; break;
                case 'd': controls.right = false; break;
                case 'q': controls.yawLeft = false; break;
                case 'e': controls.yawRight = false; break;
                case 'arrowup': controls.throttleUp = false; break;
                case 'arrowdown': controls.throttleDown = false; break;
                case 'shift': controls.boost = false; break;
                case ' ': controls.stabilize = false; break;
            }
        });

        function resetDrone() {
            drone.position.set(0, 50, 0);
            drone.velocity.set(0, 0, 0);
            drone.rotation.set(0, 0, 0);
            drone.angularVelocity.set(0, 0, 0);
            drone.currentSpeed = drone.baseSpeed;
        }

        function getTerrainHeightAt(x, z) {
            // Simple height lookup
            const localX = x + terrainSize / 2;
            const localZ = z + terrainSize / 2;
            
            if (localX < 0 || localX > terrainSize || localZ < 0 || localZ > terrainSize) {
                return 0;
            }
            
            return getTerrainHeight(x, z);
        }

        function updateDrone(deltaTime) {
            const dt = Math.min(deltaTime, 0.05); // Cap delta time
            
            // Angular controls
            const pitchSpeed = 1.5;
            const rollSpeed = 2.0;
            const yawSpeed = 1.0;
            const angularDamping = 0.92;
            
            if (controls.forward) drone.angularVelocity.x -= pitchSpeed * dt;
            if (controls.backward) drone.angularVelocity.x += pitchSpeed * dt;
            if (controls.left) drone.angularVelocity.z += rollSpeed * dt;
            if (controls.right) drone.angularVelocity.z -= rollSpeed * dt;
            if (controls.yawLeft) drone.angularVelocity.y += yawSpeed * dt;
            if (controls.yawRight) drone.angularVelocity.y -= yawSpeed * dt;
            
            // Stabilization
            if (controls.stabilize) {
                drone.angularVelocity.multiplyScalar(0.9);
                drone.rotation.x *= 0.95;
                drone.rotation.z *= 0.95;
            }
            
            // Apply angular velocity with limits
            drone.rotation.x += drone.angularVelocity.x * dt;
            drone.rotation.y += drone.angularVelocity.y * dt;
            drone.rotation.z += drone.angularVelocity.z * dt;
            
            // Clamp rotations
            drone.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, drone.rotation.x));
            drone.rotation.z = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, drone.rotation.z));
            
            // Apply damping
            drone.angularVelocity.multiplyScalar(angularDamping);
            
            // Throttle control
            if (controls.throttleUp) drone.currentSpeed += 30 * dt;
            if (controls.throttleDown) drone.currentSpeed -= 30 * dt;
            
            const speedMultiplier = controls.boost ? drone.boostMultiplier : 1.0;
            const targetSpeed = drone.currentSpeed * speedMultiplier;
            drone.currentSpeed = Math.max(10, Math.min(drone.maxSpeed, drone.currentSpeed));
            
            // Calculate forward direction
            const forward = new THREE.Vector3(0, 0, -1);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromEuler(drone.rotation);
            forward.applyQuaternion(quaternion);
            
            // Apply velocity
            drone.velocity.copy(forward).multiplyScalar(targetSpeed);
            
            // Gravity and lift
            const liftFactor = Math.cos(drone.rotation.x) * Math.cos(drone.rotation.z);
            const gravity = -9.8;
            const lift = targetSpeed * 0.15 * liftFactor;
            
            drone.velocity.y += (gravity + lift) * dt;
            
            // Update position
            drone.position.add(drone.velocity.clone().multiplyScalar(dt));
            
            // Collision avoidance
            const terrainHeight = getTerrainHeightAt(drone.position.x, drone.position.z);
            const minHeight = terrainHeight + drone.minHeight;
            
            if (drone.position.y < minHeight) {
                drone.position.y = minHeight;
                drone.velocity.y = Math.max(0, drone.velocity.y);
                
                // Push away from terrain
                if (drone.velocity.y < 5) {
                    drone.velocity.y += 20 * dt;
                }
            }
            
            // Keep within bounds
            const boundary = terrainSize / 2 - 10;
            if (Math.abs(drone.position.x) > boundary || Math.abs(drone.position.z) > boundary) {
                const toCenter = new THREE.Vector3(0, drone.position.y, 0).sub(drone.position).normalize();
                drone.velocity.add(toCenter.multiplyScalar(10 * dt));
            }
        }

        function updateCamera() {
            const cameraOffset = new THREE.Vector3(0, 3, 10);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromEuler(drone.rotation);
            cameraOffset.applyQuaternion(quaternion);
            
            camera.position.copy(drone.position).add(cameraOffset);
            camera.lookAt(drone.position);
        }

        function updateHUD() {
            document.getElementById('altitude').textContent = drone.position.y.toFixed(1);
            document.getElementById('speed').textContent = drone.velocity.length().toFixed(1);
            document.getElementById('pitch').textContent = (drone.rotation.x * 180 / Math.PI).toFixed(1);
            document.getElementById('roll').textContent = (drone.rotation.z * 180 / Math.PI).toFixed(1);
            document.getElementById('yaw').textContent = (drone.rotation.y * 180 / Math.PI).toFixed(1);
            
            const terrainHeight = getTerrainHeightAt(drone.position.x, drone.position.z);
            document.getElementById('terrain').textContent = terrainHeight.toFixed(1);
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            updateDrone(deltaTime);
            updateCamera();
            updateHUD();
            
            // Animate water
            water.material.opacity = 0.6 + Math.sin(Date.now() * 0.001) * 0.1;
            
            renderer.render(scene, camera);
        }

        // ============================================
        // WINDOW RESIZE
        // ============================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>