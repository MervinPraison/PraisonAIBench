<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural 3D City Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
        }
        
        #ui-overlay h2 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #4CAF50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .control-group input[type="text"],
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        }
        
        .control-group button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .control-group button:hover {
            background: #45a049;
        }
        
        #mini-map {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4CAF50;
            border-radius: 10px;
            z-index: 100;
        }
        
        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            z-index: 100;
        }
        
        #time-control {
            margin-top: 10px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        
        .toggle-btn {
            margin-top: 10px;
            padding: 8px;
            background: #2196F3;
        }
        
        .toggle-btn:hover {
            background: #0b7dda;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <h2>üèôÔ∏è Procedural City</h2>
        <div class="control-group">
            <label for="seed-input">Seed:</label>
            <input type="text" id="seed-input" value="12345" placeholder="Enter seed">
        </div>
        <div class="control-group">
            <label for="grid-size">Grid Size:</label>
            <input type="number" id="grid-size" value="10" min="5" max="20">
        </div>
        <div class="control-group">
            <button id="generate-btn">Generate City</button>
        </div>
        <div class="control-group">
            <label for="time-slider">Time of Day:</label>
            <input type="range" id="time-slider" min="0" max="24" step="0.1" value="12">
            <div id="time-display">12:00</div>
        </div>
        <div class="control-group">
            <button class="toggle-btn" id="toggle-ui">Hide UI</button>
        </div>
    </div>
    
    <canvas id="mini-map"></canvas>
    
    <div id="info">
        <strong>Controls:</strong><br>
        WASD - Move<br>
        Mouse - Look around<br>
        Shift - Move faster<br>
        Space - Move up<br>
        Ctrl - Move down
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Seeded random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }
            
            randomRange(min, max) {
                return min + this.random() * (max - min);
            }
            
            randomInt(min, max) {
                return Math.floor(this.randomRange(min, max + 1));
            }
        }

        // City Generator Class
        class ProceduralCity {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                // Camera setup
                this.camera.position.set(50, 30, 50);
                this.cameraRotation = { x: 0, y: 0 };
                
                // Movement
                this.keys = {};
                this.velocity = new THREE.Vector3();
                this.moveSpeed = 0.5;
                this.sprintMultiplier = 2;
                
                // Mouse control
                this.mouseDown = false;
                this.mouseSensitivity = 0.002;
                
                // City data
                this.buildings = [];
                this.trafficLights = [];
                this.gridSize = 10;
                this.blockSize = 20;
                this.roadWidth = 4;
                this.seed = 12345;
                this.rng = new SeededRandom(this.seed);
                
                // Time
                this.timeOfDay = 12;
                this.autoTime = false;
                
                this.setupLights();
                this.setupEventListeners();
                this.generateCity();
                this.setupMiniMap();
                this.animate();
            }
            
            setupLights() {
                // Ambient light
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(this.ambientLight);
                
                // Directional light (sun)
                this.sunLight = new THREE.DirectionalLight(0xffffff, 1);
                this.sunLight.position.set(100, 100, 50);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.camera.left = -100;
                this.sunLight.shadow.camera.right = 100;
                this.sunLight.shadow.camera.top = 100;
                this.sunLight.shadow.camera.bottom = -100;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.scene.add(this.sunLight);
                
                // Hemisphere light for sky
                this.hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x362503, 0.6);
                this.scene.add(this.hemiLight);
            }
            
            updateDayNightCycle() {
                const hour = this.timeOfDay % 24;
                
                // Calculate sun position
                const sunAngle = (hour / 24) * Math.PI * 2 - Math.PI / 2;
                const sunDistance = 150;
                this.sunLight.position.x = Math.cos(sunAngle) * sunDistance;
                this.sunLight.position.y = Math.sin(sunAngle) * sunDistance;
                this.sunLight.position.z = 50;
                
                // Day/night colors
                let skyColor, groundColor, sunIntensity, ambientIntensity;
                
                if (hour >= 6 && hour < 8) { // Dawn
                    const t = (hour - 6) / 2;
                    skyColor = this.lerpColor(0x1a1a2e, 0x87CEEB, t);
                    groundColor = this.lerpColor(0x0f0f1e, 0x362503, t);
                    sunIntensity = 0.3 + t * 0.7;
                    ambientIntensity = 0.2 + t * 0.3;
                } else if (hour >= 8 && hour < 18) { // Day
                    skyColor = 0x87CEEB;
                    groundColor = 0x362503;
                    sunIntensity = 1.0;
                    ambientIntensity = 0.5;
                } else if (hour >= 18 && hour < 20) { // Dusk
                    const t = (hour - 18) / 2;
                    skyColor = this.lerpColor(0x87CEEB, 0x1a1a2e, t);
                    groundColor = this.lerpColor(0x362503, 0x0f0f1e, t);
                    sunIntensity = 1.0 - t * 0.7;
                    ambientIntensity = 0.5 - t * 0.3;
                } else { // Night
                    skyColor = 0x1a1a2e;
                    groundColor = 0x0f0f1e;
                    sunIntensity = 0.1;
                    ambientIntensity = 0.2;
                }
                
                this.scene.background = new THREE.Color(skyColor);
                this.scene.fog = new THREE.Fog(skyColor, 100, 500);
                this.hemiLight.color.setHex(skyColor);
                this.hemiLight.groundColor.setHex(groundColor);
                this.sunLight.intensity = sunIntensity;
                this.ambientLight.intensity = ambientIntensity;
                
                // Update building lights
                const isNight = hour < 6 || hour >= 20;
                this.buildings.forEach(building => {
                    if (building.windows) {
                        building.windows.visible = isNight;
                    }
                });
            }
            
            lerpColor(color1, color2, t) {
                const c1 = new THREE.Color(color1);
                const c2 = new THREE.Color(color2);
                return c1.lerp(c2, t).getHex();
            }
            
            generateCity() {
                // Clear existing city
                this.buildings.forEach(b => this.scene.remove(b));
                this.trafficLights.forEach(t => this.scene.remove(t));
                this.buildings = [];
                this.trafficLights = [];
                
                // Reset RNG
                this.rng = new SeededRandom(this.seed);
                
                // Create ground
                const groundSize = this.gridSize * (this.blockSize + this.roadWidth) + this.roadWidth;
                const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Generate roads
                this.generateRoads();
                
                // Generate blocks with buildings
                for (let x = 0; x < this.gridSize; x++) {
                    for (let z = 0; z < this.gridSize; z++) {
                        this.generateBlock(x, z);
                    }
                }
                
                // Generate traffic lights
                this.generateTrafficLights();
                
                this.updateDayNightCycle();
            }
            
            generateRoads() {
                const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                
                const totalSize = this.gridSize * (this.blockSize + this.roadWidth) + this.roadWidth;
                
                // Horizontal roads
                for (let i = 0; i <= this.gridSize; i++) {
                    const z = i * (this.blockSize + this.roadWidth);
                    const roadGeometry = new THREE.BoxGeometry(totalSize, 0.1, this.roadWidth);
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(totalSize / 2 - this.roadWidth / 2, 0.05, z);
                    road.receiveShadow = true;
                    this.scene.add(road);
                    
                    // Road lines
                    for (let j = 0; j < totalSize / 4; j++) {
                        const lineGeometry = new THREE.BoxGeometry(2, 0.11, 0.2);
                        const line = new THREE.Mesh(lineGeometry, lineMaterial);
                        line.position.set(j * 4, 0.06, z);
                        this.scene.add(line);
                    }
                }
                
                // Vertical roads
                for (let i = 0; i <= this.gridSize; i++) {
                    const x = i * (this.blockSize + this.roadWidth);
                    const roadGeometry = new THREE.BoxGeometry(this.roadWidth, 0.1, totalSize);
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(x, 0.05, totalSize / 2 - this.roadWidth / 2);
                    road.receiveShadow = true;
                    this.scene.add(road);
                    
                    // Road lines
                    for (let j = 0; j < totalSize / 4; j++) {
                        const lineGeometry = new THREE.BoxGeometry(0.2, 0.11, 2);
                        const line = new THREE.Mesh(lineGeometry, lineMaterial);
                        line.position.set(x, 0.06, j * 4);
                        this.scene.add(line);
                    }
                }
            }
            
            generateBlock(gridX, gridZ) {
                const blockX = gridX * (this.blockSize + this.roadWidth) + this.roadWidth;
                const blockZ = gridZ * (this.blockSize + this.roadWidth) + this.roadWidth;
                
                // Determine number of buildings in this block
                const numBuildings = this.rng.randomInt(1, 4);
                
                for (let i = 0; i < numBuildings; i++) {
                    const width = this.rng.randomRange(3, 8);
                    const depth = this.rng.randomRange(3, 8);
                    const height = this.rng.randomRange(10, 50);
                    
                    const offsetX = this.rng.randomRange(1, this.blockSize - width - 1);
                    const offsetZ = this.rng.randomRange(1, this.blockSize - depth - 1);
                    
                    this.createBuilding(
                        blockX + offsetX,
                        blockZ + offsetZ,
                        width,
                        depth,
                        height
                    );
                }
            }
            
            createBuilding(x, z, width, depth, height) {
                const buildingGroup = new THREE.Group();
                
                // Main building
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const hue = this.rng.random();
                const saturation = this.rng.randomRange(0.1, 0.4);
                const lightness = this.rng.randomRange(0.3, 0.6);
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                const material = new THREE.MeshLambertMaterial({ color: color });
                const building = new THREE.Mesh(geometry, material);
                building.position.set(x + width / 2, height / 2, z + depth / 2);
                building.castShadow = true;
                building.receiveShadow = true;
                buildingGroup.add(building);
                
                // Windows (glow at night)
                const windowsGroup = new THREE.Group();
                const windowMaterial = new THREE.MeshBasicMaterial({ color: 0xffee88 });
                
                const windowsPerFloor = Math.floor(Math.max(width, depth) / 1.5);
                const floors = Math.floor(height / 3);
                
                for (let floor = 1; floor < floors; floor++) {
                    for (let win = 0; win < windowsPerFloor; win++) {
                        if (this.rng.random() > 0.3) { // Random windows lit
                            const windowGeom = new THREE.BoxGeometry(0.3, 0.8, 0.1);
                            const windowMesh = new THREE.Mesh(windowGeom, windowMaterial);
                            
                            // Front face
                            windowMesh.position.set(
                                x + (win + 0.5) * (width / windowsPerFloor),
                                floor * 3,
                                z + depth + 0.05
                            );
                            windowsGroup.add(windowMesh.clone());
                            
                            // Back face
                            windowMesh.position.z = z - 0.05;
                            windowsGroup.add(windowMesh.clone());
                            
                            // Left face
                            const windowMesh2 = windowMesh.clone();
                            windowMesh2.rotation.y = Math.PI / 2;
                            windowMesh2.position.set(x - 0.05, floor * 3, z + (win + 0.5) * (depth / windowsPerFloor));
                            windowsGroup.add(windowMesh2);
                            
                            // Right face
                            windowMesh2.position.x = x + width + 0.05;
                            windowsGroup.add(windowMesh2.clone());
                        }
                    }
                }
                
                buildingGroup.add(windowsGroup);
                buildingGroup.windows = windowsGroup;
                
                this.scene.add(buildingGroup);
                this.buildings.push(buildingGroup);
            }
            
            generateTrafficLights() {
                for (let x = 0; x <= this.gridSize; x++) {
                    for (let z = 0; z <= this.gridSize; z++) {
                        const posX = x * (this.blockSize + this.roadWidth);
                        const posZ = z * (this.blockSize + this.roadWidth);
                        
                        if (x < this.gridSize && z < this.gridSize) {
                            this.createTrafficLight(posX + this.roadWidth / 2, posZ + this.roadWidth / 2);
                        }
                    }
                }
            }
            
            createTrafficLight(x, z) {
                const group = new THREE.Group();
                
                // Pole
                const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(x, 2, z);
                group.add(pole);
                
                // Light box
                const boxGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
                const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.set(x, 4.2, z);
                group.add(box);
                
                // Lights (red, yellow, green)
                const lightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                
                const redLight = new THREE.Mesh(
                    lightGeometry,
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                redLight.position.set(x, 4.5, z);
                group.add(redLight);
                
                const yellowLight = new THREE.Mesh(
                    lightGeometry,
                    new THREE.MeshBasicMaterial({ color: 0x333300 })
                );
                yellowLight.position.set(x, 4.2, z);
                group.add(yellowLight);
                
                const greenLight = new THREE.Mesh(
                    lightGeometry,
                    new THREE.MeshBasicMaterial({ color: 0x003300 })
                );
                greenLight.position.set(x, 3.9, z);
                group.add(greenLight);
                
                group.lights = { red: redLight, yellow: yellowLight, green: greenLight };
                group.state = 0; // 0: red, 1: yellow, 2: green
                group.timer = 0;
                
                this.scene.add(group);
                this.trafficLights.push(group);
            }
            
            updateTrafficLights(deltaTime) {
                this.trafficLights.forEach(light => {
                    light.timer += deltaTime;
                    
                    const cycleTime = 5; // seconds per state
                    
                    if (light.timer > cycleTime) {
                        light.timer = 0;
                        light.state = (light.state + 1) % 3;
                    }
                    
                    // Update light colors
                    switch (light.state) {
                        case 0: // Red
                            light.lights.red.material.color.setHex(0xff0000);
                            light.lights.yellow.material.color.setHex(0x333300);
                            light.lights.green.material.color.setHex(0x003300);
                            break;
                        case 1: // Yellow
                            light.lights.red.material.color.setHex(0x330000);
                            light.lights.yellow.material.color.setHex(0xffff00);
                            light.lights.green.material.color.setHex(0x003300);
                            break;
                        case 2: // Green
                            light.lights.red.material.color.setHex(0x330000);
                            light.lights.yellow.material.color.setHex(0x333300);
                            light.lights.green.material.color.setHex(0x00ff00);
                            break;
                    }
                });
            }
            
            setupMiniMap() {
                this.miniMapCanvas = document.getElementById('mini-map');
                this.miniMapCtx = this.miniMapCanvas.getContext('2d');
                this.miniMapCanvas.width = 200;
                this.miniMapCanvas.height = 200;
            }
            
            updateMiniMap() {
                const ctx = this.miniMapCtx;
                const canvas = this.miniMapCanvas;
                
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const scale = canvas.width / (this.gridSize * (this.blockSize + this.roadWidth));
                
                // Draw roads
                ctx.fillStyle = '#333333';
                for (let i = 0; i <= this.gridSize; i++) {
                    const pos = i * (this.blockSize + this.roadWidth) * scale;
                    ctx.fillRect(0, pos, canvas.width, this.roadWidth * scale);
                    ctx.fillRect(pos, 0, this.roadWidth * scale, canvas.height);
                }
                
                // Draw buildings
                ctx.fillStyle = '#666666';
                this.buildings.forEach(building => {
                    const pos = building.children[0].position;
                    const size = building.children[0].geometry.parameters;
                    const x = (pos.x - size.width / 2) * scale;
                    const z = (pos.z - size.depth / 2) * scale;
                    ctx.fillRect(x, z, size.width * scale, size.depth * scale);
                });
                
                // Draw camera position
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                const camX = this.camera.position.x * scale;
                const camZ = this.camera.position.z * scale;
                ctx.arc(camX, camZ, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw camera direction
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(camX, camZ);
                const dirX = Math.sin(this.cameraRotation.y) * 10;
                const dirZ = Math.cos(this.cameraRotation.y) * 10;
                ctx.lineTo(camX + dirX, camZ + dirZ);
                ctx.stroke();
            }
            
            setupEventListeners() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Mouse
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.mouseDown = true;
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                window.addEventListener('mouseup', () => {
                    this.mouseDown = false;
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.cameraRotation.y -= e.movementX * this.mouseSensitivity;
                        this.cameraRotation.x -= e.movementY * this.mouseSensitivity;
                        this.cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraRotation.x));
                    }
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // UI Controls
                document.getElementById('generate-btn').addEventListener('click', () => {
                    this.seed = parseInt(document.getElementById('seed-input').value) || Date.now();
                    this.gridSize = parseInt(document.getElementById('grid-size').value) || 10;
                    this.generateCity();
                });
                
                document.getElementById('time-slider').addEventListener('input', (e) => {
                    this.timeOfDay = parseFloat(e.target.value);
                    this.updateDayNightCycle();
                    const hours = Math.floor(this.timeOfDay);
                    const minutes = Math.floor((this.timeOfDay % 1) * 60);
                    document.getElementById('time-display').textContent = 
                        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                });
                
                let uiVisible = true;
                document.getElementById('toggle-ui').addEventListener('click', () => {
                    uiVisible = !uiVisible;
                    const overlay = document.getElementById('ui-overlay');
                    const info = document.getElementById('info');
                    const miniMap = document.getElementById('mini-map');
                    
                    if (uiVisible) {
                        overlay.style.display = 'block';
                        info.style.display = 'block';
                        miniMap.style.display = 'block';
                    } else {
                        overlay.style.display = 'none';
                        info.style.display = 'none';
                        miniMap.style.display = 'none';
                    }
                });
            }
            
            updateCamera(deltaTime) {
                const moveSpeed = this.keys['shift'] ? 
                    this.moveSpeed * this.sprintMultiplier : this.moveSpeed;
                
                const forward = new THREE.Vector3(
                    Math.sin(this.cameraRotation.y),
                    0,
                    Math.cos(this.cameraRotation.y)
                );
                
                const right = new THREE.Vector3(
                    Math.sin(this.cameraRotation.y + Math.PI / 2),
                    0,
                    Math.cos(this.cameraRotation.y + Math.PI / 2)
                );
                
                this.velocity.set(0, 0, 0);
                
                if (this.keys['w']) this.velocity.add(forward);
                if (this.keys['s']) this.velocity.sub(forward);
                if (this.keys['d']) this.velocity.add(right);
                if (this.keys['a']) this.velocity.sub(right);
                if (this.keys[' ']) this.velocity.y += 1;
                if (this.keys['control']) this.velocity.y -= 1;
                
                if (this.velocity.length() > 0) {
                    this.velocity.normalize();
                    this.camera.position.addScaledVector(this.velocity, moveSpeed);
                }
                
                // Update camera rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.cameraRotation.y;
                this.camera.rotation.x = this.cameraRotation.x;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = 0.016; // Approximate 60fps
                
                this.updateCamera(deltaTime);
                this.updateTrafficLights(deltaTime);
                this.updateMiniMap();
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the city
        window.addEventListener('DOMContentLoaded', () => {
            const city = new ProceduralCity();
        });
    </script>
</body>
</html>