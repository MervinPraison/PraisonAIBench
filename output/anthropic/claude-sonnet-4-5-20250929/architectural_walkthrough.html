<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architectural Walkthrough</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #interaction-prompt {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            font-size: 16px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
        }
        .room-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="minimap"></div>
    <div id="crosshair"></div>
    <div id="info">
        <strong>Controls:</strong><br>
        WASD - Move<br>
        Mouse - Look Around<br>
        E - Interact<br>
        Click to lock pointer
    </div>
    <div id="interaction-prompt">Press E to interact</div>
    <div id="loading">Loading environment...</div>
    <div class="room-label" id="room-label">Living Room</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 0, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.getElementById('container').appendChild(renderer.domElement);

        // Minimap setup
        const minimapScene = new THREE.Scene();
        const minimapCamera = new THREE.OrthographicCamera(-15, 15, 15, -15, 0.1, 100);
        minimapCamera.position.set(0, 20, 0);
        minimapCamera.lookAt(0, 0, 0);
        
        const minimapRenderer = new THREE.WebGLRenderer({ alpha: true });
        minimapRenderer.setSize(200, 200);
        minimapRenderer.setClearColor(0x000000, 0.3);
        document.getElementById('minimap').appendChild(minimapRenderer.domElement);

        // Player marker for minimap
        const playerMarkerGeom = new THREE.ConeGeometry(0.3, 0.8, 3);
        const playerMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const playerMarker = new THREE.Mesh(playerMarkerGeom, playerMarkerMat);
        playerMarker.rotation.x = Math.PI;
        minimapScene.add(playerMarker);

        // Controls
        const controls = new PointerLockControls(camera, document.body);
        
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            canJump: false
        };

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveSpeed = 5.0;
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 2);

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(5, 10, 5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 50;
        sunLight.shadow.camera.left = -20;
        sunLight.shadow.camera.right = 20;
        sunLight.shadow.camera.top = 20;
        sunLight.shadow.camera.bottom = -20;
        scene.add(sunLight);

        // Light probes for indirect lighting
        const lightProbe = new THREE.LightProbe();
        scene.add(lightProbe);

        // Materials library
        const materials = {
            wall: new THREE.MeshStandardMaterial({ 
                color: 0xf5f5dc, 
                roughness: 0.9, 
                metalness: 0.0 
            }),
            wallAlt: new THREE.MeshStandardMaterial({ 
                color: 0xe6e6fa, 
                roughness: 0.9, 
                metalness: 0.0 
            }),
            floor: new THREE.MeshStandardMaterial({ 
                color: 0x8b4513, 
                roughness: 0.8, 
                metalness: 0.0 
            }),
            floorAlt: new THREE.MeshStandardMaterial({ 
                color: 0xd2b48c, 
                roughness: 0.7, 
                metalness: 0.0 
            }),
            ceiling: new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.9, 
                metalness: 0.0 
            }),
            wood: new THREE.MeshStandardMaterial({ 
                color: 0x654321, 
                roughness: 0.6, 
                metalness: 0.0 
            }),
            metal: new THREE.MeshStandardMaterial({ 
                color: 0x808080, 
                roughness: 0.3, 
                metalness: 0.8 
            }),
            glass: new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                metalness: 0, 
                roughness: 0, 
                transmission: 0.9, 
                thickness: 0.5 
            }),
            fabric: new THREE.MeshStandardMaterial({ 
                color: 0x4169e1, 
                roughness: 0.9, 
                metalness: 0.0 
            }),
            fabricAlt: new THREE.MeshStandardMaterial({ 
                color: 0x8b0000, 
                roughness: 0.9, 
                metalness: 0.0 
            })
        };

        // House structure
        const house = {
            rooms: [],
            walls: [],
            furniture: [],
            hotspots: [],
            collisionObjects: []
        };

        // Room definitions
        const roomDefinitions = [
            { name: 'Living Room', x: 0, z: 0, width: 8, depth: 8, material: materials.floor },
            { name: 'Kitchen', x: 8, z: 0, width: 6, depth: 6, material: materials.floorAlt },
            { name: 'Bedroom', x: 0, z: 8, width: 6, depth: 6, material: materials.floor },
            { name: 'Bathroom', x: 6, z: 8, width: 4, depth: 4, material: materials.floorAlt },
            { name: 'Hallway', x: 6, z: 0, width: 2, depth: 8, material: materials.floor }
        ];

        let currentRoom = null;

        // Create procedural house
        function createHouse() {
            // Create rooms
            roomDefinitions.forEach(roomDef => {
                const room = createRoom(roomDef);
                house.rooms.push(room);
            });

            // Add furniture to rooms
            addFurniture();

            // Create exterior walls
            createExteriorWalls();

            // Add minimap representation
            createMinimapRepresentation();
        }

        function createRoom(roomDef) {
            const room = {
                name: roomDef.name,
                bounds: {
                    minX: roomDef.x,
                    maxX: roomDef.x + roomDef.width,
                    minZ: roomDef.z,
                    maxZ: roomDef.z + roomDef.depth
                },
                objects: [],
                visible: true
            };

            // Floor
            const floorGeometry = new THREE.BoxGeometry(roomDef.width, 0.1, roomDef.depth);
            const floor = new THREE.Mesh(floorGeometry, roomDef.material);
            floor.position.set(roomDef.x + roomDef.width/2, 0, roomDef.z + roomDef.depth/2);
            floor.receiveShadow = true;
            scene.add(floor);
            room.objects.push(floor);
            house.collisionObjects.push(floor);

            // Ceiling
            const ceiling = new THREE.Mesh(floorGeometry, materials.ceiling);
            ceiling.position.set(roomDef.x + roomDef.width/2, 3, roomDef.z + roomDef.depth/2);
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            room.objects.push(ceiling);

            // Room light
            const roomLight = new THREE.PointLight(0xffffff, 0.6, 10);
            roomLight.position.set(roomDef.x + roomDef.width/2, 2.5, roomDef.z + roomDef.depth/2);
            roomLight.castShadow = true;
            scene.add(roomLight);
            room.objects.push(roomLight);

            return room;
        }

        function createWall(x, y, z, width, height, depth, material) {
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(wallGeometry, material);
            wall.position.set(x, y, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            house.walls.push(wall);
            house.collisionObjects.push(wall);
            
            // Minimap representation
            const minimapWall = wall.clone();
            minimapWall.material = new THREE.MeshBasicMaterial({ color: 0x666666 });
            minimapScene.add(minimapWall);
            
            return wall;
        }

        function createExteriorWalls() {
            const wallHeight = 3;
            const wallThickness = 0.2;

            // Living room walls
            createWall(0, wallHeight/2, -wallThickness/2, 8, wallHeight, wallThickness, materials.wall);
            createWall(-wallThickness/2, wallHeight/2, 4, wallThickness, wallHeight, 8, materials.wall);
            
            // Kitchen walls
            createWall(14, wallHeight/2, 3, wallThickness, wallHeight, 6, materials.wallAlt);
            createWall(11, wallHeight/2, -wallThickness/2, 6, wallHeight, wallThickness, materials.wallAlt);
            
            // Bedroom walls
            createWall(-wallThickness/2, wallHeight/2, 11, wallThickness, wallHeight, 6, materials.wall);
            
            // Bathroom walls
            createWall(10, wallHeight/2, 10, wallThickness, wallHeight, 4, materials.wallAlt);
            
            // Internal walls with doorways
            // Living room to kitchen (with door)
            createWall(8, wallHeight/2, 1.5, wallThickness, wallHeight, 3, materials.wall);
            createWall(8, wallHeight/2, 4.5, wallThickness, wallHeight, 3, materials.wall);
            
            // Living room to bedroom (with door)
            createWall(1.5, wallHeight/2, 8, 3, wallHeight, wallThickness, materials.wall);
            createWall(4.5, wallHeight/2, 8, 3, wallHeight, wallThickness, materials.wall);
            
            // Bedroom to bathroom (with door)
            createWall(6, wallHeight/2, 9.5, wallThickness, wallHeight, 3, materials.wall);
            
            // Kitchen to hallway
            createWall(8, wallHeight/2, 8, wallThickness, wallHeight, 3, materials.wallAlt);
            
            // South wall
            createWall(7, wallHeight/2, 14, 14, wallHeight, wallThickness, materials.wall);
        }

        function addFurniture() {
            // Living room furniture
            const sofa = createSofa(-1, 0.4, 3, materials.fabric);
            addHotspot(sofa, 'Toggle Sofa Color', () => {
                sofa.children.forEach(child => {
                    if (child.material === materials.fabric) {
                        child.material = materials.fabricAlt;
                    } else {
                        child.material = materials.fabric;
                    }
                });
            });

            const coffeeTable = createTable(2, 0.25, 3, 2, 0.5, 1, materials.wood);
            addHotspot(coffeeTable, 'Toggle Table Material', () => {
                coffeeTable.children.forEach(child => {
                    if (child.material === materials.wood) {
                        child.material = materials.metal;
                    } else {
                        child.material = materials.wood;
                    }
                });
            });

            createLamp(5, 0, 5, materials.metal);
            createTV(0.2, 1, 0.5, materials.metal);

            // Kitchen furniture
            createCounter(10, 0.45, 2, 3, 0.9, 0.6, materials.wood);
            createRefrigerator(13.5, 0.9, 1, materials.metal);
            createTable(10, 0.4, 4.5, 1.5, 0.8, 1.5, materials.wood);

            // Bedroom furniture
            const bed = createBed(2, 0.3, 11, materials.fabric);
            addHotspot(bed, 'Toggle Bed Color', () => {
                bed.children.forEach(child => {
                    if (child.isMesh && child.geometry.type !== 'BoxGeometry') {
                        if (child.material === materials.fabric) {
                            child.material = materials.fabricAlt;
                        } else {
                            child.material = materials.fabric;
                        }
                    }
                });
            });

            createWardrobe(5.7, 1, 9.3, materials.wood);
            createNightstand(4, 0.3, 10.5, materials.wood);

            // Bathroom furniture
            createToilet(7, 0.4, 9, materials.glass);
            createSink(9.7, 0.4, 10, materials.metal);
            createBathtub(8, 0.3, 12.5, materials.glass);

            // Hallway decoration
            createPlant(7, 0, 4, materials.wood);
        }

        function createSofa(x, y, z, material) {
            const sofa = new THREE.Group();
            
            // Base
            const baseGeom = new THREE.BoxGeometry(3, 0.6, 1.5);
            const base = new THREE.Mesh(baseGeom, material);
            base.castShadow = true;
            sofa.add(base);
            
            // Back
            const backGeom = new THREE.BoxGeometry(3, 1, 0.3);
            const back = new THREE.Mesh(backGeom, material);
            back.position.set(0, 0.5, -0.6);
            back.castShadow = true;
            sofa.add(back);
            
            // Arms
            const armGeom = new THREE.BoxGeometry(0.3, 0.8, 1.5);
            const leftArm = new THREE.Mesh(armGeom, material);
            leftArm.position.set(-1.35, 0.1, 0);
            leftArm.castShadow = true;
            sofa.add(leftArm);
            
            const rightArm = leftArm.clone();
            rightArm.position.set(1.35, 0.1, 0);
            sofa.add(rightArm);
            
            sofa.position.set(x, y, z);
            scene.add(sofa);
            house.furniture.push(sofa);
            house.collisionObjects.push(sofa);
            
            return sofa;
        }

        function createTable(x, y, z, width, height, depth, material) {
            const table = new THREE.Group();
            
            // Top
            const topGeom = new THREE.BoxGeometry(width, 0.1, depth);
            const top = new THREE.Mesh(topGeom, material);
            top.position.y = height - 0.05;
            top.castShadow = true;
            table.add(top);
            
            // Legs
            const legGeom = new THREE.CylinderGeometry(0.05, 0.05, height - 0.1);
            const positions = [
                [width/2 - 0.2, height/2 - 0.05, depth/2 - 0.2],
                [-width/2 + 0.2, height/2 - 0.05, depth/2 - 0.2],
                [width/2 - 0.2, height/2 - 0.05, -depth/2 + 0.2],
                [-width/2 + 0.2, height/2 - 0.05, -depth/2 + 0.2]
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeom, material);
                leg.position.set(...pos);
                leg.castShadow = true;
                table.add(leg);
            });
            
            table.position.set(x, y, z);
            scene.add(table);
            house.furniture.push(table);
            house.collisionObjects.push(table);
            
            return table;
        }

        function createLamp(x, y, z, material) {
            const lamp = new THREE.Group();
            
            // Base
            const baseGeom = new THREE.CylinderGeometry(0.2, 0.3, 0.1);
            const base = new THREE.Mesh(baseGeom, material);
            base.castShadow = true;
            lamp.add(base);
            
            // Pole
            const poleGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.2);
            const pole = new THREE.Mesh(poleGeom, material);
            pole.position.y = 0.6;
            pole.castShadow = true;
            lamp.add(pole);
            
            // Shade
            const shadeGeom = new THREE.ConeGeometry(0.4, 0.6, 8);
            const shade = new THREE.Mesh(shadeGeom, materials.fabric);
            shade.position.y = 1.4;
            shade.castShadow = true;
            lamp.add(shade);
            
            // Light
            const lampLight = new THREE.PointLight(0xffffcc, 0.5, 5);
            lampLight.position.y = 1.2;
            lampLight.castShadow = true;
            lamp.add(lampLight);
            
            lamp.position.set(x, y, z);
            scene.add(lamp);
            house.furniture.push(lamp);
            
            return lamp;
        }

        function createTV(x, y, z, material) {
            const tv = new THREE.Group();
            
            // Screen
            const screenGeom = new THREE.BoxGeometry(2, 1.2, 0.1);
            const screen = new THREE.Mesh(screenGeom, new THREE.MeshStandardMaterial({ color: 0x111111 }));
            screen.castShadow = true;
            tv.add(screen);
            
            // Stand base
            const standBaseGeom = new THREE.CylinderGeometry(0.3, 0.3, 0.1);
            const standBase = new THREE.Mesh(standBaseGeom, material);
            standBase.position.set(0, -0.7, 0.1);
            standBase.castShadow = true;
            tv.add(standBase);
            
            // Stand pole
            const standPoleGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
            const standPole = new THREE.Mesh(standPoleGeom, material);
            standPole.position.set(0, -0.45, 0.1);
            standPole.castShadow = true;
            tv.add(standPole);
            
            tv.position.set(x, y, z);
            scene.add(tv);
            house.furniture.push(tv);
            house.collisionObjects.push(tv);
            
            return tv;
        }

        function createCounter(x, y, z, width, height, depth, material) {
            const counter = new THREE.Group();
            
            const counterGeom = new THREE.BoxGeometry(width, height, depth);
            const counterMesh = new THREE.Mesh(counterGeom, material);
            counterMesh.castShadow = true;
            counter.add(counterMesh);
            
            counter.position.set(x, y, z);
            scene.add(counter);
            house.furniture.push(counter);
            house.collisionObjects.push(counter);
            
            return counter;
        }

        function createRefrigerator(x, y, z, material) {
            const fridge = new THREE.Group();
            
            const fridgeGeom = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            const fridgeMesh = new THREE.Mesh(fridgeGeom, material);
            fridgeMesh.castShadow = true;
            fridge.add(fridgeMesh);
            
            fridge.position.set(x, y, z);
            scene.add(fridge);
            house.furniture.push(fridge);
            house.collisionObjects.push(fridge);
            
            return fridge;
        }

        function createBed(x, y, z, material) {
            const bed = new THREE.Group();
            
            // Mattress
            const mattressGeom = new THREE.BoxGeometry(2, 0.4, 3);
            const mattress = new THREE.Mesh(mattressGeom, material);
            mattress.position.y = 0.2;
            mattress.castShadow = true;
            bed.add(mattress);
            
            // Frame
            const frameGeom = new THREE.BoxGeometry(2.2, 0.3, 3.2);
            const frame = new THREE.Mesh(frameGeom, materials.wood);
            frame.castShadow = true;
            bed.add(frame);
            
            // Headboard
            const headboardGeom = new THREE.BoxGeometry(2.2, 1, 0.2);
            const headboard = new THREE.Mesh(headboardGeom, materials.wood);
            headboard.position.set(0, 0.5, -1.5);
            headboard.castShadow = true;
            bed.add(headboard);
            
            bed.position.set(x, y, z);
            scene.add(bed);
            house.furniture.push(bed);
            house.collisionObjects.push(bed);
            
            return bed;
        }

        function createWardrobe(x, y, z, material) {
            const wardrobe = new THREE.Group();
            
            const wardrobeGeom = new THREE.BoxGeometry(1.5, 2, 0.6);
            const wardrobeMesh = new THREE.Mesh(wardrobeGeom, material);
            wardrobeMesh.castShadow = true;
            wardrobe.add(wardrobeMesh);
            
            wardrobe.position.set(x, y, z);
            scene.add(wardrobe);
            house.furniture.push(wardrobe);
            house.collisionObjects.push(wardrobe);
            
            return wardrobe;
        }

        function createNightstand(x, y, z, material) {
            const nightstand = new THREE.Group();
            
            const nightstandGeom = new THREE.BoxGeometry(0.5, 0.6, 0.4);
            const nightstandMesh = new THREE.Mesh(nightstandGeom, material);
            nightstandMesh.castShadow = true;
            nightstand.add(nightstandMesh);
            
            nightstand.position.set(x, y, z);
            scene.add(nightstand);
            house.furniture.push(nightstand);
            house.collisionObjects.push(nightstand);
            
            return nightstand;
        }

        function createToilet(x, y, z, material) {
            const toilet = new THREE.Group();
            
            // Bowl
            const bowlGeom = new THREE.CylinderGeometry(0.3, 0.25, 0.4, 16);
            const bowl = new THREE.Mesh(bowlGeom, material);
            bowl.position.y = 0.2;
            bowl.castShadow = true;
            toilet.add(bowl);
            
            // Tank
            const tankGeom = new THREE.BoxGeometry(0.4, 0.5, 0.2);
            const tank = new THREE.Mesh(tankGeom, material);
            tank.position.set(0, 0.5, -0.25);
            tank.castShadow = true;
            toilet.add(tank);
            
            toilet.position.set(x, y, z);
            scene.add(toilet);
            house.furniture.push(toilet);
            house.collisionObjects.push(toilet);
            
            return toilet;
        }

        function createSink(x, y, z, material) {
            const sink = new THREE.Group();
            
            // Basin
            const basinGeom = new THREE.CylinderGeometry(0.3, 0.25, 0.2, 16);
            const basin = new THREE.Mesh(basinGeom, material);
            basin.position.y = 0.3;
            basin.castShadow = true;
            sink.add(basin);
            
            // Counter
            const counterGeom = new THREE.BoxGeometry(0.6, 0.1, 0.5);
            const counter = new THREE.Mesh(counterGeom, materials.wood);
            counter.position.y = 0.3;
            counter.castShadow = true;
            sink.add(counter);
            
            sink.position.set(x, y, z);
            scene.add(sink);
            house.furniture.push(sink);
            house.collisionObjects.push(sink);
            
            return sink;
        }

        function createBathtub(x, y, z, material) {
            const bathtub = new THREE.Group();
            
            const tubGeom = new THREE.BoxGeometry(1.5, 0.6, 0.8);
            const tub = new THREE.Mesh(tubGeom, material);
            tub.castShadow = true;
            bathtub.add(tub);
            
            bathtub.position.set(x, y, z);
            scene.add(bathtub);
            house.furniture.push(bathtub);
            house.collisionObjects.push(bathtub);
            
            return bathtub;
        }

        function createPlant(x, y, z, material) {
            const plant = new THREE.Group();
            
            // Pot
            const potGeom = new THREE.CylinderGeometry(0.2, 0.15, 0.3, 8);
            const pot = new THREE.Mesh(potGeom, material);
            pot.position.y = 0.15;
            pot.castShadow = true;
            plant.add(pot);
            
            // Leaves
            const leafGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leafGeom, leafMat);
            leaves.position.y = 0.6;
            leaves.castShadow = true;
            plant.add(leaves);
            
            plant.position.set(x, y, z);
            scene.add(plant);
            house.furniture.push(plant);
            
            return plant;
        }

        function createMinimapRepresentation() {
            // Add floor plan to minimap
            roomDefinitions.forEach(roomDef => {
                const floorGeom = new THREE.PlaneGeometry(roomDef.width, roomDef.depth);
                const floorMat = new THREE.MeshBasicMaterial({ 
                    color: 0x333333,
                    side: THREE.DoubleSide
                });
                const floor = new THREE.Mesh(floorGeom, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(
                    roomDef.x + roomDef.width/2,
                    0.05,
                    roomDef.z + roomDef.depth/2
                );
                minimapScene.add(floor);
            });
        }

        // Hotspot system
        function addHotspot(object, label, callback) {
            const hotspot = {
                object: object,
                label: label,
                callback: callback,
                position: object.position.clone()
            };
            house.hotspots.push(hotspot);
        }

        let currentHotspot = null;
        const interactionRaycaster = new THREE.Raycaster();
        const interactionDistance = 3;

        function checkHotspots() {
            interactionRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            let closestHotspot = null;
            let closestDistance = interactionDistance;
            
            house.hotspots.forEach(hotspot => {
                const distance = camera.position.distanceTo(hotspot.position);
                if (distance < closestDistance) {
                    // Check if looking at the hotspot
                    const intersects = interactionRaycaster.intersectObject(hotspot.object, true);
                    if (intersects.length > 0 && intersects[0].distance < interactionDistance) {
                        closestHotspot = hotspot;
                        closestDistance = distance;
                    }
                }
            });
            
            if (closestHotspot !== currentHotspot) {
                currentHotspot = closestHotspot;
                const prompt = document.getElementById('interaction-prompt');
                if (currentHotspot) {
                    prompt.textContent = `Press E: ${currentHotspot.label}`;
                    prompt.style.display = 'block';
                } else {
                    prompt.style.display = 'none';
                }
            }
        }

        // Collision detection
        function checkCollisions(position) {
            const playerRadius = 0.3;
            const playerHeight = 1.6;
            
            for (let obj of house.collisionObjects) {
                if (!obj.geometry) continue;
                
                const box = new THREE.Box3().setFromObject(obj);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(
                        position.x - playerRadius,
                        position.y,
                        position.z - playerRadius
                    ),
                    new THREE.Vector3(
                        position.x + playerRadius,
                        position.y + playerHeight,
                        position.z + playerRadius
                    )
                );
                
                if (box.intersectsBox(playerBox)) {
                    return true;
                }
            }
            
            return false;
        }

        // Room-based culling
        function updateRoomCulling() {
            const playerPos = camera.position;
            
            // Find current room
            let newCurrentRoom = null;
            house.rooms.forEach(room => {
                if (playerPos.x >= room.bounds.minX && playerPos.x <= room.bounds.maxX &&
                    playerPos.z >= room.bounds.minZ && playerPos.z <= room.bounds.maxZ) {
                    newCurrentRoom = room;
                }
            });
            
            if (newCurrentRoom !== currentRoom) {
                currentRoom = newCurrentRoom;
                const roomLabel = document.getElementById('room-label');
                if (currentRoom) {
                    roomLabel.textContent = currentRoom.name;
                    roomLabel.style.display = 'block';
                    setTimeout(() => {
                        roomLabel.style.display = 'none';
                    }, 2000);
                }
            }
            
            // Simple culling: show adjacent rooms
            house.rooms.forEach(room => {
                if (!currentRoom) {
                    room.visible = true;
                    return;
                }
                
                const distance = Math.sqrt(
                    Math.pow((room.bounds.minX + room.bounds.maxX)/2 - playerPos.x, 2) +
                    Math.pow((room.bounds.minZ + room.bounds.maxZ)/2 - playerPos.z, 2)
                );
                
                room.visible = distance < 15;
                room.objects.forEach(obj => {
                    obj.visible = room.visible;
                });
            });
        }

        // Event listeners
        document.addEventListener('click', () => {
            controls.lock();
        });

        document.addEventListener('keydown', (event) => {
            switch(event.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'KeyE':
                    if (currentHotspot) {
                        currentHotspot.callback();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch(event.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        const clock = new THREE.Clock();
        let previousTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = clock.getDelta();

            if (controls.isLocked) {
                // Update velocity
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize();

                if (moveState.forward || moveState.backward) velocity.z -= direction.z * moveSpeed * delta;
                if (moveState.left || moveState.right) velocity.x -= direction.x * moveSpeed * delta;

                // Save current position
                const oldPosition = camera.position.clone();

                // Move
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Check collisions
                if (checkCollisions(camera.position)) {
                    camera.position.copy(oldPosition);
                    velocity.set(0, 0, 0);
                }

                // Keep player above ground
                if (camera.position.y < 1.6) {
                    camera.position.y = 1.6;
                }
                
                // Keep player in bounds
                camera.position.x = Math.max(-2, Math.min(15, camera.position.x));
                camera.position.z = Math.max(-2, Math.min(15, camera.position.z));

                // Update systems
                checkHotspots();
                updateRoomCulling();

                // Update minimap player marker
                playerMarker.position.set(camera.position.x, 0, camera.position.z);
                playerMarker.rotation.y = -controls.getObject().rotation.y;
            }

            previousTime = time;

            // Render main scene
            renderer.render(scene, camera);
            
            // Render minimap
            minimapRenderer.render(minimapScene, minimapCamera);
        }

        // Initialize
        async function init() {
            // Create house
            createHouse();

            // Setup light probe (simple approximation)
            const lightProbeGen = new THREE.LightProbeGenerator();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animate();
        }

        init();
    </script>
</body>
</html>