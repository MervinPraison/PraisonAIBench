<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 18px;
            text-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 100;
        }
        #health-bar {
            width: 200px;
            height: 20px;
            border: 2px solid #0ff;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.5);
        }
        #health-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #ff0, #f00);
            transition: width 0.3s;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f00;
            font-size: 48px;
            text-shadow: 0 0 20px #f00;
            display: none;
            z-index: 200;
        }
        #game-over button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 24px;
            background: #0ff;
            border: none;
            color: #000;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: none;
        }
        #game-over button:hover {
            background: #0aa;
        }
        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            display: none;
            pointer-events: all;
        }
        @media (max-width: 768px) {
            #touch-controls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui">
        <div>SCORE: <span id="score">0</span></div>
        <div>WAVE: <span id="wave">1</span></div>
        <div id="health-bar">
            <div id="health-fill" style="width: 100%;"></div>
        </div>
    </div>
    <div id="game-over">
        <div>GAME OVER</div>
        <div style="font-size: 24px; margin-top: 20px;">Final Score: <span id="final-score">0</span></div>
        <button onclick="restartGame()">RESTART</button>
    </div>
    <div id="touch-controls"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const gameState = {
            score: 0,
            wave: 1,
            health: 100,
            maxHealth: 100,
            gameOver: false,
            difficulty: 1,
            enemiesKilled: 0
        };

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        camera.position.z = 5;

        // Post-processing setup
        const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        const bloomComposer = setupBloom();

        function setupBloom() {
            // Simple bloom effect using additive blending
            const bloomScene = new THREE.Scene();
            const bloomCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            return { scene: bloomScene, camera: bloomCamera };
        }

        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPositions = new Float32Array(starCount * 3);
        const starSpeeds = new Float32Array(starCount);

        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 100;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 100 - 50;
            starSpeeds[i] = Math.random() * 0.5 + 0.1;
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.2,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Player Ship
        const playerGeometry = new THREE.ConeGeometry(0.3, 1, 4);
        const playerMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.5
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.rotation.x = Math.PI;
        player.position.z = 3;
        scene.add(player);

        // Player Wings
        const wingGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.3);
        const wingMaterial = new THREE.MeshBasicMaterial({ color: 0x0088ff });
        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-0.4, 0, 0);
        player.add(leftWing);
        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(0.4, 0, 0);
        player.add(rightWing);

        // Enemy Management (Instanced)
        const maxEnemies = 50;
        const enemyGeometry = new THREE.OctahedronGeometry(0.4, 0);
        const enemyMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.3
        });
        const enemyMesh = new THREE.InstancedMesh(enemyGeometry, enemyMaterial, maxEnemies);
        scene.add(enemyMesh);

        const enemies = [];
        const dummy = new THREE.Object3D();

        // Laser Management
        const maxLasers = 100;
        const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
        const laserMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 1
        });
        const laserMesh = new THREE.InstancedMesh(laserGeometry, laserMaterial, maxLasers);
        scene.add(laserMesh);

        const lasers = [];

        // Particle System for Hit Effects
        const maxParticles = 500;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(maxParticles * 3);
        const particleVelocities = new Float32Array(maxParticles * 3);
        const particleLifetimes = new Float32Array(maxParticles);
        const particleColors = new Float32Array(maxParticles * 3);

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        const particles = [];

        // Input Management
        const mouse = { x: 0, y: 0 };
        const touch = { active: false, x: 0, y: 0 };
        let autoShoot = true;
        let lastShootTime = 0;
        const shootCooldown = 150;

        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        document.addEventListener('touchstart', handleTouch);
        document.addEventListener('touchmove', handleTouch);
        document.addEventListener('touchend', () => {
            touch.active = false;
        });

        function handleTouch(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                touch.active = true;
                touch.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                touch.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        // Spawn Enemy
        function spawnEnemy() {
            if (enemies.length >= maxEnemies || gameState.gameOver) return;

            const enemy = {
                id: enemies.length,
                position: new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 6,
                    -20
                ),
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    0.03 + gameState.difficulty * 0.01
                ),
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.1,
                health: 1,
                active: true
            };

            enemies.push(enemy);
            updateEnemyInstance(enemy);
        }

        function updateEnemyInstance(enemy) {
            if (!enemy.active) return;
            
            dummy.position.copy(enemy.position);
            dummy.rotation.y = enemy.rotation;
            dummy.updateMatrix();
            enemyMesh.setMatrixAt(enemy.id, dummy.matrix);
            enemyMesh.instanceMatrix.needsUpdate = true;
        }

        // Shoot Laser
        function shootLaser() {
            if (lasers.length >= maxLasers || gameState.gameOver) return;

            const laser = {
                id: lasers.length,
                position: player.position.clone(),
                velocity: new THREE.Vector3(0, 0, -0.5),
                active: true
            };

            lasers.push(laser);
            updateLaserInstance(laser);
        }

        function updateLaserInstance(laser) {
            if (!laser.active) return;

            dummy.position.copy(laser.position);
            dummy.rotation.x = Math.PI / 2;
            dummy.updateMatrix();
            laserMesh.setMatrixAt(laser.id, dummy.matrix);
            laserMesh.instanceMatrix.needsUpdate = true;
        }

        // Create Hit Effect
        function createHitEffect(position, color = 0xff0000) {
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                if (particles.length >= maxParticles) break;

                const particle = {
                    position: position.clone(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    ),
                    lifetime: 1,
                    maxLifetime: 1,
                    color: new THREE.Color(color),
                    active: true
                };
                particles.push(particle);
            }
        }

        // Update Particles
        function updateParticles(deltaTime) {
            const positions = particleGeometry.attributes.position.array;
            const colors = particleGeometry.attributes.color.array;

            let activeCount = 0;

            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                if (!particle.active) continue;

                particle.lifetime -= deltaTime;
                if (particle.lifetime <= 0) {
                    particle.active = false;
                    particles.splice(i, 1);
                    continue;
                }

                particle.position.add(particle.velocity);
                particle.velocity.multiplyScalar(0.95);

                const idx = activeCount * 3;
                positions[idx] = particle.position.x;
                positions[idx + 1] = particle.position.y;
                positions[idx + 2] = particle.position.z;

                const alpha = particle.lifetime / particle.maxLifetime;
                colors[idx] = particle.color.r * alpha;
                colors[idx + 1] = particle.color.g * alpha;
                colors[idx + 2] = particle.color.b * alpha;

                activeCount++;
            }

            particleGeometry.setDrawRange(0, activeCount);
            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;
        }

        // Collision Detection
        function checkCollisions() {
            // Laser vs Enemy
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                if (!laser.active) continue;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (!enemy.active) continue;

                    const distance = laser.position.distanceTo(enemy.position);
                    if (distance < 0.6) {
                        laser.active = false;
                        enemy.health--;

                        if (enemy.health <= 0) {
                            enemy.active = false;
                            gameState.score += 10 * gameState.difficulty;
                            gameState.enemiesKilled++;
                            createHitEffect(enemy.position, 0xff6600);

                            // Check for wave completion
                            if (gameState.enemiesKilled % 10 === 0) {
                                gameState.wave++;
                                gameState.difficulty = 1 + gameState.wave * 0.2;
                            }
                        } else {
                            createHitEffect(enemy.position, 0xffff00);
                        }
                        break;
                    }
                }
            }

            // Enemy vs Player
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy.active) continue;

                const distance = player.position.distanceTo(enemy.position);
                if (distance < 0.7) {
                    enemy.active = false;
                    gameState.health -= 10;
                    createHitEffect(player.position, 0x00ffff);

                    if (gameState.health <= 0) {
                        endGame();
                    }
                }
            }
        }

        // Update Game
        let lastTime = Date.now();
        let enemySpawnTimer = 0;

        function update() {
            if (gameState.gameOver) return;

            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update player position
            const inputX = touch.active ? touch.x : mouse.x;
            const inputY = touch.active ? touch.y : mouse.y;
            
            player.position.x += (inputX * 4 - player.position.x) * 0.1;
            player.position.y += (inputY * 3 - player.position.y) * 0.1;
            
            // Clamp player position
            player.position.x = Math.max(-5, Math.min(5, player.position.x));
            player.position.y = Math.max(-3, Math.min(3, player.position.y));

            // Auto shoot
            if (autoShoot && currentTime - lastShootTime > shootCooldown) {
                shootLaser();
                lastShootTime = currentTime;
            }

            // Update starfield
            const positions = starGeometry.attributes.position.array;
            for (let i = 0; i < starCount; i++) {
                positions[i * 3 + 2] += starSpeeds[i];
                if (positions[i * 3 + 2] > 10) {
                    positions[i * 3 + 2] = -50;
                }
            }
            starGeometry.attributes.position.needsUpdate = true;

            // Spawn enemies
            enemySpawnTimer += deltaTime;
            const spawnRate = Math.max(0.3, 1 - gameState.difficulty * 0.1);
            if (enemySpawnTimer > spawnRate) {
                spawnEnemy();
                enemySpawnTimer = 0;
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy.active) {
                    enemies.splice(i, 1);
                    continue;
                }

                enemy.position.add(enemy.velocity);
                enemy.rotation += enemy.rotationSpeed;

                if (enemy.position.z > 10) {
                    enemy.active = false;
                    enemies.splice(i, 1);
                    continue;
                }

                updateEnemyInstance(enemy);
            }

            // Update lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                if (!laser.active) {
                    lasers.splice(i, 1);
                    continue;
                }

                laser.position.add(laser.velocity);

                if (laser.position.z < -25) {
                    laser.active = false;
                    lasers.splice(i, 1);
                    continue;
                }

                updateLaserInstance(laser);
            }

            // Update particles
            updateParticles(deltaTime);

            // Check collisions
            checkCollisions();

            // Update UI
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('wave').textContent = gameState.wave;
            const healthPercent = Math.max(0, (gameState.health / gameState.maxHealth) * 100);
            document.getElementById('health-fill').style.width = healthPercent + '%';
        }

        // End Game
        function endGame() {
            gameState.gameOver = true;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('game-over').style.display = 'block';
        }

        // Restart Game
        function restartGame() {
            gameState.score = 0;
            gameState.wave = 1;
            gameState.health = 100;
            gameState.gameOver = false;
            gameState.difficulty = 1;
            gameState.enemiesKilled = 0;

            enemies.length = 0;
            lasers.length = 0;
            particles.length = 0;

            player.position.set(0, 0, 3);
            document.getElementById('game-over').style.display = 'none';

            lastTime = Date.now();
            enemySpawnTimer = 0;
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            
            // Simple bloom effect
            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start Game
        animate();
    </script>
</body>
</html>