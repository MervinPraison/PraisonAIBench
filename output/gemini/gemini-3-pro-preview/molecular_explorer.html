<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Molecular Explorer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1a1a1a; color: white; }
        canvas { display: block; }
        
        /* UI Overlay Styling */
        #ui-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 280px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid #444;
            max-height: 95vh;
            overflow-y: auto;
        }

        h2 { margin-top: 0; font-size: 1.2rem; text-align: center; color: #4db8ff; }
        
        .control-group { margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; font-size: 0.85rem; margin-bottom: 5px; color: #ccc; }
        
        select, button {
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        select:hover, button:hover { background: #444; }
        
        button.primary { background: #4db8ff; color: #000; font-weight: bold; border: none; }
        button.primary:hover { background: #7bcaff; }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .radio-group { display: flex; gap: 10px; }
        .radio-item { flex: 1; display: flex; align-items: center; font-size: 0.8rem; }
        .radio-item input { margin-right: 5px; }

        #legend {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }

        /* Loading Indicator */
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            pointer-events: none;
            display: none;
        }
    </style>

    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">Loading...</div>

    <div id="ui-container">
        <h2>Molecular Explorer</h2>
        
        <div class="control-group">
            <label for="molecule-select">Select Molecule</label>
            <select id="molecule-select">
                <option value="water">Water (H2O)</option>
                <option value="caffeine" selected>Caffeine</option>
                <option value="ethanol">Ethanol</option>
                <option value="glucose">Glucose</option>
                <option value="dna">DNA Segment (Procedural)</option>
                <option value="random">Random Structure</option>
            </select>
        </div>

        <div class="control-group">
            <label>Render Mode</label>
            <div class="radio-group">
                <div class="radio-item">
                    <input type="radio" id="mode-bs" name="mode" value="ballstick" checked>
                    <label for="mode-bs">Ball & Stick</label>
                </div>
                <div class="radio-item">
                    <input type="radio" id="mode-sf" name="mode" value="spacefill">
                    <label for="mode-sf">Space Filling</label>
                </div>
            </div>
        </div>

        <div class="control-group">
            <label for="explode-slider">Explode View</label>
            <input type="range" id="explode-slider" min="0" max="2" step="0.01" value="0">
        </div>

        <div class="control-group">
            <label for="clip-slider">Section Clipping (X-Axis)</label>
            <input type="range" id="clip-slider" min="-10" max="10" step="0.1" value="10">
            <div style="font-size: 0.7rem; color: #888; margin-top:2px;">Drag left to slice molecule</div>
        </div>

        <div class="control-group">
            <button id="snapshot-btn" class="primary">ðŸ“¸ Take Snapshot</button>
        </div>

        <div class="control-group">
            <label>Element Legend</label>
            <div id="legend"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration & Data ---

        // CPK Coloring Standard (Approximate)
        const ATOM_defs = {
            'H': { color: 0xFFFFFF, radius: 0.3, name: 'Hydrogen' },
            'C': { color: 0x333333, radius: 0.7, name: 'Carbon' },
            'N': { color: 0x3050F8, radius: 0.7, name: 'Nitrogen' },
            'O': { color: 0xFF0D0D, radius: 0.6, name: 'Oxygen' },
            'P': { color: 0xFF8000, radius: 0.9, name: 'Phosphorus' },
            'S': { color: 0xFFFF30, radius: 0.9, name: 'Sulfur' },
            'X': { color: 0xFF00FF, radius: 0.5, name: 'Unknown' } // Default
        };

        // Sample Data (xyz coordinates in Angstroms approx)
        const MOLECULES = {
            'water': [
                { elem: 'O', x: 0, y: 0, z: 0 },
                { elem: 'H', x: 0.96, y: 0, z: 0 },
                { elem: 'H', x: -0.24, y: 0.93, z: 0 }
            ],
            'ethanol': [
                { elem: 'C', x: -1.2, y: -0.4, z: 0 },
                { elem: 'C', x: 0, y: 0.5, z: 0 },
                { elem: 'O', x: 1.2, y: -0.2, z: 0 },
                { elem: 'H', x: -1.2, y: -1.1, z: 0.9 }, // approx positions
                { elem: 'H', x: -1.2, y: -1.1, z: -0.9 },
                { elem: 'H', x: -2.1, y: 0.2, z: 0 },
                { elem: 'H', x: 0, y: 1.2, z: 0.9 },
                { elem: 'H', x: 0, y: 1.2, z: -0.9 },
                { elem: 'H', x: 1.2, y: -1.1, z: 0 }
            ],
            'caffeine': [
                // Approximate topology for Caffeine (C8H10N4O2)
                { elem: 'N', x: -1.2, y: 1.8, z: 0 }, // N1
                { elem: 'C', x: 0, y: 2.5, z: 0 },    // C2
                { elem: 'N', x: 1.2, y: 1.8, z: 0 },  // N3
                { elem: 'C', x: 1.1, y: 0.4, z: 0 },  // C4
                { elem: 'C', x: -1.1, y: 0.4, z: 0 }, // C5
                { elem: 'C', x: -2.4, y: 2.4, z: 0 }, // Methyl on N1
                { elem: 'O', x: 0, y: 3.7, z: 0 },    // O on C2
                { elem: 'C', x: 2.5, y: 2.4, z: 0 },  // Methyl on N3
                { elem: 'N', x: -0.7, y: -0.8, z: 0 },// N9
                { elem: 'C', x: 0.6, y: -0.8, z: 0 }, // C8
                { elem: 'N', x: 1.6, y: -1.8, z: 0 }, // N7
                { elem: 'O', x: 0.9, y: -3.0, z: 0 }, // O
                // Add some H implicitly or explicitly? Let's add explicit C methyls to make it look fuller
                { elem: 'C', x: -1.4, y: -2.0, z: 0 }, // Methyl on N9
            ],
            'glucose': [
                // Simplified Ring Structure
                { elem: 'C', x: 1, y: 0, z: 0 },
                { elem: 'C', x: 0.5, y: 0.86, z: 0 },
                { elem: 'C', x: -0.5, y: 0.86, z: 0 },
                { elem: 'O', x: -1, y: 0, z: 0 }, // Ether oxygen
                { elem: 'C', x: -0.5, y: -0.86, z: 0 },
                { elem: 'C', x: 0.5, y: -0.86, z: 0 },
                // Hydroxyls and Hydrogens (approx)
                { elem: 'O', x: 2, y: 0, z: 0 },
                { elem: 'O', x: 1, y: 2, z: 0 },
                { elem: 'O', x: -1, y: 2, z: 0 },
                { elem: 'C', x: -1.5, y: -1.5, z: 0 }, // CH2OH tail
                { elem: 'O', x: -2.5, y: -1.5, z: 0 },
                { elem: 'O', x: 1, y: -2, z: 0 },
            ]
        };

        // --- State Management ---
        const state = {
            molecule: 'caffeine',
            mode: 'ballstick', // 'ballstick' or 'spacefill'
            explode: 0,
            clipConstant: 10,
            atoms: [], // Array of {mesh, data, originalPos}
            bonds: []  // Array of {mesh, from, to, originalPos, originalRot, len}
        };

        // --- Three.js Init ---
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: true, 
            alpha: true,
            preserveDrawingBuffer: true // Required for snapshot
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.localClippingEnabled = true; // Enable clipping

        const scene = new THREE.Scene();
        
        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 15);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 10, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        camera.add(pointLight); // Light attached to camera
        scene.add(camera);

        // Clipping Plane
        const clippingPlane = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 10);

        // Groups
        const molecularGroup = new THREE.Group();
        scene.add(molecularGroup);

        // --- Logic Functions ---

        function getAtomDef(elem) {
            return ATOM_defs[elem] || ATOM_defs['X'];
        }

        // Procedural DNA Generator (Simplified Double Helix)
        function generateDNA(basePairs = 10) {
            const atoms = [];
            const rise = 1.0; // Distance between base pairs
            const radius = 4.0;
            const twist = 0.6; // Radians per step

            for (let i = 0; i < basePairs; i++) {
                const angle = i * twist;
                const y = i * rise - (basePairs * rise / 2);

                // Strand A (Phosphate backbone approx)
                const ax = Math.cos(angle) * radius;
                const az = Math.sin(angle) * radius;
                atoms.push({ elem: 'P', x: ax, y: y, z: az });
                atoms.push({ elem: 'O', x: ax, y: y + 0.3, z: az });

                // Strand B (Opposite)
                const bx = Math.cos(angle + Math.PI) * radius;
                const bz = Math.sin(angle + Math.PI) * radius;
                atoms.push({ elem: 'P', x: bx, y: y, z: bz });
                atoms.push({ elem: 'O', x: bx, y: y + 0.3, z: bz });

                // Base Pair Connection (Simplified as C-N-N-C bridge)
                // Interpolate between strand A and B
                for(let j=1; j<=4; j++) {
                    const t = j / 5;
                    const lerpX = ax + (bx - ax) * t;
                    const lerpZ = az + (bz - az) * t;
                    // Randomize types for visual variety
                    const type = (j === 1 || j === 4) ? 'N' : 'C';
                    atoms.push({ elem: type, x: lerpX, y: y, z: lerpZ });
                }
            }
            return atoms;
        }

        function generateRandomMolecule(count = 20) {
            const atoms = [];
            const elements = ['C', 'C', 'C', 'O', 'O', 'N', 'H', 'H', 'H'];
            for(let i=0; i<count; i++) {
                atoms.push({
                    elem: elements[Math.floor(Math.random() * elements.length)],
                    x: (Math.random() - 0.5) * 8,
                    y: (Math.random() - 0.5) * 8,
                    z: (Math.random() - 0.5) * 8
                });
            }
            return atoms;
        }

        // Core function to build the 3D scene
        function buildScene() {
            // 1. Cleanup
            while(molecularGroup.children.length > 0){ 
                const obj = molecularGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
                molecularGroup.remove(obj); 
            }
            state.atoms = [];
            state.bonds = [];

            // 2. Get Data
            let atomData = [];
            if (state.molecule === 'dna') atomData = generateDNA(15);
            else if (state.molecule === 'random') atomData = generateRandomMolecule(30);
            else atomData = MOLECULES[state.molecule];

            // Center the molecule data
            const center = new THREE.Vector3();
            atomData.forEach(a => center.add(new THREE.Vector3(a.x, a.y, a.z)));
            center.divideScalar(atomData.length);
            atomData = atomData.map(a => ({...a, x: a.x - center.x, y: a.y - center.y, z: a.z - center.z}));

            // 3. Create Atoms
            const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
            
            atomData.forEach((data, idx) => {
                const def = getAtomDef(data.elem);
                
                // Scale based on mode
                // BallStick: 0.4 * relative radius
                // SpaceFill: 1.2 * relative radius (van der waals approx)
                const scaleMult = state.mode === 'ballstick' ? 0.4 : 1.2;
                const r = def.radius * scaleMult;

                const mat = new THREE.MeshStandardMaterial({
                    color: def.color,
                    roughness: 0.3,
                    metalness: 0.1,
                    clippingPlanes: [ clippingPlane ],
                    clipShadows: true
                });

                const mesh = new THREE.Mesh(sphereGeo, mat);
                mesh.position.set(data.x, data.y, data.z);
                mesh.scale.set(r, r, r);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { isAtom: true, idx: idx };

                molecularGroup.add(mesh);
                
                state.atoms.push({
                    mesh: mesh,
                    data: data,
                    def: def,
                    originalPos: new THREE.Vector3(data.x, data.y, data.z)
                });
            });

            // 4. Infer Bonds (Only for Ball & Stick)
            if (state.mode === 'ballstick') {
                const bondMat = new THREE.MeshStandardMaterial({ 
                    color: 0x888888, 
                    roughness: 0.5,
                    clippingPlanes: [ clippingPlane ] 
                });
                const bondGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 12);
                bondGeo.rotateX(Math.PI / 2); // Rotate to point along Z initially

                for (let i = 0; i < atomData.length; i++) {
                    for (let j = i + 1; j < atomData.length; j++) {
                        const a1 = atomData[i];
                        const a2 = atomData[j];
                        const v1 = new THREE.Vector3(a1.x, a1.y, a1.z);
                        const v2 = new THREE.Vector3(a2.x, a2.y, a2.z);
                        const dist = v1.distanceTo(v2);

                        // Simple distance heuristic
                        // Max bond length approx 1.9 Angstroms (usually 1.0 - 1.6)
                        // Be generous for DNA procedural generation gaps
                        const maxBond = 1.9; 
                        if (dist < maxBond) {
                            const bondMesh = new THREE.Mesh(bondGeo, bondMat);
                            
                            // Align bond
                            const center = v1.clone().add(v2).multiplyScalar(0.5);
                            bondMesh.position.copy(center);
                            bondMesh.lookAt(v2);
                            bondMesh.scale.set(1, 1, dist); // Scale Z to length

                            molecularGroup.add(bondMesh);
                            
                            state.bonds.push({
                                mesh: bondMesh,
                                originalPos: center.clone(),
                                originalScaleZ: dist,
                                dir: v2.clone().sub(v1).normalize()
                            });
                        }
                    }
                }
            }

            updateLegend();
        }

        // Update the UI Legend
        function updateLegend() {
            const legendEl = document.getElementById('legend');
            legendEl.innerHTML = '';
            
            // Find unique elements in current scene
            const uniqueElems = new Set(state.atoms.map(a => a.data.elem));
            
            uniqueElems.forEach(elem => {
                const def = getAtomDef(elem);
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const hexColor = '#' + new THREE.Color(def.color).getHexString();
                
                item.innerHTML = `<div class="dot" style="background:${hexColor}"></div>${def.name} (${elem})`;
                legendEl.appendChild(item);
            });
        }

        // Animation Loop for Explode Effect
        function animate() {
            requestAnimationFrame(animate);
            
            // Handle Explode Logic
            const exp = state.explode;
            
            // Move Atoms
            state.atoms.forEach(atomObj => {
                // vector from center (0,0,0)
                const dir = atomObj.originalPos.clone().normalize();
                // New position = original + (direction * explodeFactor * scale)
                const newPos = atomObj.originalPos.clone().add(dir.multiplyScalar(exp * 2));
                atomObj.mesh.position.copy(newPos);
            });

            // Handle Bonds
            state.bonds.forEach(bondObj => {
                if(state.mode === 'ballstick') {
                    // If exploding, bonds should probably break or scale. 
                    // For a simple "explode view", we usually just push everything apart.
                    // Let's move the bond center outwards.
                    const dir = bondObj.originalPos.clone().normalize();
                    const newPos = bondObj.originalPos.clone().add(dir.multiplyScalar(exp * 2));
                    bondObj.mesh.position.copy(newPos);
                    
                    // Optional: Scale bond to 0 when fully exploded to simulate breakage
                    // Or keep it to show structural relationship. Let's keep it.
                }
            });

            // Update Clipping Plane
            clippingPlane.constant = state.clipConstant;

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('molecule-select').addEventListener('change', (e) => {
            state.molecule = e.target.value;
            buildScene();
        });

        // Mode Radio Buttons
        document.querySelectorAll('input[name="mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                state.mode = e.target.value;
                buildScene();
            });
        });

        document.getElementById('explode-slider').addEventListener('input', (e) => {
            state.explode = parseFloat(e.target.value);
        });

        document.getElementById('clip-slider').addEventListener('input', (e) => {
            state.clipConstant = parseFloat(e.target.value);
        });

        document.getElementById('snapshot-btn').addEventListener('click', () => {
            try {
                const strMime = "image/png";
                const imgData = renderer.domElement.toDataURL(strMime);
                
                const link = document.createElement('a');
                link.download = `molecule_snapshot_${Date.now()}.png`;
                link.href = imgData;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                console.error("Snapshot failed", e);
                alert("Could not save image. Browser security settings might restrict canvas export for local files.");
            }
        });

        // --- Initialization ---
        buildScene();
        animate();

    </script>
</body>
</html>