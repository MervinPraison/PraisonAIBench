<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Terrain Flight Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
        }
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            text-align: right;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        .key { color: #ffff00; font-weight: bold; }
    </style>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Simplex Noise for terrain generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <div id="hud">
        Speed: <span id="speedVal">0</span> km/h<br>
        Altitude: <span id="altVal">0</span> m<br>
        Heading: <span id="headVal">0</span>Â°
    </div>

    <div id="instructions">
        <span class="key">W / S</span> - Pitch Down/Up<br>
        <span class="key">A / D</span> - Roll Left/Right<br>
        <span class="key">Q / E</span> - Yaw Left/Right<br>
        <span class="key">SHIFT</span> - Turbo Boost<br>
        <span class="key">SPACE</span> - Brake/Hover
    </div>

    <script>
        // --- CONFIGURATION ---
        const WORLD_WIDTH = 4000;
        const WORLD_DEPTH = 4000;
        const SEGMENTS = 256; // Higher = more detail, lower = better performance
        const WATER_LEVEL = -10;
        const TREE_COUNT = 6000;
        const FOG_COLOR = 0xaaccff;
        
        // Global Variables
        let scene, camera, renderer;
        let terrainMesh, waterMesh, treeMesh;
        let simplex = new SimplexNoise();
        let clock = new THREE.Clock();
        
        // Flight Physics Variables
        let plane;
        let speed = 0;
        const MAX_SPEED = 2.5;
        const BOOST_SPEED = 5.0;
        const MIN_SPEED = 0.0;
        const ACCELERATION = 0.02;
        const TURN_SPEED = 0.03;
        
        let input = {
            up: false, down: false, left: false, right: false,
            yawLeft: false, yawRight: false, boost: false, brake: false
        };

        // UI Elements
        const uiSpeed = document.getElementById('speedVal');
        const uiAlt = document.getElementById('altVal');
        const uiHead = document.getElementById('headVal');

        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(FOG_COLOR);
            scene.fog = new THREE.FogExp2(FOG_COLOR, 0.0015);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            
            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6); // Soft white light
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(500, 1000, 500);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 1000;
            dirLight.shadow.camera.bottom = -1000;
            dirLight.shadow.camera.left = -1000;
            dirLight.shadow.camera.right = 1000;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. Generate World
            createTerrain();
            createWater();
            createTrees();
            createPlane();

            // 6. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', (e) => onKey(e, true));
            document.addEventListener('keyup', (e) => onKey(e, false));
        }

        // --- TERRAIN GENERATION ---

        function getNoiseHeight(x, z) {
            // Layering noise (Octaves)
            let y = 0;
            // Base terrain (Large hills)
            y += simplex.noise2D(x * 0.001, z * 0.001) * 150;
            // Detail (Bumps)
            y += simplex.noise2D(x * 0.005, z * 0.005) * 30;
            // Fine detail (Rocks)
            y += simplex.noise2D(x * 0.02, z * 0.02) * 5;
            
            // Flatten valleys for water/rivers slightly
            if (y < WATER_LEVEL + 5) {
                y -= 5; 
            }
            return y;
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH, SEGMENTS, SEGMENTS);
            geometry.rotateX(-Math.PI / 2);

            const count = geometry.attributes.position.count;
            const colors = [];
            const positions = geometry.attributes.position;

            for (let i = 0; i < count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                const y = getNoiseHeight(x, z);
                
                positions.setY(i, y);

                // Vertex Coloring
                // Deep Water / Sand / Grass / Rock / Snow
                let color = new THREE.Color();
                
                if (y < WATER_LEVEL - 5) {
                    color.setHex(0xc2b280); // Sand (deep)
                } else if (y < WATER_LEVEL + 2) {
                    color.setHex(0xe0d1a1); // Sand beach
                } else if (y < 30) {
                    color.setHex(0x228b22); // Grass
                    // Variation
                    color.offsetHSL(0, 0, Math.random() * 0.05);
                } else if (y < 90) {
                    color.setHex(0x555555); // Rock
                } else {
                    color.setHex(0xffffff); // Snow
                }
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({ 
                vertexColors: true,
                roughness: 0.8,
                metalness: 0.1
            });

            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);
        }

        function createWater() {
            const geometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH);
            geometry.rotateX(-Math.PI / 2);
            
            const material = new THREE.MeshStandardMaterial({
                color: 0x0077be,
                transparent: true,
                opacity: 0.75,
                roughness: 0.1,
                metalness: 0.8
            });
            
            waterMesh = new THREE.Mesh(geometry, material);
            waterMesh.position.y = WATER_LEVEL;
            scene.add(waterMesh);
        }

        function createTrees() {
            // Create a simple low-poly tree geometry
            const treeGeo = new THREE.ConeGeometry(2, 8, 6);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x0d3b0d, roughness: 0.9 });
            
            // Instanced Mesh for performance
            const mesh = new THREE.InstancedMesh(treeGeo, treeMat, TREE_COUNT);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            const dummy = new THREE.Object3D();
            let placed = 0;
            let attempts = 0;

            while (placed < TREE_COUNT && attempts < TREE_COUNT * 3) {
                attempts++;
                
                const x = (Math.random() - 0.5) * WORLD_WIDTH;
                const z = (Math.random() - 0.5) * WORLD_DEPTH;
                const y = getNoiseHeight(x, z);

                // Only place trees on grass/lower rocks, not underwater or on peaks
                if (y > WATER_LEVEL + 2 && y < 70) {
                    dummy.position.set(x, y + 4, z); // y+4 because cone pivot is center
                    
                    // Random scale
                    const scale = 0.8 + Math.random() * 0.8;
                    dummy.scale.set(scale, scale, scale);
                    
                    dummy.updateMatrix();
                    mesh.setMatrixAt(placed++, dummy.matrix);
                }
            }

            scene.add(mesh);
        }

        // --- PLAYER / PLANE ---

        function createPlane() {
            plane = new THREE.Group();

            // Fuselage
            const fuselageGeo = new THREE.BoxGeometry(1, 1, 4);
            const fuselageMat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
            const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat);
            
            // Wings
            const wingGeo = new THREE.BoxGeometry(6, 0.2, 1.5);
            const wingMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const wings = new THREE.Mesh(wingGeo, wingMat);
            wings.position.set(0, 0, -0.5);

            // Tail
            const tailGeo = new THREE.BoxGeometry(2.5, 0.2, 1);
            const tail = new THREE.Mesh(tailGeo, wingMat);
            tail.position.set(0, 0.5, 1.5);

            const rudderGeo = new THREE.BoxGeometry(0.2, 1.5, 1);
            const rudder = new THREE.Mesh(rudderGeo, wingMat);
            rudder.position.set(0, 0.5, 1.5);

            // Glow Engine
            const engineGeo = new THREE.ConeGeometry(0.3, 1, 8);
            engineGeo.rotateX(Math.PI/2);
            const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.set(0, 0, 2);

            plane.add(fuselage);
            plane.add(wings);
            plane.add(tail);
            plane.add(rudder);
            plane.add(engine);

            plane.castShadow = true;

            // Initial Position
            plane.position.set(0, 150, 0);
            scene.add(plane);
        }

        // --- INPUT & PHYSICS ---

        function onKey(event, isDown) {
            switch(event.code) {
                case 'KeyW': input.down = isDown; break; // Inverted flight controls usually
                case 'KeyS': input.up = isDown; break;
                case 'KeyA': input.left = isDown; break;
                case 'KeyD': input.right = isDown; break;
                case 'KeyQ': input.yawLeft = isDown; break;
                case 'KeyE': input.yawRight = isDown; break;
                case 'ShiftLeft': input.boost = isDown; break;
                case 'Space': input.brake = isDown; break;
            }
        }

        function updatePhysics(delta) {
            if (!plane) return;

            // Speed handling
            let targetSpeed = input.brake ? MIN_SPEED : (input.boost ? BOOST_SPEED : MAX_SPEED);
            
            // Simple linear acceleration
            if (speed < targetSpeed) speed += ACCELERATION;
            if (speed > targetSpeed) speed -= ACCELERATION;

            // Move plane forward based on local Z axis
            plane.translateZ(-speed); 

            // Rotation Controls (Pitch, Yaw, Roll)
            const rotSpeed = TURN_SPEED;
            
            if (input.up) plane.rotateX(-rotSpeed);
            if (input.down) plane.rotateX(rotSpeed);
            if (input.left) plane.rotateZ(rotSpeed);
            if (input.right) plane.rotateZ(-rotSpeed);
            if (input.yawLeft) plane.rotateY(rotSpeed);
            if (input.yawRight) plane.rotateY(-rotSpeed);

            // Auto-leveling roll (optional, helps stability)
            // plane.rotation.z *= 0.98;

            // Collision Avoidance / Terrain Height Check
            const px = plane.position.x;
            const pz = plane.position.z;
            
            // Wrap around world or Clamp? Let's clamp to world bounds with turn back force
            const halfSize = WORLD_WIDTH / 2;
            if (px < -halfSize || px > halfSize || pz < -halfSize || pz > halfSize) {
                // Simple bounce back logic or just fog hides it.
                // For this demo, let's just force a turn towards center if out of bounds
                const angleToCenter = Math.atan2(-plane.position.x, -plane.position.z);
                // This is complex to do smoothly without quaternions, 
                // so we will rely on visual fog boundaries.
            }

            const terrainH = getNoiseHeight(px, pz);
            
            // Collision buffer (don't fly through ground)
            const safeHeight = Math.max(terrainH, WATER_LEVEL) + 3; // +3 is plane radius approx
            
            if (plane.position.y < safeHeight) {
                plane.position.y = safeHeight;
                // Bump effect
                plane.rotateX(-0.02);
                speed *= 0.95; // Lose speed on "impact"
            }

            // --- Camera Follow ---
            // Calculate ideal camera position (behind and slightly up)
            const relativeCameraOffset = new THREE.Vector3(0, 5, 15);
            
            // Apply the plane's rotation matrix to the offset
            const cameraOffset = relativeCameraOffset.applyMatrix4(plane.matrixWorld);
            
            // Smoothly interpolate camera position
            camera.position.lerp(cameraOffset, 0.1);
            
            // Camera looks at the plane (slightly ahead of it)
            const lookAtPos = plane.position.clone();
            lookAtPos.add(new THREE.Vector3(0, 0, -10).applyQuaternion(plane.quaternion));
            camera.lookAt(plane.position);

            // Update UI
            updateHUD();
        }

        function updateHUD() {
            // Speed in km/h approx
            uiSpeed.innerText = Math.floor(speed * 100); 
            uiAlt.innerText = Math.floor(plane.position.y);
            
            // Heading 0-360
            let deg = THREE.MathUtils.radToDeg(plane.rotation.y) % 360;
            if(deg < 0) deg += 360;
            uiHead.innerText = Math.floor(deg);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ANIMATION LOOP ---

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            updatePhysics(delta);
            
            // Animate water slightly
            if (waterMesh) {
               // waterMesh.material.opacity = 0.7 + Math.sin(clock.elapsedTime) * 0.05;
            }

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>