<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural 3D City with Day/Night Cycle</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            backdrop-filter: blur(5px);
            border: 1px solid #444;
        }
        input[type="text"] {
            padding: 5px;
            border-radius: 4px;
            border: none;
            outline: none;
            color: #333;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 5px;
        }
        button:hover { background: #0056b3; }
        #controls-info {
            margin-top: 10px;
            font-size: 0.85em;
            color: #ccc;
            line-height: 1.4;
        }
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            z-index: 10;
            border: 2px solid #fff;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
        }
        /* Loading overlay */
        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 999;
            font-size: 2em;
            transition: opacity 0.5s;
        }
    </style>
    <!-- Import maps polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Generating City...</div>

    <div id="ui-container">
        <div style="display:flex; align-items: center;">
            <label for="seedInput" style="margin-right: 10px;">Seed:</label>
            <input type="text" id="seedInput" value="cyberpunk2077" placeholder="Enter seed...">
            <button id="genBtn">Generate</button>
        </div>
        <div id="controls-info">
            <strong>Controls (Fly Mode):</strong><br>
            WASD: Move<br>
            R / F: Up / Down<br>
            Mouse: Look/Turn<br>
            Shift: Boost Speed
        </div>
        <div style="margin-top:10px; font-size: 0.8em;">
            Time: <span id="timeDisplay">12:00</span>
        </div>
    </div>

    <div id="minimap-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { FlyControls } from 'three/addons/controls/FlyControls.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- Configuration ---
        const CITY_SIZE = 40; // Grid size (40x40 blocks)
        const BLOCK_SIZE = 20;
        const ROAD_WIDTH = 8;
        const BUILDING_BASE_SCALE = 0.8; // relative to block size - road width
        
        // --- Globals ---
        let scene, camera, renderer, controls;
        let minimapCamera, minimapRenderer;
        let sun, sky, ambientLight;
        let cityMesh, roadMesh, trafficLightMesh;
        let trafficLights = []; // store data for animation
        let animationId;
        let seedValue = 1;
        let gameTime = 0; // 0 to 1 (day cycle)
        
        // --- RNG (Linear Congruential Generator) ---
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        let rand = mulberry32(1);

        // --- Texture Generation (Procedural) ---
        // Creates a window-like texture pattern on the fly
        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Concrete base
            ctx.fillStyle = '#222';
            ctx.fillRect(0,0,64,64);
            
            // Windows (Emissive map logic mainly)
            ctx.fillStyle = '#555'; // lit windows
            // Random window pattern
            for(let y=4; y<64; y+=8) {
                for(let x=4; x<64; x+=8) {
                    if(Math.random() > 0.3) {
                        ctx.fillRect(x, y, 4, 6);
                    }
                }
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createRoadTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1a1a1a'; // Asphalt
            ctx.fillRect(0,0,64,64);
            
            // Noise
            for(let i=0; i<200; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#222' : '#111';
                ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // --- Initialization ---
        function init() {
            const container = document.body;

            // 1. Scene
            scene = new THREE.Scene();
            // Fog handles distance fade
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            // 2. Camera (Free Fly)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 50, 0); 

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 4. Controls
            controls = new FlyControls(camera, renderer.domElement);
            controls.movementSpeed = 40;
            controls.domElement = renderer.domElement;
            controls.rollSpeed = Math.PI / 12;
            controls.autoForward = false;
            controls.dragToLook = true;

            // 5. Environment (Sky & Sun)
            initSky();

            // Ambient light (base level so night isn't pitch black)
            ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            // 6. Mini-map Camera
            // Orthographic camera looking straight down
            const mapSize = (CITY_SIZE * BLOCK_SIZE) / 1.5;
            minimapCamera = new THREE.OrthographicCamera(
                -mapSize, mapSize, mapSize, -mapSize, 1, 1000
            );
            minimapCamera.position.set((CITY_SIZE*BLOCK_SIZE)/2, 500, (CITY_SIZE*BLOCK_SIZE)/2);
            minimapCamera.lookAt((CITY_SIZE*BLOCK_SIZE)/2, 0, (CITY_SIZE*BLOCK_SIZE)/2);

            // 7. Generate Initial City
            generateCity();

            // 8. Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('genBtn').addEventListener('click', () => {
                const seedStr = document.getElementById('seedInput').value;
                // Convert string to number hash
                let hash = 0;
                for (let i = 0; i < seedStr.length; i++) {
                    hash = ((hash << 5) - hash) + seedStr.charCodeAt(i);
                    hash |= 0;
                }
                seedValue = Math.abs(hash) || 1;
                generateCity();
            });
            
            // Hide loader
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => document.getElementById('loading').style.display = 'none', 500);

            // Start Loop
            animate();
        }

        function initSky() {
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            sun = new THREE.DirectionalLight(0xffffff, 3.0);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 1500; // Cover visible city
            // Configure shadow camera frustum
            const d = 600;
            sun.shadow.camera.left = -d;
            sun.shadow.camera.right = d;
            sun.shadow.camera.top = d;
            sun.shadow.camera.bottom = -d;
            scene.add(sun);

            // GUI controller simulation for sky parameters
            const effectController = {
                turbidity: 10,
                rayleigh: 3,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.7,
                elevation: 2,
                azimuth: 180
            };

            const uniforms = sky.material.uniforms;
            uniforms['turbidity'].value = effectController.turbidity;
            uniforms['rayleigh'].value = effectController.rayleigh;
            uniforms['mieCoefficient'].value = effectController.mieCoefficient;
            uniforms['mieDirectionalG'].value = effectController.mieDirectionalG;
        }

        // --- City Generation Logic ---
        function generateCity() {
            // Clear existing meshes
            if(cityMesh) { scene.remove(cityMesh); cityMesh.dispose(); }
            if(roadMesh) { scene.remove(roadMesh); roadMesh.dispose(); }
            // Clear lights
            trafficLights.forEach(tl => scene.remove(tl.mesh));
            trafficLights = [];

            // Reset RNG
            rand = mulberry32(seedValue);

            const buildingMat = new THREE.MeshStandardMaterial({
                map: createBuildingTexture(),
                roughness: 0.8,
                metalness: 0.2,
                color: 0xffffff
            });
            
            const roadMat = new THREE.MeshStandardMaterial({
                map: createRoadTexture(),
                roughness: 0.9,
                color: 0x555555
            });

            // Geometries
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            // Shift origin to bottom
            boxGeo.translate(0, 0.5, 0);
            
            const planeGeo = new THREE.PlaneGeometry(1, 1);
            planeGeo.rotateX(-Math.PI / 2);

            // Data structures
            const buildingsData = [];
            const roadsData = [];

            const centerOffset = (CITY_SIZE * BLOCK_SIZE) / 2;
            
            // Center camera logic relative to city
            camera.position.set(centerOffset, 100, centerOffset + 100);
            camera.lookAt(centerOffset, 0, centerOffset);

            // Grid Logic
            for(let x=0; x<CITY_SIZE; x++) {
                for(let z=0; z<CITY_SIZE; z++) {
                    
                    const worldX = x * BLOCK_SIZE;
                    const worldZ = z * BLOCK_SIZE;

                    // Noise-like density (city center denser)
                    const distToCenter = Math.sqrt(Math.pow(x - CITY_SIZE/2, 2) + Math.pow(z - CITY_SIZE/2, 2));
                    const normalizedDist = distToCenter / (CITY_SIZE/1.5);
                    
                    // Determine if road or building
                    // Simple grid roads every N blocks? Or Perlin noise?
                    // Let's do a procedural block layout.
                    // 1. Main Avenues every 6 blocks
                    const isAvenue = (x % 6 === 0) || (z % 6 === 0);
                    
                    if (isAvenue) {
                        // Place Road
                        roadsData.push({
                            x: worldX, z: worldZ, 
                            sx: BLOCK_SIZE, sy: 1, sz: BLOCK_SIZE
                        });

                        // Traffic Light at intersections
                        if (x % 6 === 0 && z % 6 === 0) {
                            createTrafficLight(worldX, worldZ);
                        }

                    } else {
                        // Building Block
                        // Random chance for park/empty lot
                        if(rand() > 0.1) {
                            // Building height based on closeness to center + random
                            let height = (Math.max(0, 1 - normalizedDist) * 80) + (rand() * 30) + 5;
                            // Quantize height to floor levels (approx 3 units per floor)
                            height = Math.floor(height / 3) * 3;
                            
                            if(height < 5) height = 5; // Min height

                            const width = BLOCK_SIZE - 2; // Slight gap
                            
                            // Random color variation for buildings
                            const colVar = rand();
                            const color = new THREE.Color().setHSL(0.6 + (colVar * 0.1), 0.2, 0.1 + (colVar * 0.4));

                            buildingsData.push({
                                x: worldX, z: worldZ,
                                sx: width, sy: height, sz: width,
                                color: color
                            });

                            // Ground under building
                            roadsData.push({
                                x: worldX, z: worldZ,
                                sx: BLOCK_SIZE, sy: 1, sz: BLOCK_SIZE
                            });
                        } else {
                            // Empty lot / Park
                            roadsData.push({
                                x: worldX, z: worldZ,
                                sx: BLOCK_SIZE, sy: 1, sz: BLOCK_SIZE
                            });
                        }
                    }
                }
            }

            // Create InstancedMesh for Buildings
            cityMesh = new THREE.InstancedMesh(boxGeo, buildingMat, buildingsData.length);
            cityMesh.castShadow = true;
            cityMesh.receiveShadow = true;
            
            const dummy = new THREE.Object3D();
            for(let i=0; i<buildingsData.length; i++) {
                const d = buildingsData[i];
                dummy.position.set(d.x, 0, d.z);
                dummy.scale.set(d.sx, d.sy, d.sz);
                dummy.updateMatrix();
                cityMesh.setMatrixAt(i, dummy.matrix);
                cityMesh.setColorAt(i, d.color);
            }
            scene.add(cityMesh);

            // Create InstancedMesh for Roads (Ground)
            roadMesh = new THREE.InstancedMesh(planeGeo, roadMat, roadsData.length);
            roadMesh.receiveShadow = true;
            for(let i=0; i<roadsData.length; i++) {
                const d = roadsData[i];
                dummy.position.set(d.x, 0.05, d.z); // slightly above 0 to avoid z-fight
                dummy.scale.set(d.sx, 1, d.sz);
                dummy.updateMatrix();
                roadMesh.setMatrixAt(i, dummy.matrix);
            }
            scene.add(roadMesh);
        }

        function createTrafficLight(x, z) {
            // Simple pole with a box
            const poleH = 8;
            
            // We will use simple meshes for these as they are fewer
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // Pole
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, poleH);
            const poleMat = new THREE.MeshLambertMaterial({color: 0x333333});
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = poleH/2;
            group.add(pole);

            // Light Box
            const boxGeo = new THREE.BoxGeometry(1, 3, 1);
            const boxMat = new THREE.MeshLambertMaterial({color: 0x111111});
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = poleH - 1;
            group.add(box);

            // Emissive dots (Red, Yellow, Green)
            const dotGeo = new THREE.CircleGeometry(0.3, 8);
            
            const redMat = new THREE.MeshBasicMaterial({color: 0x330000});
            const yellowMat = new THREE.MeshBasicMaterial({color: 0x333300});
            const greenMat = new THREE.MeshBasicMaterial({color: 0x003300});

            const r = new THREE.Mesh(dotGeo, redMat.clone());
            r.position.set(0, 1, 0.51);
            const y = new THREE.Mesh(dotGeo, yellowMat.clone());
            y.position.set(0, 0, 0.51);
            const g = new THREE.Mesh(dotGeo, greenMat.clone());
            g.position.set(0, -1, 0.51);

            box.add(r); box.add(y); box.add(g);

            // Add another set for the other direction (rotated)
            const box2 = box.clone();
            box2.rotation.y = Math.PI / 2;
            group.add(box2);

            scene.add(group);

            // Store for animation: random start state
            trafficLights.push({
                group: group,
                meshRed: r, meshYellow: y, meshGreen: g,
                meshRed2: box2.children[0], meshYellow2: box2.children[1], meshGreen2: box2.children[2],
                state: Math.floor(rand() * 3), // 0: Green, 1: Yellow, 2: Red
                timer: 0
            });
        }

        // --- Updates ---

        function updateTraffic(dt) {
            // Cycle logic: Green(5s) -> Yellow(2s) -> Red(5s)
            trafficLights.forEach(tl => {
                tl.timer += dt;
                let rC = 0x330000, yC = 0x333300, gC = 0x003300; // Off/Dim colors
                let rC2 = 0x330000, yC2 = 0x333300, gC2 = 0x003300;

                // Direction 1 State Logic
                if (tl.state === 0) { // Green
                    gC = 0x00ff00;
                    // Opposing is Red
                    rC2 = 0xff0000;
                    if(tl.timer > 5) { tl.state = 1; tl.timer = 0; }
                } else if (tl.state === 1) { // Yellow
                    yC = 0xffff00;
                    rC2 = 0xff0000;
                    if(tl.timer > 2) { tl.state = 2; tl.timer = 0; }
                } else if (tl.state === 2) { // Red
                    rC = 0xff0000;
                    // Opposing goes Green, then Yellow
                    // We need a sub-state for opposing logic to be perfectly synced, 
                    // but for visual flair, simple inversion with offset works
                    if(tl.timer < 5) gC2 = 0x00ff00;
                    else { gC2 = 0x003300; yC2 = 0xffff00; } // End of red, opposing goes yellow

                    if(tl.timer > 7) { tl.state = 0; tl.timer = 0; }
                }

                tl.meshRed.material.color.setHex(rC);
                tl.meshYellow.material.color.setHex(yC);
                tl.meshGreen.material.color.setHex(gC);
                
                tl.meshRed2.material.color.setHex(rC2);
                tl.meshYellow2.material.color.setHex(yC2);
                tl.meshGreen2.material.color.setHex(gC2);
            });
        }

        function updateDayNight(dt) {
            // Advance time
            gameTime += dt * 0.05; // speed of day
            
            // 0 = dawn, 0.25 = noon, 0.5 = dusk, 0.75 = midnight
            const dayProgress = gameTime % 1; 

            // Calculate Sun Position
            // Elevation goes from 0 to 90 to 0 (day) then negative (night)
            // We map 0..1 to an angle
            const phi = (dayProgress * 2 * Math.PI) - (Math.PI / 2); // -90 to 270
            const theta = Math.PI / 2; // Fixed azimuth for simplicity path

            // Convert spherical to cartesian for Sun direction
            const sunPos = new THREE.Vector3();
            sunPos.setFromSphericalCoords(1, phi + Math.PI/2, theta);
            
            sun.position.copy(sunPos).multiplyScalar(1000);
            sky.material.uniforms['sunPosition'].value.copy(sun.position);

            // Adjust light intensity
            const height = Math.sin(phi); // -1 to 1
            
            let intensity = 0;
            if (height > 0) {
                intensity = Math.max(0, height) * 2.0;
                sun.color.setHSL(0.1, 0.3, 0.9); // Daylight
                scene.fog.color.setHSL(0.6, 0.2, 0.5 + height*0.5);
                scene.background = null; // Use Sky shader
            } else {
                // Night
                intensity = 0;
                sun.intensity = 0;
                scene.fog.color.setHSL(0.66, 0.4, 0.02);
                // At night, maybe dim the sky shader or rely on fog/ambient
            }
            sun.intensity = intensity;
            
            // Ambient adjustment
            ambientLight.intensity = (height > 0) ? 0.2 : 0.05;

            // UI Time
            const hours = Math.floor(dayProgress * 24);
            const mins = Math.floor((dayProgress * 24 * 60) % 60);
            document.getElementById('timeDisplay').innerText = 
                `${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Main Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            controls.update(delta);
            updateTraffic(delta);
            updateDayNight(delta);

            // Render Main Scene
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false);
            renderer.render(scene, camera);

            // Render Mini-map
            // We need to render into the bottom right corner
            const mapSize = 200;
            const margin = 20;
            
            // Calculate minimap viewport within the window
            const mapLeft = window.innerWidth - mapSize - margin;
            const mapBottom = margin; 
            
            renderer.setClearColor(0x000000); // Background for minimap
            renderer.setScissorTest(true);
            
            // setScissor and setViewport use (x, y, width, height) where y is from bottom
            renderer.setScissor(mapLeft, mapBottom, mapSize, mapSize);
            renderer.setViewport(mapLeft, mapBottom, mapSize, mapSize);
            
            // Update Minimap camera to follow player slightly but keep centered mostly on city logic?
            // Or just static full map? Let's make it static full city map for clarity.
            // (Already set in Init). 
            // But let's add a player marker?
            // Since we can't easily draw 2D on top without another canvas, 
            // we can rely on the fact the camera is in the scene.
            // But drawing a sprite for the camera is tricky in the same render pass.
            
            renderer.render(scene, minimapCamera);
        }

        init();

    </script>
</body>
</html>