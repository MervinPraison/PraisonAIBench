<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Analytics Dashboard</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            pointer-events: none; /* Let clicks pass through to canvas where no buttons exist */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 200px;
        }

        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #3a86ff;
            color: white;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover { background: #2667cc; }
        
        .btn-secondary { background: #6c757d; }
        .btn-secondary:hover { background: #5a6268; }
        
        .btn-success { background: #2a9d8f; }
        .btn-success:hover { background: #21867a; }

        .row { display: flex; gap: 5px; }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            display: none;
            z-index: 20;
            border: 1px solid rgba(255,255,255,0.2);
            white-space: pre-line;
        }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
        }
    </style>
    
    <!-- Import Maps for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <h1>3D Data Analytics</h1>
        <div class="panel">
            <div class="row">
                <button id="btn-theme" class="btn-secondary" style="flex:1">Toggle Theme</button>
                <button id="btn-export" class="btn-success" style="flex:1">Export CSV</button>
            </div>
            <hr style="width:100%; border:0; border-top:1px solid rgba(255,255,255,0.2); margin: 5px 0;">
            <label>Camera Views</label>
            <div class="row">
                <button onclick="moveCamera('iso')" style="flex:1">Iso</button>
                <button onclick="moveCamera('top')" style="flex:1">Top</button>
                <button onclick="moveCamera('side')" style="flex:1">Side</button>
            </div>
            <div class="row">
                <button onclick="regenerateData()" class="btn-secondary" style="width:100%">New Dataset</button>
            </div>
        </div>
    </div>

    <div id="tooltip"></div>
    <div id="loading">Loading 3D Engine...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- Configuration ---
        const CONFIG = {
            gridSize: 40,
            divisions: 40,
            barCount: 30,
            scatterCount: 50,
            colors: {
                dark: { bg: 0x1a1a2e, grid: 0x888888, text: '#ffffff', fog: 0x1a1a2e },
                light: { bg: 0xf0f2f5, grid: 0xcccccc, text: '#000000', fog: 0xf0f2f5 }
            }
        };

        let isDarkMode = true;
        let generatedData = [];
        
        // --- Three.js Globals ---
        let scene, camera, renderer, controls;
        let raycaster, pointer;
        let gridHelper, axisHelper;
        let mainGroup; // Holds charts
        let intersectedObject = null;

        // --- Initialization ---
        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.dark.bg);
            scene.fog = new THREE.Fog(CONFIG.colors.dark.fog, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(30, 25, 30);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(20, 40, 20);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Helpers
            gridHelper = new THREE.GridHelper(CONFIG.gridSize, CONFIG.divisions, CONFIG.colors.dark.grid, 0x2a2a40);
            scene.add(gridHelper);

            axisHelper = new THREE.AxesHelper(5);
            axisHelper.position.set(-CONFIG.gridSize/2, 0, CONFIG.gridSize/2); // Bottom Left
            scene.add(axisHelper);

            // Main Group for Data
            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // Raycaster
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onPointerMove);
            
            // Setup UI Buttons
            document.getElementById('loading').style.display = 'none';
            document.getElementById('btn-theme').addEventListener('click', toggleTheme);
            document.getElementById('btn-export').addEventListener('click', exportCSV);
            window.moveCamera = moveCamera; // Expose to HTML
            window.regenerateData = generateAndVisualize; // Expose to HTML

            // Initial Data
            generateAndVisualize();
            
            // Loop
            animate();
        }

        // --- Data Logic ---
        function generateData() {
            const data = [];
            const categories = ['Sales', 'Marketing', 'Dev', 'HR', 'Support'];
            
            // Generate Bar Data (High Value items)
            for (let i = 0; i < CONFIG.barCount; i++) {
                const x = Math.floor(Math.random() * CONFIG.gridSize) - CONFIG.gridSize/2;
                const z = Math.floor(Math.random() * CONFIG.gridSize) - CONFIG.gridSize/2;
                const val = Math.random() * 10 + 2; // Height 2 to 12
                
                data.push({
                    id: i,
                    type: 'Bar',
                    x: x,
                    y: val / 2, // Center of box
                    z: z,
                    height: val,
                    value: Math.floor(val * 100),
                    category: categories[Math.floor(Math.random() * categories.length)]
                });
            }

            // Generate Scatter Data (Points in space)
            for (let i = 0; i < CONFIG.scatterCount; i++) {
                data.push({
                    id: CONFIG.barCount + i,
                    type: 'Scatter',
                    x: (Math.random() * CONFIG.gridSize) - CONFIG.gridSize/2,
                    y: Math.random() * 15 + 1,
                    z: (Math.random() * CONFIG.gridSize) - CONFIG.gridSize/2,
                    value: Math.floor(Math.random() * 500),
                    category: 'Anomaly'
                });
            }
            
            generatedData = data;
            return data;
        }

        // --- Visualization Logic ---
        function generateAndVisualize() {
            // Clear previous
            while(mainGroup.children.length > 0){ 
                const obj = mainGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
                mainGroup.remove(obj); 
            }

            const data = generateData();

            // 1. Bars
            const barGeo = new THREE.BoxGeometry(0.8, 1, 0.8);
            data.filter(d => d.type === 'Bar').forEach(d => {
                const color = new THREE.Color().setHSL(d.height / 15, 0.8, 0.5);
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.1 });
                const mesh = new THREE.Mesh(barGeo, mat);
                
                mesh.position.set(d.x, d.height / 2, d.z);
                mesh.scale.y = d.height;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Attach data for raycasting
                mesh.userData = { ...d };
                mainGroup.add(mesh);
            });

            // 2. Scatter Points
            const sphereGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const scatterMat = new THREE.MeshStandardMaterial({ color: 0xff0066, emissive: 0x330011 });
            
            data.filter(d => d.type === 'Scatter').forEach(d => {
                const mesh = new THREE.Mesh(sphereGeo, scatterMat);
                mesh.position.set(d.x, d.y, d.z);
                mesh.castShadow = true;
                mesh.userData = { ...d };
                mainGroup.add(mesh);
            });

            // 3. Ribbon (Trend Line) - sort a subset of bars by X
            const ribbonPoints = data.filter(d => d.type === 'Bar')
                .sort((a, b) => a.x - b.x)
                .slice(0, 10) // Take 10 points
                .map(d => new THREE.Vector3(d.x, d.height + 2, d.z));

            if(ribbonPoints.length > 1) {
                const curve = new THREE.CatmullRomCurve3(ribbonPoints);
                const tubeGeo = new THREE.TubeGeometry(curve, 64, 0.2, 8, false);
                const tubeMat = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const tube = new THREE.Mesh(tubeGeo, tubeMat);
                tube.userData = { type: 'Trend Ribbon', value: 'Aggregated', category: 'Analytics' };
                mainGroup.add(tube);
            }
        }

        // --- Interaction: Tooltip ---
        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update Raycaster
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(mainGroup.children);
            const tooltip = document.getElementById('tooltip');

            if (intersects.length > 0) {
                if (intersectedObject != intersects[0].object) {
                    // Reset previous
                    if (intersectedObject && intersectedObject.material.emissive) {
                        intersectedObject.material.emissive.setHex(intersectedObject.currentHex);
                    }

                    intersectedObject = intersects[0].object;
                    
                    // Highlight
                    if(intersectedObject.material.emissive) {
                        intersectedObject.currentHex = intersectedObject.material.emissive.getHex();
                        intersectedObject.material.emissive.setHex(0x555555);
                    }

                    // Show Tooltip
                    const d = intersectedObject.userData;
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `
                        <strong>${d.category}</strong> (${d.type})<br/>
                        Value: ${d.value}<br/>
                        Pos: [${d.x?.toFixed(1)}, ${d.z?.toFixed(1)}]
                    `;
                }
                
                // Move tooltip with mouse
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';

            } else {
                if (intersectedObject) {
                    if(intersectedObject.material.emissive) {
                        intersectedObject.material.emissive.setHex(intersectedObject.currentHex);
                    }
                    intersectedObject = null;
                }
                tooltip.style.display = 'none';
            }
        }

        // --- Logic: Camera Animation ---
        function moveCamera(view) {
            const duration = 1000; // ms
            let targetPos = { x: 0, y: 0, z: 0 };
            
            switch(view) {
                case 'top': targetPos = { x: 0, y: 50, z: 0 }; break;
                case 'side': targetPos = { x: 40, y: 5, z: 0 }; break;
                case 'iso': targetPos = { x: 30, y: 25, z: 30 }; break;
            }

            new TWEEN.Tween(camera.position)
                .to(targetPos, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
            
            new TWEEN.Tween(controls.target)
                .to({ x: 0, y: 0, z: 0 }, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }

        // --- Logic: Theme Toggle ---
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            const theme = isDarkMode ? CONFIG.colors.dark : CONFIG.colors.light;
            const uiPanel = document.querySelector('.panel');
            const heading = document.querySelector('h1');

            scene.background.setHex(theme.bg);
            scene.fog.color.setHex(theme.fog);
            
            // Grid color update
            scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(CONFIG.gridSize, CONFIG.divisions, theme.grid, theme.grid);
            scene.add(gridHelper);

            // UI Colors
            if(!isDarkMode) {
                uiPanel.style.background = "rgba(255, 255, 255, 0.8)";
                uiPanel.style.color = "#000";
                heading.style.color = "#000";
                heading.style.textShadow = "none";
            } else {
                uiPanel.style.background = "rgba(0, 0, 0, 0.6)";
                uiPanel.style.color = "#fff";
                heading.style.color = "#fff";
                heading.style.textShadow = "0 2px 4px rgba(0,0,0,0.5)";
            }
        }

        // --- Logic: CSV Export ---
        function exportCSV() {
            if(!generatedData.length) return;

            const headers = ['Type', 'Category', 'Value', 'X', 'Y', 'Z'];
            const rows = generatedData.map(d => 
                `${d.type},${d.category},${d.value},${d.x.toFixed(2)},${d.y?.toFixed(2) || 0},${d.z.toFixed(2)}`
            );

            const csvContent = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', '3d_analytics_data.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();
            renderer.render(scene, camera);
        }

        // Run
        init();

    </script>
</body>
</html>