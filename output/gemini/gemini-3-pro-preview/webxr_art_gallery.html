<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Spatial Audio Gallery</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center; color: white;
            pointer-events: none; z-index: 100; text-shadow: 1px 1px 2px black;
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white; display: flex;
            flex-direction: column; align-items: center; justify-content: center; z-index: 200;
        }
        button { padding: 12px 24px; font-size: 18px; cursor: pointer; background: #444; color: #fff; border: 1px solid #fff; border-radius: 4px; }
        button:hover { background: #666; }
    </style>
    
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="info">
        <h2>VR Art Gallery</h2>
        <p>VR: Point at floor to Teleport, Point at Art to View Info.<br>
           Desktop: Click to start, WASD to Move, Mouse to Look.</p>
    </div>

    <div id="start-screen">
        <h1>Enter Gallery</h1>
        <p>Click below to initialize Audio and Graphics</p>
        <button id="start-btn">Start Experience</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Global Variables ---
        let camera, scene, renderer;
        let container;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        
        // Navigation (VR)
        let raycaster;
        const intersected = [];
        const tempMatrix = new THREE.Matrix4();
        let marker;
        let dolly; // Camera container for VR movement

        // Navigation (Desktop)
        let controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        let isDesktop = true;

        // Environment & Objects
        const artworks = [];
        let infoModalGroup;
        
        // Audio
        let listener;
        
        const startBtn = document.getElementById('start-btn');
        const startScreen = document.getElementById('start-screen');

        startBtn.addEventListener('click', () => {
            startScreen.style.display = 'none';
            init();
            animate();
        });

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202020);
            scene.fog = new THREE.Fog(0x202020, 5, 30);

            // 2. Camera & Audio Listener
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            // We add an audio listener to the camera for spatial audio
            listener = new THREE.AudioListener();
            camera.add(listener);

            // 3. The Dolly (Rig for VR Movement)
            dolly = new THREE.Group();
            dolly.position.set(0, 0, 4);
            dolly.add(camera);
            scene.add(dolly);

            // 4. Environment (Baked-style room)
            createRoom();
            createLighting();

            // 5. Artworks
            createArtworks();

            // 6. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true; // Performance cost, but looks good
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 7. WebXR Interaction
            setupVR();

            // 8. Desktop Controls Fallback
            setupDesktopControls();

            // 9. UI Modal
            createInfoModal();

            // Handle Resize
            window.addEventListener('resize', onWindowResize);
        }

        // --- Procedural Content Generation ---

        function createRoom() {
            // Create a texture programmatically for the floor
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const context = canvas.getContext('2d');
            context.fillStyle = '#444';
            context.fillRect(0, 0, 512, 512);
            context.fillStyle = '#555';
            context.fillRect(0, 0, 256, 256);
            context.fillRect(256, 256, 256, 256);
            
            const floorTexture = new THREE.CanvasTexture(canvas);
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(10, 10);
            floorTexture.colorSpace = THREE.SRGBColorSpace;

            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.MeshStandardMaterial({ 
                map: floorTexture, 
                roughness: 0.8,
                metalness: 0.2
            });
            
            const floor = new THREE.Mesh(planeGeometry, planeMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.name = 'floor'; // Important for teleport
            scene.add(floor);

            // Teleport Marker
            marker = new THREE.Mesh(
                new THREE.RingGeometry(0.2, 0.3, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            marker.visible = false;
            scene.add(marker);

            // Walls
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5 });
            const wallGeo = new THREE.BoxGeometry(20, 6, 0.5);
            
            const backWall = new THREE.Mesh(wallGeo, wallMat);
            backWall.position.set(0, 3, -10);
            backWall.receiveShadow = true;
            scene.add(backWall);

            const leftWall = new THREE.Mesh(wallGeo, wallMat);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-10, 3, 0);
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(wallGeo, wallMat);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(10, 3, 0);
            rightWall.receiveShadow = true;
            scene.add(rightWall);
        }

        function createLighting() {
            // Ambient
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            // Directional (Spotlights simulation)
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(-3, 10, -5);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 10;
            dirLight.shadow.camera.bottom = -10;
            dirLight.shadow.camera.left = -10;
            dirLight.shadow.camera.right = 10;
            scene.add(dirLight);
        }

        function createArtworks() {
            const positions = [
                { x: 0, y: 2.5, z: -9.7, ry: 0, title: "Neon Dreams", desc: "Procedurally generated abstract neon." },
                { x: -9.7, y: 2.5, z: 0, ry: Math.PI/2, title: "Digital Noise", desc: "Visual representation of static data." },
                { x: 9.7, y: 2.5, z: 0, ry: -Math.PI/2, title: "Void State", desc: "The emptiness of uninitialized memory." }
            ];

            const geo = new THREE.BoxGeometry(3, 2, 0.1);

            positions.forEach((pos, i) => {
                // Generate a unique painting texture
                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Abstract Art Gen
                ctx.fillStyle = `hsl(${i * 60}, 50%, 20%)`;
                ctx.fillRect(0,0,512,512);
                for(let k=0; k<20; k++) {
                    ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},0.5)`;
                    ctx.fillRect(Math.random()*400, Math.random()*400, Math.random()*100 + 50, Math.random()*100 + 50);
                }
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;

                const mat = new THREE.MeshStandardMaterial({ map: tex });
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.position.set(pos.x, pos.y, pos.z);
                mesh.rotation.y = pos.ry;
                mesh.castShadow = true;
                mesh.userData = { isArt: true, title: pos.title, desc: pos.desc };
                
                scene.add(mesh);
                artworks.push(mesh);

                // Spatial Audio for Art
                // We use an oscillator to simulate a sound "emitted" by the art
                // Note: In a real app, load an audio buffer.
                try {
                    const sound = new THREE.PositionalAudio(listener);
                    const oscillator = listener.context.createOscillator();
                    oscillator.type = 'sine';
                    // Different pitch for each art
                    oscillator.frequency.setValueAtTime(200 + (i * 100), listener.context.currentTime); 
                    const gain = listener.context.createGain();
                    gain.gain.value = 0.05; // Quiet hum

                    oscillator.connect(gain);
                    sound.setNodeSource(oscillator); // Connect custom graph to Three.js audio
                    sound.setRefDistance(1);
                    sound.setRolloffFactor(2);
                    
                    mesh.add(sound);
                    oscillator.start(0);
                } catch(e) {
                    console.warn("Audio context not ready or supported", e);
                }
            });
        }

        function createInfoModal() {
            infoModalGroup = new THREE.Group();
            scene.add(infoModalGroup);
            infoModalGroup.visible = false;

            // Background
            const bgGeo = new THREE.PlaneGeometry(2, 1);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.8, transparent: true, side: THREE.DoubleSide });
            const bg = new THREE.Mesh(bgGeo, bgMat);
            infoModalGroup.add(bg);

            // Text Canvas
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Placeholder texture, updated on interaction
            const texture = new THREE.CanvasTexture(canvas);
            const textGeo = new THREE.PlaneGeometry(2, 1);
            const textMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const textMesh = new THREE.Mesh(textGeo, textMat);
            textMesh.position.z = 0.01; // Slightly in front
            textMesh.name = "textMesh";
            infoModalGroup.add(textMesh);

            infoModalGroup.userData.updateText = (title, desc) => {
                ctx.clearRect(0, 0, 1024, 512);
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = "bold 80px Arial";
                ctx.fillText(title, 512, 150);
                ctx.font = "40px Arial";
                // Simple wrapping logic for desc would go here, just centering for demo
                ctx.fillText(desc, 512, 300);
                ctx.fillText("(Click again to close)", 512, 400);
                texture.needsUpdate = true;
            };
        }

        // --- WebXR Setup ---

        function setupVR() {
            document.body.appendChild(VRButton.createButton(renderer));

            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('connected', function (event) {
                this.add(buildController(event.data));
                isDesktop = false; // VR Active
            });
            dolly.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('connected', function (event) {
                this.add(buildController(event.data));
            });
            dolly.add(controller2);

            // Raycaster line visual
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const line = new THREE.Line(geometry);
            line.name = 'line';
            line.scale.z = 5;

            controller1.add(line.clone());
            controller2.add(line.clone());

            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            dolly.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            dolly.add(controllerGrip2);

            raycaster = new THREE.Raycaster();
        }

        function buildController(data) {
            let geometry, material;
            switch (data.targetRayMode) {
                case 'tracked-pointer':
                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));
                    material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });
                    return new THREE.Line(geometry, material);
                case 'gaze':
                    geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, -1);
                    material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
                    return new THREE.Mesh(geometry, material);
            }
        }

        function onSelectStart(event) {
            this.userData.isSelecting = true;
        }

        function onSelectEnd(event) {
            this.userData.isSelecting = false;
            const controller = event.target;
            
            // Teleport Logic
            if (marker.visible) {
                const offsetPosition = { x: -controller.position.x + marker.position.x, y: -controller.position.y + marker.position.y, z: -controller.position.z + marker.position.z };
                
                // Move dolly to marker position
                dolly.position.set(marker.position.x, dolly.position.y, marker.position.z);
                marker.visible = false;
                return;
            }

            // Interaction Logic (Art)
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const intersects = raycaster.intersectObjects(artworks);

            if (intersects.length > 0) {
                const art = intersects[0].object;
                showInfo(art);
            } else if (infoModalGroup.visible) {
                // Close modal if clicking elsewhere (but not on floor/teleport)
                infoModalGroup.visible = false;
            }
        }

        // --- Desktop Fallback ---

        function setupDesktopControls() {
            controls = new PointerLockControls(camera, document.body);

            container.addEventListener('click', () => {
                if(isDesktop) controls.lock();
            });

            const onKeyDown = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                }
            };

            const onKeyUp = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Desktop click interaction
            document.addEventListener('mousedown', (e) => {
                if (!isDesktop || !controls.isLocked) return;
                // Simple raycaster from center of screen
                raycaster.ray.origin.copy(camera.position);
                raycaster.ray.direction.set(0, 0, -1).applyQuaternion(camera.quaternion);
                
                const intersects = raycaster.intersectObjects(artworks);
                if (intersects.length > 0) {
                    showInfo(intersects[0].object);
                } else {
                    infoModalGroup.visible = false;
                }
            });
        }

        function showInfo(artObject) {
            infoModalGroup.visible = true;
            
            // Position modal slightly towards viewer from the art
            // Calculate vector from art to camera (or dolly)
            const targetPos = isDesktop ? camera.position : dolly.position;
            
            const artPos = artObject.position.clone();
            const dirToPlayer = new THREE.Vector3().subVectors(targetPos, artPos).normalize();
            
            infoModalGroup.position.copy(artPos).add(dirToPlayer.multiplyScalar(1.5));
            infoModalGroup.lookAt(targetPos.x, infoModalGroup.position.y, targetPos.z);
            
            infoModalGroup.userData.updateText(artObject.userData.title, artObject.userData.desc);
        }

        // --- Main Loop ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            const time = performance.now();

            // VR Controller Handling
            if (renderer.xr.isPresenting) {
                handleController(controller1);
                handleController(controller2);
            } 
            // Desktop Handling
            else if (isDesktop && controls.isLocked) {
                const delta = (time - prevTime) / 1000;
                const speed = 5.0;

                const velocity = new THREE.Vector3();
                const direction = new THREE.Vector3();

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x);
                controls.moveForward(-velocity.z);
                
                // Sync dolly to camera for consistency if user switches modes (hypothetically)
                dolly.position.copy(camera.position);
                dolly.position.y = 0; 
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        function handleController(controller) {
            if (controller.userData.isSelecting) {
                // While holding trigger, visual feedback could go here
            }

            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            // Check Floor (Teleport)
            // We only teleport if we aren't pointing at art
            const artIntersects = raycaster.intersectObjects(artworks);
            
            if (artIntersects.length > 0) {
                marker.visible = false;
                // Highlight art logic could go here
            } else {
                const floor = scene.getObjectByName('floor');
                const intersects = raycaster.intersectObject(floor);

                if (intersects.length > 0) {
                    marker.visible = true;
                    marker.position.copy(intersects[0].point);
                    // Keep marker flat slightly above floor
                    marker.position.y = 0.05; 
                } else {
                    marker.visible = false;
                }
            }
        }

    </script>
</body>
</html>