<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle System - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
            z-index: 10;
        }
        canvas {
            display: block;
        }
    </style>
    <!-- Import Three.js as a module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="info">
        <h2>Magical Particle Stream</h2>
        <p>Move your mouse to control the emitter source.</p>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const PARTICLE_COUNT = 15000;
        const GRAVITY = -0.15;
        const BASE_VELOCITY = 4.0;
        const SPREAD = 1.5;
        
        // --- Global Variables ---
        let scene, camera, renderer;
        let particles, particleGeometry, particleMaterial;
        
        // We store custom physics data here (velocity, life)
        const velocities = []; 
        const lives = []; // 0 to 1 value representing particle life cycle
        
        // Mouse interaction
        const mouse = new THREE.Vector2();
        const targetPos = new THREE.Vector3(0, 0, 0);
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        // Color cycling
        let hue = 0;

        // --- Helper: Create a soft glow texture on the fly ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            
            // Draw a radial gradient
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            // Add some subtle fog for depth
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 100;
            camera.position.y = 20;
            camera.lookAt(0, 0, 0);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 4. Particle System Initialization
            particleGeometry = new THREE.BufferGeometry();
            
            const positions = [];
            const colors = [];

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Initial Positions (start at center)
                positions.push(0, -100, 0); // Start hidden

                // Initial Velocities
                const vx = (Math.random() - 0.5) * SPREAD;
                const vy = (Math.random() * BASE_VELOCITY) + 2; // Always up
                const vz = (Math.random() - 0.5) * SPREAD;
                
                velocities.push({ x: vx, y: vy, z: vz });

                // Initial Life (staggered so they don't all spawn at once)
                lives.push(Math.random());

                // Initial Colors (white/blueish)
                colorObj.setHSL(0.6, 1.0, 0.5);
                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Material
            particleMaterial = new THREE.PointsMaterial({
                size: 1.5,
                map: createParticleTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // 5. Event Listeners
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
        }

        function onDocumentMouseMove(event) {
            // Normalize mouse position (-1 to +1)
            mouse.x = (event.clientX - windowHalfX) / 20; // Scaling factor for movement range
            mouse.y = -(event.clientY - windowHalfY) / 20;
            
            // Update target position for the emitter
            targetPos.x = mouse.x * 5; // Multiplier defines how far emitter moves
            targetPos.y = mouse.y * 3;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update centers
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
        }

        function updateParticles() {
            const positions = particleGeometry.attributes.position.array;
            const colors = particleGeometry.attributes.color.array;
            
            // Cycle the base hue over time
            hue += 0.001;
            if (hue > 1) hue = 0;

            const colorHelper = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Index for the position array (x, y, z)
                const i3 = i * 3;

                // Update Physics
                velocities[i].y += GRAVITY; // Apply gravity
                
                // Apply velocity to position
                positions[i3] += velocities[i].x;
                positions[i3 + 1] += velocities[i].y;
                positions[i3 + 2] += velocities[i].z;

                // Check Floor Collision / Death
                // If particle falls below -40, respawn it at the emitter
                if (positions[i3 + 1] < -40) {
                    // Reset Position to the "Target" (Mouse position)
                    positions[i3] = targetPos.x;
                    positions[i3 + 1] = targetPos.y;
                    positions[i3 + 2] = 0; // Keep Z relatively flat for the source

                    // Reset Velocity (Explosion/Fountain effect)
                    const speed = Math.random() * 0.5 + 0.5; // variance
                    // Random cone spread
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 0.5;

                    velocities[i].x = Math.cos(angle) * radius + (Math.random() - 0.5);
                    velocities[i].y = (Math.random() * BASE_VELOCITY * 0.8) + 2; 
                    velocities[i].z = Math.sin(angle) * radius + (Math.random() - 0.5);

                    // Reset Color based on global Hue
                    // We vary the hue slightly per particle for richness
                    colorHelper.setHSL(hue + (Math.random() * 0.1), 0.8, 0.6);
                    colors[i3] = colorHelper.r;
                    colors[i3 + 1] = colorHelper.g;
                    colors[i3 + 2] = colorHelper.b;
                }
            }

            // Mark attributes as needing update for the GPU
            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            updateParticles();
            
            // Slowly rotate the whole system for cinematic effect
            particles.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        // Start the application
        init();
        animate();

    </script>
</body>
</html>