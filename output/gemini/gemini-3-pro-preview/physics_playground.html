<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Playground - Three.js & Cannon-es</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #111; color: white; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            width: 220px;
            pointer-events: auto;
            user-select: none;
            border: 1px solid #444;
        }

        h1 { font-size: 16px; margin: 0 0 10px 0; color: #4faeff; text-align: center; }
        .control-group { margin-bottom: 10px; }
        label { display: block; font-size: 12px; margin-bottom: 5px; color: #ccc; }
        
        button {
            width: 100%;
            padding: 8px;
            background: #4faeff;
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: #82caff; }
        button:active { transform: translateY(1px); }

        input[type="range"] { width: 100%; cursor: pointer; }
        
        .checkbox-container { display: flex; align-items: center; justify-content: space-between; }
        .checkbox-container input { width: auto; }

        #instructions {
            margin-top: 10px;
            font-size: 11px;
            color: #888;
            border-top: 1px solid #444;
            padding-top: 5px;
            line-height: 1.4;
        }
        .key { color: #fff; font-weight: bold; }
    </style>
    
    <!-- Import Map for modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui-container">
        <h1>Physics Playground</h1>
        
        <div class="control-group">
            <button id="btn-reset">Reset Scene</button>
        </div>

        <div class="control-group">
            <label for="slider-gravity">Gravity Y: <span id="val-gravity">-9.8</span></label>
            <input type="range" id="slider-gravity" min="-20" max="10" step="0.1" value="-9.81">
        </div>

        <div class="control-group checkbox-container">
            <label for="chk-slowmo">Slow Motion</label>
            <input type="checkbox" id="chk-slowmo">
        </div>

        <div id="instructions">
            • <span class="key">Left Click + Drag</span> to move objects.<br>
            • <span class="key">Right Click</span> to rotate camera.<br>
            • <span class="key">Scroll</span> to zoom.
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- Configuration ---
        const SETTINGS = {
            stepFrequency: 60,
            slowMoFactor: 0.2
        };

        // --- Globals ---
        let scene, camera, renderer, controls;
        let world;
        let objectsToUpdate = []; // Array of { mesh, body }
        let mouseConstraint;
        let lastCallTime;
        let isSlowMotion = false;

        // UI Elements
        const uiGravity = document.getElementById('slider-gravity');
        const uiGravityVal = document.getElementById('val-gravity');
        const uiSlowMo = document.getElementById('chk-slowmo');
        const uiReset = document.getElementById('btn-reset');

        // --- Initialization ---
        init();
        animate();

        function init() {
            // 1. Three.js Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202025);
            scene.fog = new THREE.Fog(0x202025, 20, 50);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(10, 8, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 2. Physics World Setup
            initPhysics();

            // 3. Setup Event Listeners
            window.addEventListener('resize', onWindowResize);
            setupInteraction();
            setupUI();

            // 4. Create Initial Objects
            createSceneObjects();
        }

        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            // SAPBroadphase is better for stacking than NaiveBroadphase
            world.broadphase = new CANNON.SAPBroadphase(world); 
            world.allowSleep = true;
            world.solver.iterations = 10;

            // Materials
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(
                defaultMaterial,
                defaultMaterial,
                {
                    friction: 0.5,
                    restitution: 0.3 // Bounciness
                }
            );
            world.addContactMaterial(defaultContactMaterial);
            world.defaultContactMaterial = defaultContactMaterial; // Apply to everything w/o specific material
        }

        function createSceneObjects() {
            // Floor
            createFloor();

            // Stack of Boxes
            for(let i = 0; i < 6; i++) {
                const size = 1;
                const x = -4 + (Math.random() - 0.5) * 0.1;
                const y = 0.5 + i * (size + 0.1);
                createBox(size, size, size, {x: x, y: y, z: 0}, 1, 0x4faeff);
            }

            // Some Spheres
            for(let i = 0; i < 15; i++) {
                createSphere(0.4, {
                    x: (Math.random() - 0.5) * 4,
                    y: 5 + i * 2,
                    z: (Math.random() - 0.5) * 4 + 5
                }, 1, 0xff6b6b);
            }

            // Hinge Joint (Swinging Door/Barrier)
            createHingeSystem();

            // Ragdoll
            createRagdoll({ x: 4, y: 5, z: 0 });
        }

        // --- Object Creator Helpers ---

        function createFloor() {
            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                roughness: 0.4,
                metalness: 0.2
            });
            const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            planeMesh.rotation.x = -Math.PI / 2;
            planeMesh.receiveShadow = true;
            scene.add(planeMesh);

            const planeShape = new CANNON.Plane();
            const planeBody = new CANNON.Body({
                mass: 0, // Static
                shape: planeShape
            });
            planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(planeBody);
        }

        function createBox(w, h, d, pos, mass, color) {
            // ThreeJS
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // CannonJS
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass, shape: shape });
            body.position.set(pos.x, pos.y, pos.z);
            world.addBody(body);

            objectsToUpdate.push({ mesh, body });
            return body;
        }

        function createSphere(radius, pos, mass, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.1, metalness: 0.1 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass: mass, shape: shape });
            body.position.set(pos.x, pos.y, pos.z);
            world.addBody(body);

            objectsToUpdate.push({ mesh, body });
            return body;
        }

        // --- Advanced Structures ---

        function createHingeSystem() {
            // Static Pillar
            const pillarBody = createBox(0.5, 4, 0.5, {x: 0, y: 2, z: -5}, 0, 0x888888);
            
            // Swinging Arm
            const armBody = createBox(3, 0.5, 0.2, {x: 1.75, y: 3.5, z: -5}, 1, 0xffd93d);

            // Constraint
            // Pivot on Pillar relative to pillar center
            const pivotA = new CANNON.Vec3(0, 1.5, 0); 
            // Pivot on Arm relative to arm center
            const pivotB = new CANNON.Vec3(-1.5, 0, 0);
            const axis = new CANNON.Vec3(0, 1, 0); // Rotate around Y

            const hingeConstraint = new CANNON.HingeConstraint(pillarBody, armBody, {
                pivotA: pivotA,
                axisA: axis,
                pivotB: pivotB,
                axisB: axis,
            });
            world.addConstraint(hingeConstraint);
        }

        function createRagdoll(pos) {
            const scale = 0.6; // Scale down the ragdoll
            const shouldersDistance = 0.5 * scale;
            const upperArmLength = 0.4 * scale;
            const lowerArmLength = 0.4 * scale;
            const upperLegLength = 0.5 * scale;
            const lowerLegLength = 0.5 * scale;
            const headRadius = 0.25 * scale;
            const torsoWidth = 0.5 * scale;
            const torsoHeight = 0.6 * scale;
            const hipsWidth = 0.5 * scale;
            const hipsHeight = 0.3 * scale;

            // Helper to link parts
            const link = (bodyA, bodyB, pivotA, pivotB, axisA = null, axisB = null, type = 'cone') => {
                let c;
                if(type === 'hinge') {
                    c = new CANNON.HingeConstraint(bodyA, bodyB, { pivotA, pivotB, axisA, axisB });
                } else {
                    c = new CANNON.ConeTwistConstraint(bodyA, bodyB, { pivotA, pivotB });
                    // Allow some looseness
                    c.angle = Math.PI / 4; 
                    c.twistAngle = Math.PI / 8;
                }
                world.addConstraint(c);
            };

            const color = 0x99ff99;

            // 1. Body Parts
            // Head
            const head = createSphere(headRadius, {x: pos.x, y: pos.y + (torsoHeight + hipsHeight + headRadius)*1.2, z: pos.z}, 1, color);
            // Torso
            const torso = createBox(torsoWidth, torsoHeight, torsoWidth/2, {x: pos.x, y: pos.y + hipsHeight + torsoHeight/2, z: pos.z}, 2, color);
            // Hips
            const hips = createBox(hipsWidth, hipsHeight, hipsWidth/2, {x: pos.x, y: pos.y + hipsHeight/2, z: pos.z}, 2, color);

            // Arms
            const leftUpperArm = createBox(0.15*scale, upperArmLength, 0.15*scale, {x: pos.x - shouldersDistance, y: pos.y + hipsHeight + torsoHeight - 0.1, z: pos.z}, 1, color);
            const leftLowerArm = createBox(0.12*scale, lowerArmLength, 0.12*scale, {x: pos.x - shouldersDistance, y: pos.y + hipsHeight + torsoHeight - upperArmLength - 0.1, z: pos.z}, 0.5, color);
            
            const rightUpperArm = createBox(0.15*scale, upperArmLength, 0.15*scale, {x: pos.x + shouldersDistance, y: pos.y + hipsHeight + torsoHeight - 0.1, z: pos.z}, 1, color);
            const rightLowerArm = createBox(0.12*scale, lowerArmLength, 0.12*scale, {x: pos.x + shouldersDistance, y: pos.y + hipsHeight + torsoHeight - upperArmLength - 0.1, z: pos.z}, 0.5, color);

            // Legs
            const leftUpperLeg = createBox(0.18*scale, upperLegLength, 0.18*scale, {x: pos.x - 0.15, y: pos.y + hipsHeight/2 - 0.1, z: pos.z}, 1, color);
            const leftLowerLeg = createBox(0.15*scale, lowerLegLength, 0.15*scale, {x: pos.x - 0.15, y: pos.y + hipsHeight/2 - upperLegLength - 0.1, z: pos.z}, 0.5, color);

            const rightUpperLeg = createBox(0.18*scale, upperLegLength, 0.18*scale, {x: pos.x + 0.15, y: pos.y + hipsHeight/2 - 0.1, z: pos.z}, 1, color);
            const rightLowerLeg = createBox(0.15*scale, lowerLegLength, 0.15*scale, {x: pos.x + 0.15, y: pos.y + hipsHeight/2 - upperLegLength - 0.1, z: pos.z}, 0.5, color);


            // 2. Joints
            // Head -> Torso
            link(head, torso, new CANNON.Vec3(0, -headRadius, 0), new CANNON.Vec3(0, torsoHeight/2, 0));
            
            // Torso -> Hips
            link(torso, hips, new CANNON.Vec3(0, -torsoHeight/2, 0), new CANNON.Vec3(0, hipsHeight/2, 0));

            // Shoulders (ConeTwist)
            link(torso, leftUpperArm, new CANNON.Vec3(-torsoWidth/2, torchHeight/2*0.8, 0), new CANNON.Vec3(0, upperArmLength/2, 0));
            link(torso, rightUpperArm, new CANNON.Vec3(torsoWidth/2, torchHeight/2*0.8, 0), new CANNON.Vec3(0, upperArmLength/2, 0));

            // Elbows (Hinge)
            link(leftUpperArm, leftLowerArm, new CANNON.Vec3(0, -upperArmLength/2, 0), new CANNON.Vec3(0, lowerArmLength/2, 0), new CANNON.Vec3(1,0,0), new CANNON.Vec3(1,0,0), 'hinge');
            link(rightUpperArm, rightLowerArm, new CANNON.Vec3(0, -upperArmLength/2, 0), new CANNON.Vec3(0, lowerArmLength/2, 0), new CANNON.Vec3(1,0,0), new CANNON.Vec3(1,0,0), 'hinge');

            // Hips to Legs (ConeTwist)
            link(hips, leftUpperLeg, new CANNON.Vec3(-hipsWidth/3, -hipsHeight/2, 0), new CANNON.Vec3(0, upperLegLength/2, 0));
            link(hips, rightUpperLeg, new CANNON.Vec3(hipsWidth/3, -hipsHeight/2, 0), new CANNON.Vec3(0, upperLegLength/2, 0));

            // Knees (Hinge)
            link(leftUpperLeg, leftLowerLeg, new CANNON.Vec3(0, -upperLegLength/2, 0), new CANNON.Vec3(0, lowerLegLength/2, 0), new CANNON.Vec3(1,0,0), new CANNON.Vec3(1,0,0), 'hinge');
            link(rightUpperLeg, rightLowerLeg, new CANNON.Vec3(0, -upperLegLength/2, 0), new CANNON.Vec3(0, lowerLegLength/2, 0), new CANNON.Vec3(1,0,0), new CANNON.Vec3(1,0,0), 'hinge');

            // Fix: typo in variable name inside should link calculation, using explicit numbers instead for stability
        }

        // --- Interaction Logic (Mouse Drag) ---
        function setupInteraction() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // A kinematic body that moves with the mouse
            const mouseBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
            mouseBody.collisionFilterGroup = 0; // Disable collision with everything
            world.addBody(mouseBody);

            let isDragging = false;

            window.addEventListener('pointerdown', (event) => {
                // Left click only
                if(event.button !== 0) return;

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // Get meshes from our objects list
                const meshes = objectsToUpdate.map(obj => obj.mesh);
                const intersects = raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    // Disable OrbitControls while dragging
                    controls.enabled = false;

                    const hitMesh = intersects[0].object;
                    const hitPoint = intersects[0].point;
                    const objectData = objectsToUpdate.find(obj => obj.mesh === hitMesh);
                    
                    if (objectData && objectData.body.mass > 0) {
                        isDragging = true;
                        const body = objectData.body;

                        // Move mouse body to hit point
                        mouseBody.position.set(hitPoint.x, hitPoint.y, hitPoint.z);

                        // Create constraint
                        // Vector from body center to hit point
                        const localPivotBody = body.pointToLocalFrame(new CANNON.Vec3(hitPoint.x, hitPoint.y, hitPoint.z));
                        const localPivotMouse = new CANNON.Vec3(0, 0, 0);

                        mouseConstraint = new CANNON.PointToPointConstraint(
                            body, 
                            localPivotBody, 
                            mouseBody, 
                            localPivotMouse
                        );
                        world.addConstraint(mouseConstraint);
                    }
                }
            });

            window.addEventListener('pointermove', (event) => {
                if (!isDragging) return;

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Project mouse onto a plane at the depth of the drag
                raycaster.setFromCamera(mouse, camera);
                
                // Standard plane math to drag parallel to camera or floor
                // Here we create a virtual plane facing the camera at the depth of the object
                const distance = mouseBody.position.distanceTo(camera.position);
                const target = new THREE.Vector3();
                raycaster.ray.at(distance, target);
                
                mouseBody.position.set(target.x, target.y, target.z);
                world.step(0); // Wake up sleepers
            });

            window.addEventListener('pointerup', () => {
                controls.enabled = true;
                isDragging = false;
                if (mouseConstraint) {
                    world.removeConstraint(mouseConstraint);
                    mouseConstraint = null;
                }
            });
        }

        function setupUI() {
            uiReset.addEventListener('click', () => {
                resetScene();
            });

            uiGravity.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                uiGravityVal.innerText = val.toFixed(1);
                world.gravity.set(0, val, 0);
                // Wake up all bodies so they react to gravity change
                world.bodies.forEach(b => b.wakeUp());
            });

            uiSlowMo.addEventListener('change', (e) => {
                isSlowMotion = e.target.checked;
            });
        }

        function resetScene() {
            // Remove all objects
            objectsToUpdate.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
                if(obj.mesh.geometry) obj.mesh.geometry.dispose();
                if(obj.mesh.material) obj.mesh.material.dispose();
            });
            objectsToUpdate = [];
            
            // Remove constraints (except mouse constraint if any, but that gets cleared on mouse up)
            while(world.constraints.length > 0) {
                world.removeConstraint(world.constraints[0]);
            }

            // Recreate
            createSceneObjects();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() / 1000; // seconds
            if (!lastCallTime) lastCallTime = time;
            const dt = time - lastCallTime;
            lastCallTime = time;

            // Physics Step
            const timeStep = 1 / SETTINGS.stepFrequency;
            
            if (isSlowMotion) {
                // Step smaller amounts of time
                world.step(timeStep * SETTINGS.slowMoFactor, dt, 10);
            } else {
                world.step(timeStep, dt, 10);
            }

            // Update Visuals
            for (const object of objectsToUpdate) {
                object.mesh.position.copy(object.body.position);
                object.mesh.quaternion.copy(object.body.quaternion);
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>