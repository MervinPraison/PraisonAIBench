<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Architectural Walkthrough</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #111; color: white; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* UI Overlays */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); border: 1px solid black;
        }

        /* Minimap */
        #minimap-container {
            position: absolute; top: 20px; right: 20px;
            width: 200px; height: 200px;
            background: rgba(0, 0, 0, 0.5); border: 2px solid #555;
            border-radius: 8px; overflow: hidden;
        }
        #minimap { width: 100%; height: 100%; }

        /* Interaction Prompt */
        #interaction-msg {
            position: absolute; top: 55%; left: 50%; transform: translate(-50%, 0);
            background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 20px;
            font-size: 14px; opacity: 0; transition: opacity 0.2s; text-align: center;
        }

        /* Instructions & Start Screen */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
            z-index: 10; pointer-events: auto;
        }
        #instructions {
            width: 500px; height: 300px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444; border-radius: 10px; padding: 40px;
            text-align: center; cursor: pointer;
        }
        h1 { margin-top: 0; font-weight: 300; color: #4da6ff; }
        .key { display: inline-block; background: #333; padding: 4px 8px; border-radius: 4px; margin: 0 2px; border-bottom: 2px solid #111; font-family: monospace;}
        
        /* Debug / Info */
        #debug-info { position: absolute; bottom: 10px; left: 10px; font-size: 12px; color: #888; }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="minimap-container">
            <canvas id="minimap" width="200" height="200"></canvas>
        </div>
        <div id="interaction-msg">Press <span class="key">E</span> to Interact</div>
        <div id="debug-info">Room Culling: Active | Light Probes: Baked</div>
    </div>

    <!-- Start Screen -->
    <div id="blocker">
        <div id="instructions">
            <h1>Architectural Walkthrough</h1>
            <p>
                Move: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span><br>
                Look: Mouse<br>
                Interact: <span class="key">E</span><br>
            </p>
            <p style="font-size: 14px; color: #aaa; margin-top: 30px;">
                Features: Procedural Generation, Collision, Room Culling, <br>Baked Lighting Simulation, Interactive Furniture.
            </p>
            <p style="margin-top: 40px; font-size: 20px; font-weight: bold;">CLICK TO START</p>
        </div>
    </div>

    <!-- Three.js Logic -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

        // --- Global Variables ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Architecture Storage
        const walls = []; // Array of meshes for collision
        const rooms = []; // { x, z, w, h, id, objects: [] }
        const interactables = []; // { mesh, type, action }
        
        // Minimap
        const mapCanvas = document.getElementById('minimap');
        const mapCtx = mapCanvas.getContext('2d');
        const mapScale = 5; 
        const houseSize = 60; // Total grid size

        // Raycaster for Interaction
        const raycaster = new THREE.Raycaster();
        const centerScreen = new THREE.Vector2(0, 0);
        let currentIntersect = null;

        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            // Fog for depth and hiding culling artifacts
            scene.fog = new THREE.Fog(0xdddddd, 0, 40);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // Output encoding for realistic light
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. Lighting (Simulating Baked/IBL)
            // Hemisphere light acts as IBL/Ambient
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); 
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            // Directional Light (Sun)
            const dirLight = new THREE.DirectionalLight(0xffdfba, 1.5);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Light Probe (Simulating Global Illumination capture)
            const lightProbe = new THREE.LightProbe();
            scene.add(lightProbe);
            // Normally we'd load SH data here, but we'll leave it default to affect PBR materials slightly

            // 5. Procedural House Generation
            generateHouse();

            // 6. Controls
            controls = new PointerLockControls(camera, document.body);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            instructions.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'flex';
                instructions.style.display = '';
            });

            scene.add(controls.getObject());

            // Keyboard Listeners
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'KeyE': interact(); break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Handle Resize
            window.addEventListener('resize', onWindowResize);
        }

        // --- Procedural Generation Logic ---

        function generateHouse() {
            // Common Materials
            const matWall = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const matFloor = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5, metalness: 0.1 });
            const matCeiling = new THREE.MeshStandardMaterial({ color: 0xeeeeee });

            // Define Layout (Abstract grid units)
            const layout = [
                { x: 0, z: 0, w: 20, d: 10, name: 'Hallway', type: 'hall' },
                { x: -15, z: -10, w: 15, d: 15, name: 'Living Room', type: 'living' },
                { x: 15, z: -10, w: 15, d: 15, name: 'Kitchen', type: 'kitchen' },
                { x: 0, z: -15, w: 10, d: 10, name: 'Bedroom', type: 'bed' },
            ];

            layout.forEach((roomData, index) => {
                // Create Room Floor
                const floorGeo = new THREE.PlaneGeometry(roomData.w, roomData.d);
                const floor = new THREE.Mesh(floorGeo, matFloor);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(roomData.x, 0, roomData.z);
                floor.receiveShadow = true;
                scene.add(floor);

                // Create Ceiling
                const ceilGeo = new THREE.PlaneGeometry(roomData.w, roomData.d);
                const ceiling = new THREE.Mesh(ceilGeo, matCeiling);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(roomData.x, 4, roomData.z); // Height 4
                scene.add(ceiling);

                // Store room info for logic
                const roomObj = {
                    id: index,
                    bounds: new THREE.Box3().setFromObject(floor),
                    center: new THREE.Vector3(roomData.x, 2, roomData.z),
                    contents: []
                };

                // Generate Walls (Simple Box Extrusions)
                createWallsForRoom(roomData, matWall);

                // Add Room Light (Simulating baked GI per room)
                const roomLight = new THREE.PointLight(0xffeedd, 10, 20);
                roomLight.position.set(roomData.x, 3.5, roomData.z);
                scene.add(roomLight);
                roomObj.contents.push(roomLight);

                // Add Furniture based on type
                if(roomData.type === 'living') addLivingRoomFurniture(roomData, roomObj);
                if(roomData.type === 'kitchen') addKitchenFurniture(roomData, roomObj);
                if(roomData.type === 'bed') addBedroomFurniture(roomData, roomObj);
                if(roomData.type === 'hall') addHallDecor(roomData, roomObj);

                rooms.push(roomObj);
            });

            // Initial Player Position
            controls.getObject().position.set(0, 1.7, 0);
        }

        function createWallsForRoom(data, material) {
            const thickness = 0.5;
            const height = 4;
            
            // 4 Walls relative to center
            const configs = [
                { pos: [0, data.d/2], dim: [data.w, thickness] }, // Front
                { pos: [0, -data.d/2], dim: [data.w, thickness] }, // Back
                { pos: [-data.w/2, 0], dim: [thickness, data.d] }, // Left
                { pos: [data.w/2, 0], dim: [thickness, data.d] }  // Right
            ];

            configs.forEach(cfg => {
                // Doorway logic: If wall is near 0 (hallway connection), make gaps
                let isDoorway = false;
                
                // Very simple logic: if the wall crosses the axis where rooms connect
                // Hallway is at 0,0. 
                const worldX = data.x + cfg.pos[0];
                const worldZ = data.z + cfg.pos[1];

                // Check for doorways based on layout coordinates (hardcoded connection logic for this proc-gen)
                if ((data.type !== 'hall' && Math.abs(worldX) < 5 && Math.abs(worldZ) < 5) ||
                    (data.type === 'hall')) {
                    // It's a connection area, create door frame instead of full wall
                    // Or simply skip wall segment to create an opening
                    // For this demo: Split wall into two parts to make a door
                    
                    // If it is a solid wall, add it
                    // Simplification: Just punch holes in specific known directions
                    
                    // If this wall segment is adjacent to the central hallway area...
                    if(Math.abs(worldX) < 10 && Math.abs(worldZ) < 10) {
                         // Make a door gap
                         createDoorWall(data.x + cfg.pos[0], data.z + cfg.pos[1], cfg.dim[0], cfg.dim[1], height, material, cfg.dim[0] > cfg.dim[1]);
                         return;
                    }
                }

                // Solid Wall
                const geo = new THREE.BoxGeometry(cfg.dim[0], height, cfg.dim[1]);
                const mesh = new THREE.Mesh(geo, material);
                mesh.position.set(data.x + cfg.pos[0], height/2, data.z + cfg.pos[1]);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                walls.push(new THREE.Box3().setFromObject(mesh));
            });
        }

        function createDoorWall(x, z, w, d, h, mat, isHorizontal) {
            // Create two smaller walls with a gap
            const doorWidth = 3;
            
            if (isHorizontal) {
                // Wall runs along X
                const segW = (w - doorWidth) / 2;
                const left = new THREE.Mesh(new THREE.BoxGeometry(segW, h, d), mat);
                left.position.set(x - doorWidth/2 - segW/2, h/2, z);
                const right = new THREE.Mesh(new THREE.BoxGeometry(segW, h, d), mat);
                right.position.set(x + doorWidth/2 + segW/2, h/2, z);
                const top = new THREE.Mesh(new THREE.BoxGeometry(doorWidth, 1, d), mat);
                top.position.set(x, h - 0.5, z);
                
                [left, right, top].forEach(m => {
                    m.castShadow = true; scene.add(m);
                    walls.push(new THREE.Box3().setFromObject(m));
                });
            } else {
                 // Wall runs along Z
                const segD = (d - doorWidth) / 2;
                const left = new THREE.Mesh(new THREE.BoxGeometry(w, h, segD), mat);
                left.position.set(x, h/2, z - doorWidth/2 - segD/2);
                const right = new THREE.Mesh(new THREE.BoxGeometry(w, h, segD), mat);
                right.position.set(x, h/2, z + doorWidth/2 + segD/2);
                const top = new THREE.Mesh(new THREE.BoxGeometry(w, 1, doorWidth), mat);
                top.position.set(x, h - 0.5, z);

                [left, right, top].forEach(m => {
                    m.castShadow = true; scene.add(m);
                    walls.push(new THREE.Box3().setFromObject(m));
                });
            }
        }

        // --- Furniture Generators ---

        function createHotspot(mesh, type, roomObj) {
            // Create a visual indicator
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
            const hotspot = new THREE.Mesh(geometry, material);
            
            // Position above object
            const box = new THREE.Box3().setFromObject(mesh);
            const center = new THREE.Vector3();
            box.getCenter(center);
            hotspot.position.set(center.x, box.max.y + 0.5, center.z);
            
            scene.add(hotspot);
            roomObj.contents.push(hotspot);

            // Add to interactive list
            interactables.push({
                mesh: hotspot,
                targetMesh: mesh,
                type: type,
                originalColor: mesh.material.color ? mesh.material.color.getHex() : 0xffffff
            });

            // Animation user data
            hotspot.userData = { timeOffset: Math.random() * 100 };
        }

        function addLivingRoomFurniture(data, roomObj) {
            // Sofa
            const sofaGeo = new THREE.BoxGeometry(4, 1, 1.5);
            const sofaMat = new THREE.MeshStandardMaterial({ color: 0x552222 });
            const sofa = new THREE.Mesh(sofaGeo, sofaMat);
            sofa.position.set(data.x, 0.5, data.z - 2);
            sofa.castShadow = true;
            scene.add(sofa);
            roomObj.contents.push(sofa);
            walls.push(new THREE.Box3().setFromObject(sofa)); // Collide with sofa
            
            createHotspot(sofa, 'color_change', roomObj);

            // Table
            const tableTop = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), new THREE.MeshStandardMaterial({color: 0x3e2723}));
            tableTop.position.set(data.x, 1, data.z + 1);
            tableTop.castShadow = true;
            scene.add(tableTop);
            roomObj.contents.push(tableTop);
            createHotspot(tableTop, 'toggle_vis', roomObj);
        }

        function addKitchenFurniture(data, roomObj) {
            // Counter
            const counterGeo = new THREE.BoxGeometry(2, 1.2, 10);
            const counter = new THREE.Mesh(counterGeo, new THREE.MeshStandardMaterial({ color: 0xffffff }));
            counter.position.set(data.x - 5, 0.6, data.z);
            counter.castShadow = true;
            scene.add(counter);
            roomObj.contents.push(counter);
            walls.push(new THREE.Box3().setFromObject(counter));
            createHotspot(counter, 'color_change', roomObj);
        }

        function addBedroomFurniture(data, roomObj) {
            const bedGeo = new THREE.BoxGeometry(3, 0.8, 4);
            const bed = new THREE.Mesh(bedGeo, new THREE.MeshStandardMaterial({ color: 0x333399 }));
            bed.position.set(data.x, 0.4, data.z);
            bed.castShadow = true;
            scene.add(bed);
            roomObj.contents.push(bed);
            walls.push(new THREE.Box3().setFromObject(bed));
            createHotspot(bed, 'color_change', roomObj);
        }

        function addHallDecor(data, roomObj) {
            // Art Pedestal
            const pedGeo = new THREE.BoxGeometry(0.8, 1.5, 0.8);
            const ped = new THREE.Mesh(pedGeo, new THREE.MeshStandardMaterial({color: 0x222222}));
            ped.position.set(data.x, 0.75, data.z);
            scene.add(ped);
            roomObj.contents.push(ped);
            walls.push(new THREE.Box3().setFromObject(ped));

            // Floating Art
            const artGeo = new THREE.IcosahedronGeometry(0.5, 0);
            const art = new THREE.Mesh(artGeo, new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 1.0, roughness: 0.2}));
            art.position.set(data.x, 2.2, data.z);
            scene.add(art);
            roomObj.contents.push(art);
            
            // Rotate art in animation loop
            art.userData = { rotate: true };
            
            createHotspot(art, 'color_change', roomObj);
        }

        // --- Interaction Logic ---

        function interact() {
            if (currentIntersect) {
                const item = interactables.find(i => i.mesh === currentIntersect.object);
                if (item) {
                    if (item.type === 'color_change') {
                        const newColor = Math.random() * 0xffffff;
                        item.targetMesh.material.color.setHex(newColor);
                    } else if (item.type === 'toggle_vis') {
                        item.targetMesh.visible = !item.targetMesh.visible;
                    }
                }
            }
        }

        // --- Main Loops ---

        function updateRoomCulling(playerPos) {
            // Determine which room the player is in
            // Simple logic: Find closest room center
            let activeRoom = null;
            let minDist = Infinity;

            rooms.forEach(r => {
                const dist = playerPos.distanceTo(r.center);
                if (dist < minDist) {
                    minDist = dist;
                    activeRoom = r;
                }
            });

            // Room-based Culling Logic:
            // Show current room and immediate neighbors (based on layout index or distance)
            // For this grid, we just use distance threshold to hide contents of far rooms
            const viewDistance = 30; 

            rooms.forEach(r => {
                const dist = playerPos.distanceTo(r.center);
                const isVisible = dist < viewDistance;
                
                // Toggle content visibility
                r.contents.forEach(obj => {
                    obj.visible = isVisible;
                });
            });
        }

        function drawMinimap(px, pz) {
            // Clear canvas
            mapCtx.fillStyle = '#222';
            mapCtx.fillRect(0, 0, 200, 200);

            // Center of map (100, 100) represents player position? 
            // Better: Draw entire map scaled to fit, draw player dot.

            const cx = 100;
            const cy = 100;
            const scale = 3; // Pixels per unit

            mapCtx.save();
            mapCtx.translate(cx, cy);
            mapCtx.scale(scale, scale);
            
            // Invert Z for canvas coordinates (Canvas Y is down, 3D Z is back/forward)
            // Translate so player is in center
            mapCtx.translate(-px, -pz);

            // Draw Rooms
            mapCtx.fillStyle = '#444';
            mapCtx.strokeStyle = '#666';
            mapCtx.lineWidth = 1;
            
            rooms.forEach(r => {
                // Room floor is roughly the bounds
                const w = r.bounds.max.x - r.bounds.min.x;
                const d = r.bounds.max.z - r.bounds.min.z;
                const x = r.bounds.min.x;
                const z = r.bounds.min.z;
                
                mapCtx.fillRect(x, z, w, d);
                mapCtx.strokeRect(x, z, w, d);
            });

            // Draw Player
            mapCtx.restore(); // Back to center center
            
            // Draw Player Arrow
            mapCtx.fillStyle = 'red';
            mapCtx.beginPath();
            mapCtx.arc(100, 100, 3, 0, Math.PI * 2);
            mapCtx.fill();

            // Direction indicator
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            mapCtx.strokeStyle = 'red';
            mapCtx.beginPath();
            mapCtx.moveTo(100, 100);
            mapCtx.lineTo(100 + dir.x * 10, 100 + dir.z * 10);
            mapCtx.stroke();
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                
                // --- Physics / Movement ---
                
                // Friction
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                // Input direction
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // consistent speed

                const speed = 40.0; // Movement speed

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                // Apply movement attempt
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Collision Detection (AABB)
                const playerPos = controls.getObject().position;
                const playerBox = new THREE.Box3();
                const radius = 0.5; // Player radius
                // Construct player box
                playerBox.min.set(playerPos.x - radius, playerPos.y - 1.5, playerPos.z - radius);
                playerBox.max.set(playerPos.x + radius, playerPos.y + 0.5, playerPos.z + radius);

                let collision = false;
                for (let wall of walls) {
                    if (playerBox.intersectsBox(wall)) {
                        collision = true;
                        break;
                    }
                }

                if (collision) {
                    // Revert movement (Simple slide prevention)
                    controls.moveRight(velocity.x * delta);
                    controls.moveForward(velocity.z * delta);
                    velocity.x = 0;
                    velocity.z = 0;
                }

                // --- Room Logic ---
                updateRoomCulling(playerPos);
                
                // --- Minimap ---
                drawMinimap(playerPos.x, playerPos.z);
            }

            // --- Hotspot Raycasting ---
            raycaster.setFromCamera(centerScreen, camera);
            const intersects = raycaster.intersectObjects(interactables.map(i => i.mesh), false);
            const msgDiv = document.getElementById('interaction-msg');

            if (intersects.length > 0) {
                if(intersects[0].distance < 4) {
                    currentIntersect = intersects[0];
                    msgDiv.style.opacity = 1;
                    msgDiv.style.top = '55%'; // subtle float
                } else {
                    currentIntersect = null;
                    msgDiv.style.opacity = 0;
                }
            } else {
                currentIntersect = null;
                msgDiv.style.opacity = 0;
            }

            // --- Animation Effects ---
            interactables.forEach(i => {
                // Pulse logic for hotspots
                const s = 1 + Math.sin(time * 0.005 + i.mesh.userData.timeOffset) * 0.1;
                i.mesh.scale.set(s, s, s);
            });

            // Rotate Art objects
            scene.traverse(obj => {
                if(obj.userData.rotate) {
                    obj.rotation.y += delta;
                    obj.rotation.x += delta * 0.5;
                }
            });

            prevTime = time;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>