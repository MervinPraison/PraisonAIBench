[
  {
    "test_name": "terrain_flight_mode",
    "prompt": "Create a complete HTML file with Three.js that generates procedural terrain using heightmaps or Perlin noise with rivers, trees (instanced meshes), and LOD. Add a simple 'drone/plane' controller to fly above terrain with pitch/roll/yaw, speed boost, and collision avoidance. The HTML file should be self-contained with Three.js loaded from CDN and include all terrain generation code inline. Save the output as 'terrain_flight.html'.",
    "response": "I'll create a complete HTML file with Three.js that generates procedural terrain with all the requested features. Here's the complete implementation:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Terrain Flight Simulator</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            background: #87CEEB;\n            font-family: Arial, sans-serif;\n        }\n        \n        canvas {\n            display: block;\n        }\n        \n        #controls {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            color: white;\n            font-size: 14px;\n            background: rgba(0, 0, 0, 0.7);\n            padding: 15px;\n            border-radius: 5px;\n            z-index: 100;\n        }\n        \n        #stats {\n            position: absolute;\n            top: 10px;\n            right: 10px;\n            color: white;\n            font-size: 14px;\n            background: rgba(0, 0, 0, 0.7);\n            padding: 15px;\n            border-radius: 5px;\n            z-index: 100;\n        }\n        \n        .control-line {\n            margin: 5px 0;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"controls\">\n        <div class=\"control-line\"><strong>Flight Controls:</strong></div>\n        <div class=\"control-line\">WASD - Move Forward/Back/Left/Right</div>\n        <div class=\"control-line\">Q/E - Yaw Left/Right</div>\n        <div class=\"control-line\">Arrow Keys - Pitch/Roll</div>\n        <div class=\"control-line\">Shift - Speed Boost</div>\n        <div class=\"control-line\">Space - Ascend, C - Descend</div>\n        <div class=\"control-line\">R - Reset Position</div>\n    </div>\n    \n    <div id=\"stats\">\n        <div class=\"control-line\">Speed: <span id=\"speed\">0</span></div>\n        <div class=\"control-line\">Altitude: <span id=\"altitude\">0</span></div>\n        <div class=\"control-line\">Position: <span id=\"position\">0, 0</span></div>\n        <div class=\"control-line\">FPS: <span id=\"fps\">0</span></div>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script>\n        // Perlin Noise Implementation\n        class PerlinNoise {\n            constructor() {\n                this.permutation = [];\n                for (let i = 0; i < 256; i++) {\n                    this.permutation[i] = Math.floor(Math.random() * 256);\n                }\n                \n                for (let i = 0; i < 256; i++) {\n                    this.permutation[256 + i] = this.permutation[i];\n                }\n            }\n            \n            fade(t) {\n                return t * t * t * (t * (t * 6 - 15) + 10);\n            }\n            \n            lerp(t, a, b) {\n                return a + t * (b - a);\n            }\n            \n            grad(hash, x, y, z = 0) {\n                const h = hash & 15;\n                const u = h < 8 ? x : y;\n                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;\n                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n            }\n            \n            noise(x, y, z = 0) {\n                const X = Math.floor(x) & 255;\n                const Y = Math.floor(y) & 255;\n                const Z = Math.floor(z) & 255;\n                \n                x -= Math.floor(x);\n                y -= Math.floor(y);\n                z -= Math.floor(z);\n                \n                const u = this.fade(x);\n                const v = this.fade(y);\n                const w = this.fade(z);\n                \n                const A = this.permutation[X] + Y;\n                const AA = this.permutation[A] + Z;\n                const AB = this.permutation[A + 1] + Z;\n                const B = this.permutation[X + 1] + Y;\n                const BA = this.permutation[B] + Z;\n                const BB = this.permutation[B + 1] + Z;\n                \n                return this.lerp(w,\n                    this.lerp(v,\n                        this.lerp(u, this.grad(this.permutation[AA], x, y, z),\n                                    this.grad(this.permutation[BA], x - 1, y, z)),\n                        this.lerp(u, this.grad(this.permutation[AB], x, y - 1, z),\n                                    this.grad(this.permutation[BB], x - 1, y - 1, z))),\n                    this.lerp(v,\n                        this.lerp(u, this.grad(this.permutation[AA + 1], x, y, z - 1),\n                                    this.grad(this.permutation[BA + 1], x - 1, y, z - 1)),\n                        this.lerp(u, this.grad(this.permutation[AB + 1], x, y - 1, z - 1),\n                                    this.grad(this.permutation[BB + 1], x - 1, y - 1, z - 1))));\n            }\n        }\n\n        // Global variables\n        let scene, camera, renderer, drone;\n        let terrain = {};\n        let trees = [];\n        let rivers = [];\n        let noise = new PerlinNoise();\n        let heightMap = {};\n        \n        // Movement variables\n        let moveForward = false, moveBackward = false;\n        let moveLeft = false, moveRight = false;\n        let moveUp = false, moveDown = false;\n        let yawLeft = false, yawRight = false;\n        let pitchUp = false, pitchDown = false;\n        let rollLeft = false, rollRight = false;\n        let boost = false;\n        \n        const velocity = new THREE.Vector3();\n        const direction = new THREE.Vector3();\n        let pitch = 0, yaw = 0, roll = 0;\n        const maxSpeed = 2;\n        const acceleration = 0.1;\n        const friction = 0.95;\n        \n        // Terrain settings\n        const TERRAIN_SIZE = 512;\n        const TERRAIN_SEGMENTS = 256;\n        const MAX_HEIGHT = 50;\n        const WATER_LEVEL = 5;\n        const TREE_COUNT = 2000;\n        const LOD_LEVELS = 3;\n        \n        // Initialize the scene\n        function init() {\n            // Scene setup\n            scene = new THREE.Scene();\n            scene.fog = new THREE.Fog(0x87CEEB, 100, 800);\n            \n            // Camera setup\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n            camera.position.set(0, 50, 0);\n            \n            // Renderer setup\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.setClearColor(0x87CEEB);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            document.body.appendChild(renderer.domElement);\n            \n            // Lighting\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);\n            scene.add(ambientLight);\n            \n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(100, 100, 50);\n            directionalLight.castShadow = true;\n            directionalLight.shadow.mapSize.width = 2048;\n            directionalLight.shadow.mapSize.height = 2048;\n            directionalLight.shadow.camera.near = 0.5;\n            directionalLight.shadow.camera.far = 500;\n            directionalLight.shadow.camera.left = -200;\n            directionalLight.shadow.camera.right = 200;\n            directionalLight.shadow.camera.top = 200;\n            directionalLight.shadow.camera.bottom = -200;\n            scene.add(directionalLight);\n            \n            // Create drone\n            createDrone();\n            \n            // Generate terrain\n            generateTerrain();\n            \n            // Generate trees\n            generateTrees();\n            \n            // Generate rivers\n            generateRivers();\n            \n            // Event listeners\n            setupEventListeners();\n            \n            // Start animation loop\n            animate();\n        }\n        \n        function createDrone() {\n            const droneGroup = new THREE.Group();\n            \n            // Main body\n            const bodyGeometry = new THREE.CylinderGeometry(0.5, 1, 2, 8);\n            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });\n            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);\n            body.rotation.z = Math.PI / 2;\n            droneGroup.add(body);\n            \n            // Wings\n            const wingGeometry = new THREE.BoxGeometry(0.2, 4, 0.1);\n            const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });\n            const wing1 = new THREE.Mesh(wingGeometry, wingMaterial);\n            wing1.position.set(0, 0, 0.5);\n            droneGroup.add(wing1);\n            \n            const wing2 = new THREE.Mesh(wingGeometry, wingMaterial);\n            wing2.position.set(0, 0, -0.5);\n            droneGroup.add(wing2);\n            \n            // Propellers\n            for (let i = 0; i < 4; i++) {\n                const propGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 3);\n                const propMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });\n                const prop = new THREE.Mesh(propGeometry, propMaterial);\n                \n                const x = i % 2 === 0 ? 1.5 : -1.5;\n                const z = i < 2 ? 0.5 : -0.5;\n                prop.position.set(x, 0, z);\n                prop.rotation.z = Math.PI / 2;\n                droneGroup.add(prop);\n            }\n            \n            drone = droneGroup;\n            drone.position.set(0, 30, 0);\n            scene.add(drone);\n        }\n        \n        function generateTerrain() {\n            // Generate height map\n            for (let x = 0; x <= TERRAIN_SEGMENTS; x++) {\n                heightMap[x] = {};\n                for (let z = 0; z <= TERRAIN_SEGMENTS; z++) {\n                    const worldX = (x / TERRAIN_SEGMENTS) * TERRAIN_SIZE - TERRAIN_SIZE / 2;\n                    const worldZ = (z / TERRAIN_SEGMENTS) * TERRAIN_SIZE - TERRAIN_SIZE / 2;\n                    \n                    let height = 0;\n                    \n                    // Multiple octaves of noise\n                    height += noise.noise(worldX * 0.01, worldZ * 0.01) * 30;\n                    height += noise.noise(worldX * 0.02, worldZ * 0.02) * 15;\n                    height += noise.noise(worldX * 0.04, worldZ * 0.04) * 7;\n                    height += noise.noise(worldX * 0.08, worldZ * 0.08) * 3;\n                    \n                    // Add some variation\n                    height = Math.max(0, height);\n                    heightMap[x][z] = height;\n                }\n            }\n            \n            // Create terrain geometry with LOD\n            for (let lod = 0; lod < LOD_LEVELS; lod++) {\n                const segments = Math.max(32, TERRAIN_SEGMENTS / Math.pow(2, lod));\n                const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, segments, segments);\n                geometry.rotateX(-Math.PI / 2);\n                \n                const vertices = geometry.attributes.position.array;\n                const colors = [];\n                \n                for (let i = 0; i < vertices.length; i += 3) {\n                    const x = vertices[i];\n                    const z = vertices[i + 2];\n                    \n                    const mapX = Math.floor(((x + TERRAIN_SIZE / 2) / TERRAIN_SIZE) * TERRAIN_SEGMENTS);\n                    const mapZ = Math.floor(((z + TERRAIN_SIZE / 2) / TERRAIN_SIZE) * TERRAIN_SEGMENTS);\n                    \n                    const height = heightMap[Math.max(0, Math.min(TERRAIN_SEGMENTS, mapX))] ?\n                                  heightMap[Math.max(0, Math.min(TERRAIN_SEGMENTS, mapX))][Math.max(0, Math.min(TERRAIN_SEGMENTS, mapZ))] || 0 : 0;\n                    \n                    vertices[i + 1] = height;\n                    \n                    // Color based on height\n                    let r, g, b;\n                    if (height < WATER_LEVEL) {\n                        r = 0.2; g = 0.5; b = 0.8; // Water\n                    } else if (height < 15) {\n                        r = 0.2 + (height / 15) * 0.3;\n                        g = 0.6 + (height / 15) * 0.2;\n                        b = 0.2;\n                    } else if (height < 30) {\n                        r = 0.4 + (height / 30) * 0.3;\n                        g = 0.5 + (height / 30) * 0.3;\n                        b = 0.2;\n                    } else {\n                        r = 0.8; g = 0.8; b = 0.9; // Snow\n                    }\n                    \n                    colors.push(r, g, b);\n                }\n                \n                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n                geometry.computeVertexNormals();\n                \n                const material = new THREE.MeshLambertMaterial({\n                    vertexColors: true,\n                    wireframe: false\n                });\n                \n                const mesh = new THREE.Mesh(geometry, material);\n                mesh.receiveShadow = true;\n                mesh.userData.lod = lod;\n                terrain[lod] = mesh;\n                scene.add(mesh);\n            }\n        }\n        \n        function generateTrees() {\n            // Tree geometry\n            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 3, 6);\n            const leavesGeometry = new THREE.SphereGeometry(1.5, 6, 6);\n            \n            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });\n            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });\n            \n            // Create instanced meshes\n            const trunkMesh = new THREE.InstancedMesh(trunkGeometry, trunkMaterial,",
    "model": "anthropic/claude-sonnet-4-20250514",
    "agent_name": "BenchAgent",
    "execution_time": 43.73532509803772,
    "status": "success",
    "timestamp": "2025-08-29 17:52:36"
  }
]