[
  {
    "test_name": "rotating_cube_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays a rotating 3D cube. The cube should have different colored faces, rotate continuously, and include proper lighting. The HTML file should be self-contained with Three.js loaded from CDN. Include camera controls for user interaction. Save the output as 'rotating_cube.html'.",
    "response": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Rotating 3D Cube - Three.js</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body { height: 100%; margin: 0; background: #0e0e12; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }\n    #app { position: fixed; inset: 0; }\n    .hud {\n      position: fixed; left: 12px; bottom: 12px; padding: 8px 10px;\n      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);\n      border-radius: 8px; font-size: 12px; line-height: 1.35;\n      -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);\n      user-select: none; pointer-events: none;\n    }\n    a { color: #8ec5ff; text-decoration: none; }\n  </style>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <div class=\"hud\">\n    Rotating Cube \u2022 Drag to orbit \u2022 Scroll to zoom \u2022 Right-click to pan\n  </div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';\n    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js';\n\n    // Basic setup\n    const container = document.getElementById('app');\n    const scene = new THREE.Scene();\n\n    // Camera\n    const camera = new THREE.PerspectiveCamera(\n      60, window.innerWidth / window.innerHeight, 0.1, 100\n    );\n    camera.position.set(3, 2, 4);\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    container.appendChild(renderer.domElement);\n\n    // Controls\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.minDistance = 1.5;\n    controls.maxDistance = 15;\n\n    // Lighting\n    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222233, 0.7);\n    scene.add(hemiLight);\n\n    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);\n    dirLight.position.set(5, 6, 4);\n    scene.add(dirLight);\n\n    // Cube with different colored faces\n    const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);\n    const materials = [\n      new THREE.MeshStandardMaterial({ color: 0xff5555, roughness: 0.5, metalness: 0.1 }), // +X\n      new THREE.MeshStandardMaterial({ color: 0x55ff55, roughness: 0.5, metalness: 0.1 }), // -X\n      new THREE.MeshStandardMaterial({ color: 0x5555ff, roughness: 0.5, metalness: 0.1 }), // +Y\n      new THREE.MeshStandardMaterial({ color: 0xffff55, roughness: 0.5, metalness: 0.1 }), // -Y\n      new THREE.MeshStandardMaterial({ color: 0xff55ff, roughness: 0.5, metalness: 0.1 }), // +Z\n      new THREE.MeshStandardMaterial({ color: 0x55ffff, roughness: 0.5, metalness: 0.1 }), // -Z\n    ];\n    const cube = new THREE.Mesh(geometry, materials);\n    scene.add(cube);\n\n    // Subtle background fog for depth perception\n    scene.fog = new THREE.Fog(0x0e0e12, 12, 26);\n\n    // Animation loop\n    function animate() {\n      // Continuous rotation\n      cube.rotation.x += 0.01;\n      cube.rotation.y += 0.016;\n\n      controls.update();\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    }\n    animate();\n\n    // Handle resize\n    window.addEventListener('resize', () => {\n      const w = window.innerWidth;\n      const h = window.innerHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    });\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 31.044238805770874,
    "status": "success",
    "timestamp": "2025-08-29 17:29:59"
  },
  {
    "test_name": "solar_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that simulates a simple solar system. Include the sun (yellow sphere) at the center, Earth (blue sphere) orbiting around it, and the moon (gray sphere) orbiting around Earth. Add realistic orbital speeds and include stars in the background. The HTML should be self-contained with Three.js from CDN. Save the output as 'solar_system.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Simple Solar System - Three.js</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }\n    #info {\n      position: absolute; top: 10px; left: 10px; color: #ddd; font: 14px/1.3 system-ui, Arial, sans-serif;\n      background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 6px; user-select: none;\n    }\n    a { color: #9cf; text-decoration: none; }\n  </style>\n</head>\n<body>\n  <div id=\"info\">\n    Simple Solar System (Three.js)<br>\n    - Sun at center, Earth and Moon with realistic relative periods<br>\n    - Drag to orbit view, scroll to zoom<br>\n    Simulation speed: 10 days per second\n  </div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';\n    import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n\n    // Scene\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x000000);\n\n    // Camera\n    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);\n    camera.position.set(60, 30, 60);\n\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.target.set(0, 0, 0);\n\n    // Constants (scaled)\n    const SUN_RADIUS = 5;\n    const EARTH_RADIUS = 1.0;              // ~1/5 of sun here (stylized)\n    const MOON_RADIUS = 0.27;              // realistic ratio to Earth\n    const EARTH_ORBIT_RADIUS = 40;         // distance from sun\n    const MOON_ORBIT_RADIUS = 3;           // distance from earth\n\n    // Time scaling (realistic relative periods, sped up)\n    const DAYS_PER_SECOND = 10;            // simulation speed\n    const EARTH_YEAR_DAYS = 365.256;       // sidereal year\n    const MOON_ORBIT_DAYS = 27.321661;     // sidereal month\n    const EARTH_DAY_DAYS = 1.0;\n\n    // Angular speeds (radians per real second)\n    const earthOrbitOmega = 2 * Math.PI * (DAYS_PER_SECOND / EARTH_YEAR_DAYS);\n    const moonOrbitOmega  = 2 * Math.PI * (DAYS_PER_SECOND / MOON_ORBIT_DAYS);\n    const earthSpinOmega  = 2 * Math.PI * (DAYS_PER_SECOND / EARTH_DAY_DAYS);\n    const sunSpinOmega    = 2 * Math.PI * (DAYS_PER_SECOND / (25)); // ~25 days (equator), stylized\n\n    // Lights\n    const sunLight = new THREE.PointLight(0xffffff, 3, 0, 2); // bright point light at sun\n    sunLight.position.set(0, 0, 0);\n    scene.add(sunLight);\n\n    const ambient = new THREE.AmbientLight(0x222222);\n    scene.add(ambient);\n\n    // Sun (emissive)\n    const sunGeo = new THREE.SphereGeometry(SUN_RADIUS, 64, 64);\n    const sunMat = new THREE.MeshStandardMaterial({\n      color: 0xffdd66,\n      emissive: 0xffcc44,\n      emissiveIntensity: 1.5,\n      roughness: 1.0,\n      metalness: 0.0\n    });\n    const sun = new THREE.Mesh(sunGeo, sunMat);\n    sun.position.set(0, 0, 0);\n    scene.add(sun);\n\n    // Earth\n    const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS, 48, 48);\n    const earthMat = new THREE.MeshStandardMaterial({\n      color: 0x2b6cff, // blue\n      roughness: 0.9,\n      metalness: 0.0\n    });\n    const earth = new THREE.Mesh(earthGeo, earthMat);\n\n    // Moon\n    const moonGeo = new THREE.SphereGeometry(MOON_RADIUS, 32, 32);\n    const moonMat = new THREE.MeshStandardMaterial({\n      color: 0xbfbfbf, // gray\n      roughness: 1.0,\n      metalness: 0.0\n    });\n    const moon = new THREE.Mesh(moonGeo, moonMat);\n\n    // Orbit pivots\n    const earthOrbit = new THREE.Object3D(); // revolves around sun\n    scene.add(earthOrbit);\n\n    earth.position.set(EARTH_ORBIT_RADIUS, 0, 0);\n    earth.rotation.z = THREE.MathUtils.degToRad(23.5); // axial tilt\n    earthOrbit.add(earth);\n\n    const moonOrbit = new THREE.Object3D(); // revolves around earth\n    moonOrbit.position.set(EARTH_ORBIT_RADIUS, 0, 0); // center at earth\n    earthOrbit.add(moonOrbit);\n\n    moon.position.set(MOON_ORBIT_RADIUS, 0, 0);\n    moonOrbit.add(moon);\n\n    // Orbit rings (visual guides)\n    function makeOrbitRing(radius, color = 0x444444) {\n      const segments = 256;\n      const pts = [];\n      for (let i = 0; i <= segments; i++) {\n        const t = (i / segments) * Math.PI * 2;\n        pts.push(new THREE.Vector3(Math.cos(t) * radius, 0, Math.sin(t) * radius));\n      }\n      const geo = new THREE.BufferGeometry().setFromPoints(pts);\n      const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.35 });\n      const ring = new THREE.Line(geo, mat);\n      return ring;\n    }\n\n    // Earth's orbital ring around the sun (world-centered)\n    const earthRing = makeOrbitRing(EARTH_ORBIT_RADIUS, 0x555577);\n    scene.add(earthRing);\n\n    // Moon's orbital ring around the earth (attached to the earth's position)\n    const moonRing = makeOrbitRing(MOON_ORBIT_RADIUS, 0x555555);\n    moonRing.rotation.x = 0; // ecliptic plane; could tilt slightly if desired\n    moonOrbit.add(moonRing);\n\n    // Starfield\n    function addStars(count = 4000, radius = 1200) {\n      const positions = new Float32Array(count * 3);\n      for (let i = 0; i < count; i++) {\n        // Random point on a sphere shell\n        const theta = Math.acos(THREE.MathUtils.randFloatSpread(2)); // 0..pi\n        const phi = Math.random() * Math.PI * 2;\n        const r = radius * (0.85 + Math.random() * 0.15); // slight variance\n        const x = r * Math.sin(theta) * Math.cos(phi);\n        const y = r * Math.cos(theta);\n        const z = r * Math.sin(theta) * Math.sin(phi);\n        positions.set([x, y, z], i * 3);\n      }\n      const starGeo = new THREE.BufferGeometry();\n      starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n      const starMat = new THREE.PointsMaterial({\n        color: 0xffffff,\n        size: 1.2,\n        sizeAttenuation: true,\n        transparent: true,\n        opacity: 0.9\n      });\n      const stars = new THREE.Points(starGeo, starMat);\n      scene.add(stars);\n    }\n    addStars();\n\n    // Animation\n    const clock = new THREE.Clock();\n\n    function animate() {\n      const dt = clock.getDelta();\n\n      // Revolutions\n      earthOrbit.rotation.y += earthOrbitOmega * dt;  // Earth around Sun\n      moonOrbit.rotation.y  += moonOrbitOmega  * dt;  // Moon around Earth\n\n      // Spins\n      earth.rotation.y += earthSpinOmega * dt;        // Earth's day\n      sun.rotation.y   += sunSpinOmega   * dt;        // Sun's rotation (stylized)\n\n      controls.update();\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    }\n\n    animate();\n\n    // Resize handling\n    window.addEventListener('resize', () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 77.31550407409668,
    "status": "success",
    "timestamp": "2025-08-29 17:31:16"
  },
  {
    "test_name": "particle_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays an animated particle system. The particles should move in interesting patterns (like a fountain, explosion, or flowing stream), change colors over time, and respond to mouse movement. Include at least 1000 particles with realistic physics. The HTML should be self-contained with Three.js from CDN. Save the output as 'particle_system.html'.",
    "response": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Three.js Particle System - Fountain + Swirl</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }\n    #overlay {\n      position: absolute; left: 12px; top: 12px; color: #cfd8dc; font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;\n      background: rgba(0,0,0,0.35); padding: 10px 12px; border-radius: 8px; backdrop-filter: blur(2px);\n      user-select: none; z-index: 10;\n    }\n    a { color: #90caf9; text-decoration: none; }\n    a:hover { text-decoration: underline; }\n  </style>\n</head>\n<body>\n  <div id=\"overlay\">\n    Three.js Particle Fountain (2000 particles)\n    <br>- Move mouse: push/pull particles near the cursor\n    <br>- Click: toggle attraction/repulsion\n    <br>- Space: burst impulse\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js\"></script>\n  <script>\n  (() => {\n    // Basic Three.js setup\n    const scene = new THREE.Scene();\n    scene.fog = new THREE.FogExp2(0x000000, 0.07);\n\n    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);\n    camera.position.set(0, 2.5, 7);\n    camera.lookAt(0, 1.3, 0);\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setClearColor(0x000000, 1);\n    document.body.appendChild(renderer.domElement);\n\n    // Soft circular sprite for points\n    function makeSprite(size = 128) {\n      const canvas = document.createElement('canvas');\n      canvas.width = canvas.height = size;\n      const ctx = canvas.getContext('2d');\n      const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);\n      g.addColorStop(0.0, 'rgba(255,255,255,1)');\n      g.addColorStop(0.2, 'rgba(255,255,255,0.9)');\n      g.addColorStop(0.5, 'rgba(255,255,255,0.3)');\n      g.addColorStop(1.0, 'rgba(255,255,255,0)');\n      ctx.fillStyle = g;\n      ctx.fillRect(0,0,size,size);\n      const tex = new THREE.CanvasTexture(canvas);\n      tex.minFilter = THREE.LinearMipMapLinearFilter;\n      tex.magFilter = THREE.LinearFilter;\n      tex.generateMipmaps = true;\n      return tex;\n    }\n\n    // Ground reference (subtle) and emitter marker\n    {\n      const grid = new THREE.GridHelper(60, 60, 0x2a2a2a, 0x1a1a1a);\n      grid.position.y = 0;\n      grid.material.opacity = 0.25;\n      grid.material.transparent = true;\n      scene.add(grid);\n\n      const emitterRing = new THREE.Mesh(\n        new THREE.TorusGeometry(0.2, 0.01, 8, 48),\n        new THREE.MeshBasicMaterial({ color: 0x2266ff })\n      );\n      emitterRing.rotation.x = Math.PI / 2;\n      emitterRing.position.set(0, 0.001, 0);\n      scene.add(emitterRing);\n    }\n\n    // Particle system parameters\n    const COUNT = 2000;\n    const emitter = new THREE.Vector3(0, 0.0, 0);\n    const gravity = new THREE.Vector3(0, -9.8, 0); // m/s^2\n    const airDrag = 0.995; // simple drag per frame\n    const floorY = 0.0;\n    const restitution = 0.45; // bounce dampening\n    const friction = 0.85; // along-surface energy loss\n    const swirlStrength = 1.2; // angular acceleration around Y\n    const mouseForceBase = 35; // strength of mouse interaction\n    const mouseRadius = 1.8; // influence radius\n    const respawnBelowY = -8;\n\n    // Buffers and attributes\n    const positions = new Float32Array(COUNT * 3);\n    const velocities = new Float32Array(COUNT * 3);\n    const colors = new Float32Array(COUNT * 3);\n    const ages = new Float32Array(COUNT);\n    const lifes = new Float32Array(COUNT);\n    const seeds = new Float32Array(COUNT); // per-particle phase/noise seed\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n    geometry.computeBoundingSphere = () => {}; // micro-optimization; boundingSphere not needed here\n\n    const material = new THREE.PointsMaterial({\n      size: 0.08,\n      map: makeSprite(128),\n      transparent: true,\n      depthWrite: false,\n      blending: THREE.AdditiveBlending,\n      vertexColors: true,\n      opacity: 0.95,\n      sizeAttenuation: true\n    });\n\n    const points = new THREE.Points(geometry, material);\n    scene.add(points);\n\n    // Utilities\n    function randRange(min, max) { return min + Math.random() * (max - min); }\n\n    function hslToRgb(h, s, l) {\n      // h,s,l in [0,1]\n      if (s === 0) {\n        const v = l; return [v, v, v];\n      }\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      const hk = h - Math.floor(h);\n      const tc = [hk + 1/3, hk, hk - 1/3].map(t => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1/6) return p + (q - p) * 6 * t;\n        if (t < 1/2) return q;\n        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n        return p;\n      });\n      return tc;\n    }\n\n    function respawn(i) {\n      // Emit upward from a small disk with a cone of velocities; slight randomness in lifespan\n      const r = Math.sqrt(Math.random()) * 0.2;\n      const ang = Math.random() * Math.PI * 2;\n      const ox = Math.cos(ang) * r;\n      const oz = Math.sin(ang) * r;\n\n      const idx = i * 3;\n      positions[idx + 0] = emitter.x + ox;\n      positions[idx + 1] = emitter.y + 0.01;\n      positions[idx + 2] = emitter.z + oz;\n\n      // Upward initial speed with slight lateral spread; make interesting by biasing with emitter offset\n      const vy = randRange(3.5, 7.0);\n      const vx = ox * randRange(2.0, 4.5) + randRange(-0.6, 0.6);\n      const vz = oz * randRange(2.0, 4.5) + randRange(-0.6, 0.6);\n\n      velocities[idx + 0] = vx;\n      velocities[idx + 1] = vy;\n      velocities[idx + 2] = vz;\n\n      ages[i] = 0;\n      lifes[i] = randRange(1.8, 3.8); // seconds\n      seeds[i] = Math.random() * 1000;\n    }\n\n    // Initialize all particles\n    for (let i = 0; i < COUNT; i++) {\n      respawn(i);\n      // initialize color\n      const c = i * 3;\n      colors[c+0] = 1; colors[c+1] = 1; colors[c+2] = 1;\n    }\n    geometry.attributes.position.needsUpdate = true;\n    geometry.attributes.color.needsUpdate = true;\n\n    // Lighting-like additive haze using a dim point light proxy (not actual light for particles)\n    {\n      const glow = new THREE.Points(\n        new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([0, 2, 0], 3)),\n        new THREE.PointsMaterial({ size: 12, color: 0x113366, transparent: true, opacity: 0.03, depthWrite: false, blending: THREE.AdditiveBlending, map: makeSprite(128) })\n      );\n      scene.add(glow);\n    }\n\n    // Mouse interaction (ray onto plane y=0)\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2(0, 0);\n    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // y=0\n    const mouseWorld = new THREE.Vector3(0, 0, 0);\n    let haveMouseWorld = false;\n    let attract = false; // false = repel, true = attract\n\n    function updateMouseWorld() {\n      raycaster.setFromCamera(mouse, camera);\n      const hit = new THREE.Vector3();\n      if (raycaster.ray.intersectPlane(plane, hit)) {\n        mouseWorld.copy(hit);\n        haveMouseWorld = true;\n      } else {\n        haveMouseWorld = false;\n      }\n    }\n\n    window.addEventListener('mousemove', (e) => {\n      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;\n      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n      updateMouseWorld();\n    }, { passive: true });\n\n    window.addEventListener('mousedown', () => { attract = !attract; });\n    window.addEventListener('touchstart', (e) => {\n      const t = e.touches[0];\n      mouse.x = (t.clientX / window.innerWidth) * 2 - 1;\n      mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;\n      updateMouseWorld();\n      attract = !attract;\n    }, { passive: true });\n\n    // Burst impulse on space\n    window.addEventListener('keydown', (e) => {\n      if (e.code === 'Space') {\n        burst(mouseWorld, haveMouseWorld ? 5 : 0);\n      }\n    });\n\n    function burst(center, radius = 3) {\n      // Radial impulse from a point, with falloff\n      for (let i = 0; i < COUNT; i++) {\n        const idx = i * 3;\n        const dx = positions[idx+0] - center.x;\n        const dy = positions[idx+1] - center.y;\n        const dz = positions[idx+2] - center.z;\n        const dist = Math.hypot(dx, dy, dz) + 1e-6;\n        const falloff = Math.exp(-(dist*dist) / (2 * (radius*radius)));\n        const strength = 18 * falloff;\n        velocities[idx+0] += (dx / dist) * strength;\n        velocities[idx+1] += (dy / dist) * strength;\n        velocities[idx+2] += (dz / dist) * strength;\n      }\n    }\n\n    // Animation loop\n    let prev = performance.now() / 1000;\n    function animate() {\n      const now = performance.now() / 1000;\n      const rawDt = now - prev;\n      prev = now;\n      const dt = Math.min(0.033, rawDt); // clamp to maintain stability\n      const t = now;\n\n      // Camera slow orbit for parallax interest\n      const camR = 7;\n      const camSpeed = 0.08;\n      camera.position.x = Math.cos(t * camSpeed) * camR;\n      camera.position.z = Math.sin(t * camSpeed) * camR;\n      camera.position.y = 2.6 + Math.sin(t * 0.35) * 0.3;\n      camera.lookAt(0, 1.3, 0);\n\n      // Update particle physics\n      for (let i = 0; i < COUNT; i++) {\n        const p = i * 3;\n\n        // Age and lifetime\n        ages[i] += dt;\n        if (ages[i] > lifes[i]) {\n          respawn(i);\n          continue;\n        }\n\n        // Position and velocity\n        let px = positions[p+0];\n        let py = positions[p+1];\n        let pz = positions[p+2];\n\n        let vx = velocities[p+0];\n        let vy = velocities[p+1];\n        let vz = velocities[p+2];\n\n        // Forces: gravity\n        vx += gravity.x * dt;\n        vy += gravity.y * dt;\n        vz += gravity.z * dt;\n\n        // Swirl (vortex) around Y axis\n        const radialX = px;\n        const radialZ = pz;\n        const rLen = Math.hypot(radialX, radialZ) + 1e-6;\n        const swirlDirX = -radialZ / rLen;\n        const swirlDirZ = radialX / rLen;\n        const swirlFalloff = 1.0 / (1.0 + rLen * 1.3);\n        vx += swirlDirX * swirlStrength * swirlFalloff * dt * vy * 0.2;\n        vz += swirlDirZ * swirlStrength * swirlFalloff * dt * vy * 0.2;\n\n        // Gentle per-particle sine drift for turbulence\n        const s = seeds[i];\n        vx += Math.sin(t * 1.3 + s) * 0.3 * dt;\n        vz += Math.cos(t * 1.7 + s * 0.7) * 0.3 * dt;\n\n        // Mouse field\n        if (haveMouseWorld) {\n          const mx = mouseWorld.x;\n          const my = mouseWorld.y;\n          const mz = mouseWorld.z;\n          const dx = mx - px;\n          const dy = my - py;\n          const dz = mz - pz;\n          const dist = Math.hypot(dx, dy, dz);\n          if (dist < mouseRadius) {\n            const norm = dist > 1e-6 ? 1.0 / dist : 0.0;\n            const dirx = dx * norm, diry = dy * norm, dirz = dz * norm;\n            const falloff = Math.exp(-(dist * dist) / (2 * mouseRadius * mouseRadius));\n            const sign = attract ? 1.0 : -1.0;\n            const f = mouseForceBase * falloff * dt;\n            vx += dirx * f * sign;\n            vy += diry * f * sign;\n            vz += dirz * f * sign;\n          }\n        }\n\n        // Apply drag\n        vx *= Math.pow(airDrag, 60 * dt); // scale drag to frame time\n        vy *= Math.pow(airDrag, 60 * dt);\n        vz *= Math.pow(airDrag, 60 * dt);\n\n        // Integrate\n        px += vx * dt;\n        py += vy * dt;\n        pz += vz * dt;\n\n        // Floor collision and bounce\n        if (py < floorY) {\n          py = floorY;\n          if (vy < 0) {\n            vy = -vy * restitution;\n            vx *= friction;\n            vz *= friction;\n          }\n        }\n\n        // If falls too low (e.g., escaped), respawn\n        if (py < respawnBelowY) {\n          respawn(i);\n          continue;\n        }\n\n        // Store back\n        positions[p+0] = px;\n        positions[p+1] = py;\n        positions[p+2] = pz;\n        velocities[p+0] = vx;\n        velocities[p+1] = vy;\n        velocities[p+2] = vz;\n\n        // Color over time: hue cycles with age and height, brightness with velocity\n        const age01 = ages[i] / Math.max(lifes[i], 1e-6);\n        const hue = (0.58 + age01 * 0.4 + (py * 0.05)) % 1.0; // go from cyan->magenta range\n        const speed = Math.min(1.0, Math.hypot(vx, vy, vz) / 8);\n        const sat = 0.9 - 0.3 * age01 + 0.1 * speed;\n        const lum = 0.45 + 0.25 * speed;\n\n        const [r, g, b] = hslToRgb(hue, sat, lum);\n        colors[p+0] = r;\n        colors[p+1] = g;\n        colors[p+2] = b;\n      }\n\n      geometry.attributes.position.needsUpdate = true;\n      geometry.attributes.color.needsUpdate = true;\n\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    }\n\n    // Handle resize\n    function onResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n    window.addEventListener('resize', onResize);\n\n    // Prime mouse world for initial frame\n    updateMouseWorld();\n\n    // Kick off\n    requestAnimationFrame(animate);\n  })();\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 71.39478516578674,
    "status": "success",
    "timestamp": "2025-08-29 17:32:27"
  },
  {
    "test_name": "terrain_simulation",
    "prompt": "Create a complete HTML file with Three.js that generates and displays a 3D terrain landscape. The terrain should have hills and valleys using noise or height maps, include realistic texturing (grass, rock, etc.), and allow the user to fly through the scene with keyboard controls (WASD). Add fog effects for depth. The HTML should be self-contained with Three.js from CDN. Save the output as 'terrain_landscape.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Three.js Terrain Landscape (WASD Fly)</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body { margin: 0; padding: 0; height: 100%; background: #87a7d1; }\n    canvas { display: block; }\n    #ui {\n      position: fixed;\n      top: 12px; left: 12px;\n      background: rgba(0,0,0,0.45);\n      color: #fff;\n      padding: 10px 12px;\n      border-radius: 8px;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;\n      font-size: 14px;\n      line-height: 1.35;\n      user-select: none;\n      z-index: 10;\n      max-width: 320px;\n    }\n    #ui b { color: #aee2ff; }\n    #ui .title { font-weight: 700; font-size: 16px; color: #fff; }\n    #ui .hr { height: 1px; background: rgba(255,255,255,0.15); margin: 8px 0; }\n    #loading {\n      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;\n      background: radial-gradient(ellipse at center, rgba(0,0,0,0.5), rgba(0,0,0,0.85));\n      color: #e6f2ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;\n      z-index: 20;\n    }\n    #loading .inner {\n      text-align: center;\n      padding: 22px 26px;\n      border: 1px solid rgba(255,255,255,0.15);\n      border-radius: 12px;\n      background: rgba(0,0,0,0.25);\n      max-width: 420px;\n    }\n    #loading .inner h1 { margin: 0 0 8px 0; font-size: 18px; font-weight: 700; }\n    #loading .inner p { margin: 6px 0; font-size: 14px; color: #d6e8ff; }\n    #loading .hint { opacity: 0.8; font-size: 13px; }\n    a { color: #aee2ff; text-decoration: none; border-bottom: 1px dotted rgba(174,226,255,0.6); }\n    a:hover { border-bottom-color: rgba(174,226,255,1); }\n  </style>\n</head>\n<body>\n  <div id=\"ui\">\n    <div class=\"title\">3D Terrain Landscape</div>\n    <div class=\"hr\"></div>\n    Controls:\n    <ul style=\"margin:6px 0 0 16px;padding:0;\">\n      <li><b>W/A/S/D</b> move forward/left/back/right</li>\n      <li><b>R / F</b> move up / down</li>\n      <li><b>Mouse</b> drag to look around</li>\n      <li><b>Shift</b> hold to boost speed</li>\n    </ul>\n  </div>\n\n  <div id=\"loading\">\n    <div class=\"inner\">\n      <h1>Generating terrain...</h1>\n      <p>This may take a moment on first load.</p>\n      <p class=\"hint\">Tip: Use WASD to fly, drag the mouse to look. R/F to go up/down.</p>\n    </div>\n  </div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';\n    import { FlyControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/FlyControls.js';\n    import { ImprovedNoise } from 'https://unpkg.com/three@0.165.0/examples/jsm/math/ImprovedNoise.js';\n\n    let renderer, scene, camera, controls;\n    let terrain;\n    const clock = new THREE.Clock();\n\n    init();\n    animate();\n\n    function init() {\n      // Renderer\n      renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      renderer.outputColorSpace = THREE.SRGBColorSpace;\n      document.body.appendChild(renderer.domElement);\n\n      // Scene and fog\n      const skyColor = new THREE.Color(0x87a7d1); // soft blue\n      scene = new THREE.Scene();\n      scene.background = skyColor;\n      scene.fog = new THREE.FogExp2(skyColor.getHex(), 0.00038);\n\n      // Camera\n      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 8000);\n      camera.position.set(0, 180, 400);\n\n      // Lights\n      const hemi = new THREE.HemisphereLight(0xbfd4ff, 0x3f3a2a, 0.7);\n      scene.add(hemi);\n\n      const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);\n      dirLight.position.set(1200, 1500, 700);\n      scene.add(dirLight);\n\n      // Terrain\n      terrain = createTerrain({\n        worldSize: 4000,\n        segments: 256,\n        heightScale: 260\n      });\n      scene.add(terrain);\n\n      // Controls (FlyControls)\n      controls = new FlyControls(camera, renderer.domElement);\n      controls.dragToLook = true;        // left-mouse drag to look\n      controls.movementSpeed = 160;      // base speed\n      controls.rollSpeed = Math.PI / 20; // not used much; enables Q/E roll if desired\n      controls.autoForward = false;\n\n      // Optional: shift to boost\n      let boosting = false;\n      window.addEventListener('keydown', (e) => {\n        if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {\n          if (!boosting) {\n            controls.movementSpeed *= 2.5;\n            boosting = true;\n          }\n        }\n      });\n      window.addEventListener('keyup', (e) => {\n        if (boosting && (e.code === 'ShiftLeft' || e.code === 'ShiftRight')) {\n          controls.movementSpeed /= 2.5;\n          boosting = false;\n        }\n      });\n\n      // Window resize\n      window.addEventListener('resize', onWindowResize);\n\n      // Remove loading overlay after a tick\n      setTimeout(() => {\n        const loading = document.getElementById('loading');\n        if (loading) loading.style.display = 'none';\n      }, 100);\n    }\n\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    function animate() {\n      requestAnimationFrame(animate);\n      const dt = Math.min(clock.getDelta(), 0.05);\n      controls.update(dt);\n      renderer.render(scene, camera);\n    }\n\n    function createTerrain({ worldSize = 4000, segments = 256, heightScale = 200 } = {}) {\n      // Build plane\n      const geometry = new THREE.PlaneGeometry(worldSize, worldSize, segments, segments);\n      geometry.rotateX(-Math.PI / 2);\n\n      // Heights with multi-octave Perlin (ImprovedNoise)\n      const cols = segments + 1;\n      const rows = segments + 1;\n      const heights = generateHeight(cols, rows);\n      const pos = geometry.attributes.position;\n      const vCount = pos.count;\n\n      // Displace vertices\n      let minY = Infinity, maxY = -Infinity;\n      for (let i = 0; i < vCount; i++) {\n        const ix = i % cols;\n        const iz = (i / cols) | 0;\n        const h = heights[iz * cols + ix]; // -1..1\n        const y = h * heightScale;\n        pos.setY(i, y);\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n      }\n\n      // Normals\n      geometry.computeVertexNormals();\n\n      // Color the terrain based on elevation and slope (procedural \"texturing\")\n      const normal = geometry.attributes.normal;\n      const colors = new Float32Array(vCount * 3);\n\n      const colorGrass = new THREE.Color(0x3a7d3a); // rich green\n      const colorDirt  = new THREE.Color(0x6b4f2a); // earthy brown\n      const colorRock  = new THREE.Color(0x888a8c); // gray rock\n      const colorSnow  = new THREE.Color(0xf3f7fb); // snow\n\n      // Helper: smoothstep\n      const smoothstep = (edge0, edge1, x) => {\n        const t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);\n        return t * t * (3 - 2 * t);\n      };\n\n      for (let i = 0; i < vCount; i++) {\n        const y = pos.getY(i);\n        const hN = THREE.MathUtils.clamp((y - minY) / (maxY - minY), 0, 1); // 0..1\n        const ny = normal.getY(i);\n        const slope = THREE.MathUtils.clamp(1 - ny, 0, 1); // 0 flat, 1 steep\n\n        // Base weights using height and slope\n        const snowW = smoothstep(0.78, 0.92, hN);\n        const rockW = Math.max(\n          smoothstep(0.55, 0.82, hN) * smoothstep(0.15, 0.55, slope),\n          smoothstep(0.65, 0.85, hN) * 0.6\n        );\n        const grassW = (1 - slope) * smoothstep(0.15, 0.65, 1.0 - Math.abs(hN - 0.45) * 1.5);\n        const dirtW = 0.35 * smoothstep(0.0, 0.2, 1.0 - hN) * (1 - slope * 0.5);\n\n        // Normalize weights\n        let wSum = snowW + rockW + grassW + dirtW;\n        if (wSum < 1e-5) wSum = 1;\n        const wSnow  = snowW / wSum;\n        const wRock  = rockW / wSum;\n        const wGrass = grassW / wSum;\n        const wDirt  = dirtW / wSum;\n\n        // Slight color variation based on world position to break uniformity\n        const ix = i % cols;\n        const iz = (i / cols) | 0;\n        const varHash = (Math.sin(ix * 12.9898 + iz * 78.233) * 43758.5453) % 1;\n        const variation = 0.92 + (varHash - Math.floor(varHash)) * 0.16; // 0.92..1.08\n\n        const c = new THREE.Color(0, 0, 0);\n        c.addScaledVector(colorSnow,  wSnow);\n        c.addScaledVector(colorRock,  wRock);\n        c.addScaledVector(colorGrass, wGrass);\n        c.addScaledVector(colorDirt,  wDirt);\n        c.multiplyScalar(variation);\n\n        colors[i * 3 + 0] = c.r;\n        colors[i * 3 + 1] = c.g;\n        colors[i * 3 + 2] = c.b;\n      }\n\n      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n      // Material with vertex colors and subtle sheen\n      const material = new THREE.MeshStandardMaterial({\n        vertexColors: true,\n        roughness: 0.95,\n        metalness: 0.0,\n        fog: true\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.receiveShadow = false;\n      mesh.castShadow = false;\n\n      // Add a gentle horizon skydome for better depth (optional visual)\n      const skyGeo = new THREE.SphereGeometry(worldSize * 3, 32, 16);\n      const skyMat = new THREE.ShaderMaterial({\n        side: THREE.BackSide,\n        uniforms: {\n          topColor:    { value: new THREE.Color(0xa8c7ff) },\n          bottomColor: { value: new THREE.Color(0xe6f1ff) },\n          offset:      { value: 400 },\n          exponent:    { value: 0.6 }\n        },\n        vertexShader: `\n          varying vec3 vWorldPosition;\n          void main() {\n            vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n            vWorldPosition = worldPosition.xyz;\n            gl_Position = projectionMatrix * viewMatrix * worldPosition;\n          }\n        `,\n        fragmentShader: `\n          uniform vec3 topColor;\n          uniform vec3 bottomColor;\n          uniform float offset;\n          uniform float exponent;\n          varying vec3 vWorldPosition;\n          void main() {\n            float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;\n            float f = max(pow(max(h, 0.0), exponent), 0.0);\n            gl_FragColor = vec4(mix(bottomColor, topColor, f), 1.0);\n          }\n        `,\n        fog: false\n      });\n      const sky = new THREE.Mesh(skyGeo, skyMat);\n      mesh.add(sky);\n\n      return mesh;\n    }\n\n    function generateHeight(width, height) {\n      const size = width * height;\n      const data = new Float32Array(size);\n      const perlin = new ImprovedNoise();\n      const z = Math.random() * 100;\n\n      // Multi-octave noise\n      let amplitude = 1.0;\n      let frequency = 1.0;\n      let totalAmp = 0.0;\n\n      for (let octave = 0; octave < 6; octave++) {\n        for (let i = 0; i < size; i++) {\n          const x = i % width;\n          const y = (i / width) | 0;\n          // noise returns roughly -1..1\n          const n = perlin.noise(\n            (x / width) * 8.0 * frequency,\n            (y / height) * 8.0 * frequency,\n            z\n          );\n          data[i] += n * amplitude;\n        }\n        totalAmp += amplitude;\n        amplitude *= 0.5;   // persistence\n        frequency *= 2.0;   // lacunarity\n      }\n\n      // Normalize to -1..1\n      for (let i = 0; i < size; i++) {\n        data[i] /= totalAmp;\n        // Add a broad, gentle mountain shape by blending radial falloff\n        const x = (i % width) / (width - 1) * 2 - 1;  // -1..1\n        const y = ((i / width) | 0) / (height - 1) * 2 - 1; // -1..1\n        const r = Math.sqrt(x * x + y * y);\n        const falloff = THREE.MathUtils.clamp(1.0 - r * 0.6, 0.0, 1.0);\n        data[i] = data[i] * 0.8 + (falloff - 0.5) * 0.35;\n      }\n\n      return data; // -1..1\n    }\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 154.42430472373962,
    "status": "success",
    "timestamp": "2025-08-29 17:35:02"
  },
  {
    "test_name": "interactive_solar_system",
    "prompt": "Create a complete HTML file with Three.js that builds an interactive 3D solar system with textured planets, axial rotation, elliptical orbits, adjustable time speed, and click-to-reveal planet facts. Include orbit lines, lighting from a sun mesh, and responsive camera controls. The HTML file should be self-contained with Three.js loaded from CDN and include all textures as data URLs or procedural materials. Save the output as 'interactive_solar_system.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Interactive 3D Solar System</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      background: #000;\n      color: #eee;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;\n      height: 100%;\n    }\n    #app {\n      position: fixed;\n      inset: 0;\n    }\n    canvas { display: block; }\n\n    .ui {\n      position: fixed;\n      top: 10px;\n      left: 10px;\n      background: rgba(0,0,0,0.55);\n      border: 1px solid rgba(255,255,255,0.1);\n      border-radius: 8px;\n      padding: 10px 12px;\n      backdrop-filter: blur(4px);\n      z-index: 10;\n      max-width: 320px;\n    }\n    .ui h1 {\n      font-size: 16px;\n      margin: 0 0 6px 0;\n      font-weight: 600;\n      letter-spacing: 0.3px;\n    }\n    .row {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      margin: 6px 0;\n    }\n    .row label { font-size: 13px; min-width: 88px; }\n    .row input[type=\"range\"] { flex: 1; }\n    .row .value { width: 48px; text-align: right; font-variant-numeric: tabular-nums; }\n    .buttons {\n      display: flex;\n      gap: 6px;\n      margin-top: 6px;\n    }\n    .buttons button, .row input[type=\"checkbox\"] + span {\n      font-size: 13px;\n    }\n    .info {\n      position: fixed;\n      right: 10px;\n      bottom: 10px;\n      z-index: 12;\n      max-width: min(360px, 80vw);\n      background: rgba(0,0,0,0.6);\n      border: 1px solid rgba(255,255,255,0.1);\n      border-radius: 10px;\n      padding: 12px 14px;\n      backdrop-filter: blur(4px);\n      display: none;\n    }\n    .info h2 {\n      margin: 0 0 6px;\n      font-size: 18px;\n      font-weight: 600;\n    }\n    .info p {\n      margin: 6px 0;\n      font-size: 13px;\n      line-height: 1.3;\n      color: #ddd;\n    }\n    .info .grid {\n      display: grid;\n      grid-template-columns: auto 1fr;\n      gap: 4px 10px;\n      font-size: 13px;\n    }\n    .hint {\n      position: fixed;\n      left: 50%;\n      transform: translateX(-50%);\n      bottom: 10px;\n      background: rgba(0,0,0,0.45);\n      border: 1px solid rgba(255,255,255,0.08);\n      padding: 6px 10px;\n      border-radius: 999px;\n      font-size: 12px;\n      letter-spacing: 0.2px;\n      z-index: 9;\n    }\n    @media (max-width: 720px) {\n      .ui { max-width: calc(100vw - 20px); }\n      .info { left: 10px; right: 10px; bottom: 10px; max-width: unset; }\n    }\n  </style>\n</head>\n<body>\n  <div id=\"app\"></div>\n\n  <div class=\"ui\">\n    <h1>Interactive Solar System</h1>\n    <div class=\"row\">\n      <label for=\"speedRange\">Time speed</label>\n      <input id=\"speedRange\" type=\"range\" min=\"0\" max=\"200\" value=\"50\" step=\"1\" />\n      <div class=\"value\"><span id=\"speedValue\">50</span>x</div>\n    </div>\n    <div class=\"row\">\n      <label for=\"orbitsToggle\">Orbit lines</label>\n      <input id=\"orbitsToggle\" type=\"checkbox\" checked />\n      <span>Show</span>\n    </div>\n    <div class=\"row\">\n      <label for=\"labelsToggle\">Stars</label>\n      <input id=\"starsToggle\" type=\"checkbox\" checked />\n      <span>Show</span>\n    </div>\n    <div class=\"buttons\">\n      <button id=\"pauseBtn\">Pause</button>\n      <button id=\"resetCamBtn\">Reset Camera</button>\n      <button id=\"homeInnerBtn\">Focus Inner</button>\n    </div>\n    <div style=\"margin-top:6px; font-size:12px; color:#bbb;\">\n      Tip: Click a planet to see facts. Drag to orbit, scroll/pinch to zoom. Time speed is in \u201cdays per second\u201d.\n    </div>\n  </div>\n\n  <div class=\"info\" id=\"infoPanel\">\n    <h2 id=\"infoTitle\">Planet</h2>\n    <div class=\"grid\">\n      <div>Type:</div><div id=\"infoType\">\u2014</div>\n      <div>Mean radius:</div><div id=\"infoRadius\">\u2014</div>\n      <div>Semi-major axis:</div><div id=\"infoSMA\">\u2014</div>\n      <div>Eccentricity:</div><div id=\"infoEcc\">\u2014</div>\n      <div>Orbital period:</div><div id=\"infoPeriod\">\u2014</div>\n      <div>Rotation period:</div><div id=\"infoRotation\">\u2014</div>\n      <div>Axial tilt:</div><div id=\"infoTilt\">\u2014</div>\n    </div>\n    <p id=\"infoDesc\" style=\"margin-top:8px;\">\u2014</p>\n  </div>\n\n  <div class=\"hint\">Made with Three.js \u2014 Lighting from the Sun \u2014 Elliptical orbits \u2014 Axial rotation \u2014 Saturn's rings</div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';\n    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';\n\n    // Renderer, Scene, Camera\n    const app = document.getElementById('app');\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });\n    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    app.appendChild(renderer.domElement);\n\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x000000);\n\n    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 8000);\n    const initialCamPos = new THREE.Vector3(0, 120, 420);\n    camera.position.copy(initialCamPos);\n\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.target.set(0, 0, 0);\n    controls.minDistance = 30;\n    controls.maxDistance = 3000;\n\n    // UI Elements\n    const speedRange = document.getElementById('speedRange');\n    const speedValue = document.getElementById('speedValue');\n    const orbitsToggle = document.getElementById('orbitsToggle');\n    const starsToggle = document.getElementById('starsToggle');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const resetCamBtn = document.getElementById('resetCamBtn');\n    const homeInnerBtn = document.getElementById('homeInnerBtn');\n\n    speedRange.addEventListener('input', () => {\n      speedValue.textContent = speedRange.value;\n      timeSpeed = parseFloat(speedRange.value);\n    });\n\n    resetCamBtn.addEventListener('click', () => {\n      camera.position.copy(initialCamPos);\n      controls.target.set(0, 0, 0);\n      controls.update();\n    });\n\n    homeInnerBtn.addEventListener('click', () => {\n      // Focus on the inner planets region\n      camera.position.set(0, 80, 240);\n      controls.target.set(0, 0, 0);\n      controls.update();\n    });\n\n    // Time control\n    let paused = false;\n    let timeSpeed = parseFloat(speedRange.value); // days per second\n    pauseBtn.addEventListener('click', () => {\n      paused = !paused;\n      pauseBtn.textContent = paused ? 'Resume' : 'Pause';\n    });\n\n    // Resize handling\n    window.addEventListener('resize', () => {\n      const w = window.innerWidth, h = window.innerHeight;\n      renderer.setSize(w, h);\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n    });\n\n    // Utilities: colors\n    function color(c) { return new THREE.Color(c); }\n\n    // Procedural textures using Canvas\n    function createCanvas(w, h) {\n      const c = document.createElement('canvas');\n      c.width = w; c.height = h;\n      const ctx = c.getContext('2d', { willReadFrequently: false });\n      return { c, ctx };\n    }\n\n    function canvasTexture(draw, w = 1024, h = 512) {\n      const { c, ctx } = createCanvas(w, h);\n      draw(ctx, w, h);\n      const tex = new THREE.CanvasTexture(c);\n      tex.colorSpace = THREE.SRGBColorSpace;\n      tex.wrapS = THREE.RepeatWrapping;\n      tex.wrapT = THREE.RepeatWrapping;\n      tex.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy?.() || 1, 8);\n      return tex;\n    }\n\n    function makeSunTexture() {\n      return canvasTexture((ctx, w, h) => {\n        const grd = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.05, w/2, h/2, Math.max(w,h)*0.55);\n        grd.addColorStop(0.0, '#fff27a');\n        grd.addColorStop(0.2, '#ffd257');\n        grd.addColorStop(0.45, '#ff9e2b');\n        grd.addColorStop(0.7, '#ff6b0f');\n        grd.addColorStop(1.0, '#4a1b00');\n        ctx.fillStyle = grd;\n        ctx.fillRect(0, 0, w, h);\n\n        // Add \"granulation\" noise\n        for (let i = 0; i < 1800; i++) {\n          const x = Math.random()*w, y = Math.random()*h;\n          const r = 0.5 + Math.random()*2.0;\n          const a = 0.05 + Math.random()*0.08;\n          ctx.fillStyle = `rgba(255,200,80,${a})`;\n          ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();\n        }\n      }, 1024, 1024);\n    }\n\n    function makeRockTexture(base, accent) {\n      return canvasTexture((ctx, w, h) => {\n        ctx.fillStyle = base;\n        ctx.fillRect(0, 0, w, h);\n        // subtle noise\n        for (let i = 0; i < 5000; i++) {\n          const x = Math.random()*w, y = Math.random()*h;\n          const a = Math.random()*0.15;\n          const r = Math.random()*1.2 + 0.4;\n          ctx.fillStyle = `rgba(255,255,255,${a})`;\n          ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();\n        }\n        // blotches\n        for (let i = 0; i < 90; i++) {\n          ctx.globalAlpha = 0.12 + Math.random()*0.18;\n          ctx.fillStyle = accent;\n          const cx = Math.random()*w, cy = Math.random()*h;\n          const rx = 10 + Math.random()*80, ry = 8 + Math.random()*60;\n          ctx.beginPath(); ctx.ellipse(cx, cy, rx, ry, Math.random()*Math.PI, 0, Math.PI*2); ctx.fill();\n        }\n        ctx.globalAlpha = 1;\n      }, 1024, 512);\n    }\n\n    function makeGasGiantTexture(bands) {\n      return canvasTexture((ctx, w, h) => {\n        // Draw horizontal bands with slight waviness\n        const rows = bands.length;\n        const bandHeight = h / rows;\n        for (let i = 0; i < rows; i++) {\n          const y0 = Math.floor(i * bandHeight);\n          const y1 = Math.floor((i+1) * bandHeight);\n          ctx.fillStyle = bands[i];\n          for (let y = y0; y < y1; y++) {\n            const offset = Math.sin((y/h)*Math.PI*4 + i*0.7) * 8;\n            ctx.fillRect(offset, y, w, 1);\n          }\n        }\n        // Add turbulence streaks\n        ctx.globalAlpha = 0.15;\n        ctx.fillStyle = '#ffffff';\n        for (let i = 0; i < 200; i++) {\n          const y = Math.random()*h;\n          const len = 60 + Math.random()*280;\n          const x = Math.random()*w;\n          ctx.fillRect(x, y, len, 1);\n        }\n        ctx.globalAlpha = 1;\n      }, 2048, 1024);\n    }\n\n    function makeEarthLikeTexture() {\n      return canvasTexture((ctx, w, h) => {\n        // Ocean\n        const grd = ctx.createLinearGradient(0, 0, 0, h);\n        grd.addColorStop(0, '#2075c8');\n        grd.addColorStop(1, '#0f4ea6');\n        ctx.fillStyle = grd;\n        ctx.fillRect(0, 0, w, h);\n\n        // Continents (randomized blobs)\n        function drawBlob(color, count, minR=30, maxR=160, alpha=0.6) {\n          ctx.fillStyle = color;\n          ctx.globalAlpha = alpha;\n          for (let i = 0; i < count; i++) {\n            const cx = Math.random()*w, cy = Math.random()*h;\n            const r = minR + Math.random()*(maxR-minR);\n            ctx.beginPath();\n            const steps = 10 + Math.floor(Math.random()*18);\n            for (let a = 0; a <= steps; a++) {\n              const ang = (a/steps) * Math.PI*2;\n              const rad = r * (0.7 + Math.random()*0.6);\n              const x = cx + Math.cos(ang)*rad;\n              const y = cy + Math.sin(ang)*rad;\n              if (a===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);\n            }\n            ctx.closePath(); ctx.fill();\n          }\n          ctx.globalAlpha = 1;\n        }\n        drawBlob('#3aa655', 16, 40, 120, 0.65);\n        drawBlob('#2e8b57', 14, 20, 100, 0.55);\n        // Clouds\n        ctx.globalAlpha = 0.2;\n        ctx.fillStyle = '#ffffff';\n        for (let i = 0; i < 900; i++) {\n          const x = Math.random()*w, y = Math.random()*h;\n          const rx = 10 + Math.random()*40, ry = 5 + Math.random()*20;\n          ctx.beginPath(); ctx.ellipse(x, y, rx, ry, Math.random()*Math.PI, 0, Math.PI*2); ctx.fill();\n        }\n        ctx.globalAlpha = 1;\n      }, 2048, 1024);\n    }\n\n    function makeRingTexture() {\n      // Transparent center (inner radius), semi-transparent ring with subtle banding\n      return canvasTexture((ctx, w, h) => {\n        ctx.clearRect(0, 0, w, h);\n        const cx = w/2, cy = h/2;\n        const maxR = Math.min(w, h)/2;\n        for (let r = 0; r < maxR; r++) {\n          const t = r/maxR;\n          // Multiple pale hues\n          const c1 = Math.floor(220 - 80*t);\n          const c2 = Math.floor(210 - 70*t);\n          const alpha = (t > 0.35 && t < 0.95) ? 0.5 - 0.45*Math.abs(t-0.65) : 0.0;\n          ctx.strokeStyle = `rgba(${c1},${c2},${c1},${alpha})`;\n          ctx.beginPath();\n          ctx.arc(cx, cy, r, 0, Math.PI*2);\n          ctx.stroke();\n        }\n        // Subtle darker ringlets\n        ctx.globalAlpha = 0.25;\n        ctx.strokeStyle = 'rgba(120,110,100,0.5)';\n        for (let i = 0; i < 16; i++) {\n          const r = (0.45 + 0.05*i) * maxR;\n          ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();\n        }\n        ctx.globalAlpha = 1;\n      }, 1024, 1024);\n    }\n\n    // Scene contents\n    // Stars (optional toggle)\n    const starGroup = new THREE.Group();\n    scene.add(starGroup);\n\n    function buildStars() {\n      starGroup.clear();\n      const starGeo = new THREE.BufferGeometry();\n      const count = 2000;\n      const positions = new Float32Array(count * 3);\n      for (let i = 0; i < count; i++) {\n        // Spherical shell\n        const r = 3000 + Math.random() * 1200;\n        const theta = Math.random() * Math.PI * 2;\n        const phi = Math.acos(2 * Math.random() - 1);\n        positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);\n        positions[i*3+1] = r * Math.cos(phi) * (Math.random() < 0.95 ? 1 : 0.4); // small band bias\n        positions[i*3+2] = r * Math.sin(phi) * Math.sin(theta);\n      }\n      starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n      const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.4, sizeAttenuation: true, transparent: true, opacity: 0.9 });\n      const stars = new THREE.Points(starGeo, starMat);\n      starGroup.add(stars);\n    }\n    buildStars();\n\n    starsToggle.addEventListener('change', () => {\n      starGroup.visible = starsToggle.checked;\n    });\n\n    // Sun\n    const sunTexture = makeSunTexture();\n    const sunRadius = 16;\n    const sunGeo = new THREE.SphereGeometry(sunRadius, 64, 64);\n    const sunMat = new THREE.MeshBasicMaterial({ map: sunTexture, toneMapped: false });\n    const sunMesh = new THREE.Mesh(sunGeo, sunMat);\n    sunMesh.name = 'Sun';\n    scene.add(sunMesh);\n\n    // Light emitted from the Sun\n    const sunLight = new THREE.PointLight(0xffffff, 3.5, 0, 2);\n    sunLight.position.set(0, 0, 0);\n    scene.add(sunLight);\n\n    // Very subtle ambient light to prevent total darkness on night sides\n    scene.add(new THREE.AmbientLight(0x222222, 0.4));\n\n    // Orbit Line builder (elliptical)\n    function buildOrbitLine(aUnits, e, incDeg, periDeg, samples=256, colorHex=0x444444) {\n      const positions = [];\n      const a = aUnits;\n      const inc = THREE.MathUtils.degToRad(incDeg);\n      const peri = THREE.MathUtils.degToRad(periDeg);\n      const cosPeri = Math.cos(peri), sinPeri = Math.sin(peri);\n      const cosInc = Math.cos(inc), sinInc = Math.sin(inc);\n\n      for (let i = 0; i <= samples; i++) {\n        const theta = (i / samples) * Math.PI * 2;\n        const r = a * (1 - e*e) / (1 + e * Math.cos(theta));\n        let x = r * Math.cos(theta);\n        let z = r * Math.sin(theta);\n        // Rotate by periapsis around Y\n        const x1 = x * cosPeri - z * sinPeri;\n        const z1 = x * sinPeri + z * cosPeri;\n        // Inclination around X\n        const y2 = z1 * sinInc;\n        const z2 = z1 * cosInc;\n        positions.push(x1, y2, z2);\n      }\n      const geo = new THREE.BufferGeometry();\n      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n      const mat = new THREE.LineBasicMaterial({ color: colorHex, transparent: true, opacity: 0.6 });\n      const line = new THREE.Line(geo, mat);\n      line.frustumCulled = false;\n      return line;\n    }\n\n    // Distance scaling: compress outer system while keeping order\n    function scaleAU(au) {\n      // Nonlinear scale good for visualization\n      return 30 + 60 * Math.pow(au, 0.8) + 20 * au;\n    }\n\n    // Planet data\n    const planetsData = [\n      {\n        name: 'Mercury',\n        type: 'Rocky',\n        radius: 0.4,\n        au: 0.39, e: 0.2056, inc: 7.0, peri: 29.1,\n        orbitalDays: 88.0,\n        rotationDays: 58.6, tilt: 0.03,\n        colorBase: '#6f6f6f', colorAccent: '#4a4a4a',\n        description: 'The smallest planet and closest to the Sun. Mercury has a heavily cratered, airless surface and extreme temperature swings.'\n      },\n      {\n        name: 'Venus',\n        type: 'Rocky',\n        radius: 0.95,\n        au: 0.72, e: 0.0067, inc: 3.39, peri: 54.9,\n        orbitalDays: 224.7,\n        rotationDays: -243.0, tilt: 177.0, // retrograde\n        colorBase: '#e1c26b', colorAccent: '#caa458',\n        description: 'A hot world with a thick, toxic atmosphere and runaway greenhouse effect. Venus rotates retrograde (opposite direction).'\n      },\n      {\n        name: 'Earth',\n        type: 'Rocky',\n        radius: 1.0,\n        au: 1.0, e: 0.0167, inc: 0.0, peri: 102.9,\n        orbitalDays: 365.25,\n        rotationDays: 1.0, tilt: 23.44,\n        customTexture: 'earth',\n        description: 'Our home world, the only known planet to harbor life. 71% covered by oceans, with a protective atmosphere and magnetic field.'\n      },\n      {\n        name: 'Mars',\n        type: 'Rocky',\n        radius: 0.53,\n        au: 1.52, e: 0.0934, inc: 1.85, peri: 286.5,\n        orbitalDays: 686.98,\n        rotationDays: 1.03, tilt: 25.19,\n        colorBase: '#b65f3a', colorAccent: '#7f3820',\n        description: 'The Red Planet is a cold desert world with the largest volcano and canyon in the Solar System.'\n      },\n      {\n        name: 'Jupiter',\n        type: 'Gas giant',\n        radius: 3.6, // visual scale\n        au: 5.20, e: 0.0489, inc: 1.30, peri: 273.9,\n        orbitalDays: 4332.59,\n        rotationDays: 0.41, tilt: 3.13,\n        bands: ['#caa77e','#a88a67','#caa77e','#8d6f55','#caa77e','#b89672','#a07f60','#cfb28d'],\n        description: 'The largest planet with a thick atmosphere of hydrogen and helium, famous for its Great Red Spot storm.'\n      },\n      {\n        name: 'Saturn',\n        type: 'Gas giant',\n        radius: 3.1,\n        au: 9.58, e: 0.0565, inc: 2.49, peri: 339.4,\n        orbitalDays: 10759.22,\n        rotationDays: 0.44, tilt: 26.73,\n        bands: ['#e1d3b3','#cdbd9f','#e1d3b3','#b7a584','#e1d3b3','#d4c6a6','#c0ae90','#e1d3b3'],\n        hasRings: true,\n        description: 'A gas giant distinguished by its spectacular ring system made of ice, rock, and dust.'\n      },\n      {\n        name: 'Uranus',\n        type: 'Ice giant',\n        radius: 2.2,\n        au: 19.2, e: 0.046, inc: 0.77, peri: 96.9,\n        orbitalDays: 30685.4,\n        rotationDays: -0.72, tilt: 97.77, // rolls on its side\n        bands: ['#9fd4d9','#8ecad0','#9fd4d9','#7dbec6','#9fd4d9','#8ecad0'],\n        description: 'An ice giant with a unique sideways rotation, likely caused by an ancient collision.'\n      },\n      {\n        name: 'Neptune',\n        type: 'Ice giant',\n        radius: 2.1,\n        au: 30.05, e: 0.0097, inc: 1.77, peri: 273.2,\n        orbitalDays: 60190,\n        rotationDays: 0.67, tilt: 28.32,\n        bands: ['#4c79d3','#406bc1','#4c79d3','#385fb1','#4c79d3','#406bc1'],\n        description: 'A windy, cold ice giant with supersonic storms and a deep blue color from methane in its atmosphere.'\n      }\n    ];\n\n    // Build planet system\n    const planetObjects = []; // { mesh, data, orbitLine, ring? }\n    const clickable = []; // for raycasting\n\n    const ringTexture = makeRingTexture();\n\n    planetsData.forEach((pd, index) => {\n      const distance = scaleAU(pd.au);\n      const radius = pd.radius * 2.2; // visual size factor\n      let texture;\n\n      if (pd.customTexture === 'earth') {\n        texture = makeEarthLikeTexture();\n      } else if (pd.bands) {\n        texture = makeGasGiantTexture(pd.bands);\n      } else {\n        texture = makeRockTexture(pd.colorBase, pd.colorAccent);\n      }\n\n      const geo = new THREE.SphereGeometry(radius, 64, 64);\n      const mat = new THREE.MeshStandardMaterial({\n        map: texture,\n        roughness: 1.0,\n        metalness: 0.0\n      });\n      const mesh = new THREE.Mesh(geo, mat);\n      mesh.castShadow = false;\n      mesh.receiveShadow = false;\n      mesh.name = pd.name;\n\n      // Create a parent object to place the planet at position (for orbit animation)\n      const holder = new THREE.Object3D();\n      holder.position.set(0, 0, 0);\n      scene.add(holder);\n\n      // Add the mesh to the holder, we will directly set 'mesh.position' in world space every frame\n      scene.add(mesh);\n\n      // Axis tilt: tilt the mesh, then spin around local Y (post-tilt)\n      mesh.rotation.z = THREE.MathUtils.degToRad(pd.tilt || 0);\n\n      // Orbit visualization line\n      const orbitA = distance; // semi-major axis (scaled)\n      const orbitE = pd.e;\n      const orbitLine = buildOrbitLine(orbitA, orbitE, pd.inc, pd.peri, 256, 0x555555);\n      orbitLine.visible = orbitsToggle.checked;\n      scene.add(orbitLine);\n\n      // Saturn rings\n      let ringMesh = null;\n      if (pd.hasRings) {\n        const innerR = radius * 1.8;\n        const outerR = radius * 3.2;\n        const ringGeo = new THREE.RingGeometry(innerR, outerR, 128, 1);\n        // Orient UVs to center\n        const pos = ringGeo.attributes.position;\n        const uv = new Float32Array((pos.count) * 2);\n        for (let i = 0; i < pos.count; i++) {\n          const x = pos.getX(i), y = pos.getY(i);\n          uv[i*2] = (x / (outerR*2)) + 0.5;\n          uv[i*2+1] = (y / (outerR*2)) + 0.5;\n        }\n        ringGeo.setAttribute('uv', new THREE.BufferAttribute(uv, 2));\n\n        const ringMat = new THREE.MeshBasicMaterial({\n          map: ringTexture,\n          transparent: true,\n          opacity: 0.9,\n          side: THREE.DoubleSide,\n          depthWrite: false\n        });\n        ringMesh = new THREE.Mesh(ringGeo, ringMat);\n        ringMesh.rotation.x = Math.PI / 2; // initial orientation; we will align with planet's tilt in animate\n        ringMesh.matrixAutoUpdate = true;\n        ringMesh.renderOrder = 1;\n        ringMesh.userData.isRing = true;\n        scene.add(ringMesh);\n      }\n\n      planetObjects.push({\n        data: pd,\n        mesh,\n        ring: ringMesh,\n        orbitLine,\n        a: orbitA,\n        e: orbitE,\n        inc: THREE.MathUtils.degToRad(pd.inc),\n        peri: THREE.MathUtils.degToRad(pd.peri),\n        rotationDays: pd.rotationDays\n      });\n\n      clickable.push(mesh);\n    });\n\n    orbitsToggle.addEventListener('change', () => {\n      planetObjects.forEach(p => p.orbitLine.visible = orbitsToggle.checked);\n    });\n\n    // Raycaster for click-to-reveal\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n    renderer.domElement.addEventListener('pointerdown', (ev) => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;\n      mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;\n\n      raycaster.setFromCamera(mouse, camera);\n      const intersects = raycaster.intersectObjects(clickable, true);\n      if (intersects.length > 0) {\n        const obj = intersects[0].object;\n        const found = planetObjects.find(p => p.mesh === obj || p.mesh === obj.parent);\n        if (found) showInfo(found);\n      }\n    });\n\n    // Info panel handling\n    const infoPanel = document.getElementById('infoPanel');\n    const infoTitle = document.getElementById('infoTitle');\n    const infoType = document.getElementById('infoType');\n    const infoRadius = document.getElementById('infoRadius');\n    const infoSMA = document.getElementById('infoSMA');\n    const infoEcc = document.getElementById('infoEcc');\n    const infoPeriod = document.getElementById('infoPeriod');\n    const infoRotation = document.getElementById('infoRotation');\n    const infoTilt = document.getElementById('infoTilt');\n    const infoDesc = document.getElementById('infoDesc');\n\n    function showInfo(p) {\n      const d = p.data;\n      infoTitle.textContent = d.name;\n      infoType.textContent = d.type;\n      infoRadius.textContent = `${(d.radius * 6371).toFixed(0)} km (scaled)`;\n      infoSMA.textContent = `${d.au} AU`;\n      infoEcc.textContent = d.e.toFixed(3);\n      infoPeriod.textContent = `${d.orbitalDays.toLocaleString()} days`;\n      infoRotation.textContent = `${Math.abs(d.rotationDays).toFixed(2)} days` + (d.rotationDays < 0 ? ' (retrograde)' : '');\n      infoTilt.textContent = `${d.tilt}\u00b0`;\n      infoDesc.textContent = d.description || '';\n      infoPanel.style.display = 'block';\n    }\n\n    // Hide info on background double-click\n    renderer.domElement.addEventListener('dblclick', () => {\n      infoPanel.style.display = 'none';\n    });\n\n    // Animation state\n    const clock = new THREE.Clock();\n    let simDays = 0;\n\n    // Animate\n    function animate() {\n      requestAnimationFrame(animate);\n      const dt = clock.getDelta();\n      if (!paused) {\n        simDays += dt * timeSpeed;\n      }\n\n      // Spin and orbit each planet\n      for (const p of planetObjects) {\n        const { mesh, ring, a, e } = p;\n        const T = p.data.orbitalDays;\n        const angle = (simDays / T) * Math.PI * 2; // mean anomaly approximation\n        const r = a * (1 - e*e) / (1 + e * Math.cos(angle));\n\n        // Local position in orbital plane (x,z)\n        let x = r * Math.cos(angle);\n        let z = r * Math.sin(angle);\n\n        // Apply periapsis rotation around Y\n        const cp = Math.cos(p.peri), sp = Math.sin(p.peri);\n        const x1 = x * cp - z * sp;\n        const z1 = x * sp + z * cp;\n\n        // Apply inclination around X\n        const ci = Math.cos(p.inc), si = Math.sin(p.inc);\n        const y2 = z1 * si;\n        const z2 = z1 * ci;\n\n        mesh.position.set(x1, y2, z2);\n\n        // Spin (axial rotation)\n        const rotDays = p.rotationDays;\n        if (!paused && rotDays !== 0) {\n          const spinRateRadPerDay = (Math.PI * 2) / Math.abs(rotDays);\n          const spinDir = rotDays < 0 ? -1 : 1;\n          mesh.rotation.y += spinDir * spinRateRadPerDay * dt * timeSpeed;\n        }\n\n        // Align rings with the planet's axial tilt (approximate)\n        if (ring) {\n          ring.position.copy(mesh.position);\n          // We orient ring plane to planet's equator: rotate ring around Z by planet tilt\n          ring.rotation.set(0, 0, 0);\n          ring.rotateX(Math.PI / 2);\n          ring.rotateZ(mesh.rotation.z);\n        }\n      }\n\n      // Slow sun \"boil\"\n      sunMesh.rotation.y += 0.005;\n\n      controls.update();\n      renderer.render(scene, camera);\n    }\n    animate();\n\n    // Initial info: none\n\n    // Create minimal ground grid? Not needed in space.\n\n    // Done\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 185.98330807685852,
    "status": "success",
    "timestamp": "2025-08-29 17:38:08"
  },
  {
    "test_name": "procedural_city_generator",
    "prompt": "Create a complete HTML file with Three.js that generates a procedural 3D city with random blocks, building heights, road grid, traffic light animations, day/night cycle with HDRI sky, and a free-fly camera. Add a mini-map overlay and a seed input to reproduce layouts. The HTML file should be self-contained with Three.js loaded from CDN and include all necessary shaders and textures inline. Save the output as 'procedural_city.html'.",
    "response": "Below is a complete, self-contained HTML file that you can save as procedural_city.html. It uses Three.js from CDN, includes a procedural 3D city with random blocks and building heights, a road grid, animated traffic lights, a day/night cycle using the Three.js Sky shader (HDR environment), a free-fly camera, a mini-map overlay, and a seed input to reproduce layouts. All textures are generated procedurally in code; no external textures are used.\n\nCopy everything below into a file named procedural_city.html and open it in a modern browser. For best results, run it from a local web server (many browsers block some module features from file:// URLs).\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Procedural City - Three.js</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\" />\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      height: 100%;\n      background: #000;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;\n      color: #eee;\n    }\n    #ui {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      background: rgba(0,0,0,0.55);\n      padding: 10px 12px;\n      border-radius: 8px;\n      backdrop-filter: blur(4px);\n      z-index: 10;\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    #ui label {\n      font-size: 12px;\n      opacity: 0.9;\n    }\n    #seedInput {\n      width: 160px;\n      padding: 4px 6px;\n      border-radius: 4px;\n      border: 1px solid #444;\n      background: #101010;\n      color: #eee;\n    }\n    #regenBtn, #randomBtn {\n      padding: 6px 10px;\n      border: 1px solid #444;\n      background: #181818;\n      color: #eee;\n      border-radius: 4px;\n      cursor: pointer;\n    }\n    #regenBtn:hover, #randomBtn:hover {\n      background: #222;\n    }\n    #info {\n      position: absolute;\n      left: 10px;\n      bottom: 10px;\n      z-index: 10;\n      background: rgba(0,0,0,0.5);\n      padding: 8px 10px;\n      border-radius: 8px;\n      font-size: 12px;\n      line-height: 1.35;\n    }\n    #miniMapFrame {\n      position: absolute;\n      right: 12px;\n      top: 12px;\n      width: 200px;\n      height: 200px;\n      border: 2px solid rgba(255,255,255,0.6);\n      box-shadow: 0 0 0 2px rgba(0,0,0,0.4) inset;\n      border-radius: 8px;\n      pointer-events: none;\n      z-index: 15;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"ui\">\n    <label for=\"seedInput\">Seed:</label>\n    <input id=\"seedInput\" type=\"text\" placeholder=\"Enter seed\" />\n    <button id=\"regenBtn\" title=\"Regenerate city using the seed\">Regenerate</button>\n    <button id=\"randomBtn\" title=\"Generate a random seed and rebuild\">Randomize</button>\n    <label id=\"timeLabel\">Time: --:--</label>\n  </div>\n  <div id=\"miniMapFrame\"></div>\n  <div id=\"info\">\n    Controls: Click and drag to look \u2022 WASD to move \u2022 R/F up/down \u2022 Q/E roll \u2022 Shift for fast<br/>\n    Day/Night cycle and traffic lights are animated<br/>\n    Mini-map shows top-down view of the city (top-right)\n  </div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';\n    import { FlyControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/FlyControls.js';\n    import { Sky } from 'https://unpkg.com/three@0.160.1/examples/jsm/objects/Sky.js';\n\n    // DOM\n    const seedInput = document.getElementById('seedInput');\n    const regenBtn = document.getElementById('regenBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const timeLabel = document.getElementById('timeLabel');\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.0;\n    document.body.appendChild(renderer.domElement);\n\n    // Scene and Cameras\n    const scene = new THREE.Scene();\n\n    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 8000);\n    camera.position.set(150, 120, 150);\n    camera.lookAt(0, 0, 0);\n\n    // Minimap camera (orthographic top-down)\n    const miniMapCamera = new THREE.OrthographicCamera(-200, 200, 200, -200, 1, 4000);\n    miniMapCamera.up.set(0, 0, -1); // Make +Z go down in the mini-map for intuitive orientation\n    miniMapCamera.lookAt(new THREE.Vector3(0, 0, 0));\n\n    // Controls\n    const controls = new FlyControls(camera, renderer.domElement);\n    controls.movementSpeed = 60;\n    controls.rollSpeed = Math.PI / 8;\n    controls.dragToLook = true;\n    controls.autoForward = false;\n\n    // Lighting\n    const ambient = new THREE.AmbientLight(0xffffff, 0.25);\n    scene.add(ambient);\n\n    const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);\n    sunLight.position.set(100, 200, 100);\n    sunLight.castShadow = false;\n    scene.add(sunLight);\n\n    // Sky (HDR-ish environment via Sky + PMREM)\n    const skyBG = new Sky();\n    skyBG.scale.setScalar(100000);\n    scene.add(skyBG);\n\n    const skyEnv = new Sky();\n    skyEnv.scale.setScalar(100000);\n\n    const skyScene = new THREE.Scene();\n    skyScene.add(skyEnv);\n\n    const pmremGen = new THREE.PMREMGenerator(renderer);\n    pmremGen.compileEquirectangularShader();\n    let envRT = null;\n\n    function setSkyUniforms(sky, elevation, azimuth) {\n      const uniforms = sky.material.uniforms;\n      uniforms['turbidity'].value = 2.2;\n      uniforms['rayleigh'].value = 1.5;\n      uniforms['mieCoefficient'].value = 0.005;\n      uniforms['mieDirectionalG'].value = 0.8;\n\n      // Convert elevation/azimuth (in degrees) to sun position (spherical coords)\n      const phi = THREE.MathUtils.degToRad(90 - elevation);\n      const theta = THREE.MathUtils.degToRad(azimuth);\n      const sunPos = new THREE.Vector3().setFromSphericalCoords(1, phi, theta);\n      uniforms['sunPosition'].value.copy(sunPos);\n    }\n\n    function updateEnvironment() {\n      if (envRT) envRT.dispose();\n      envRT = pmremGen.fromScene(skyScene);\n      scene.environment = envRT.texture;\n    }\n\n    // City parameters and containers\n    const CITY = {\n      blocksX: 14,\n      blocksZ: 14,\n      blockSize: 42,\n      streetWidth: 10,\n      marginInsideBlock: 3,\n      buildingMin: 6,\n      buildingMax: 18,\n      buildingHeightMin: 10,\n      buildingHeightMax: 120,\n      buildingColorPalette: [\n        '#aaaaaa', '#bbbbbb', '#c1c7d0', '#9da3a6', '#8c8f96', '#b7b7b7', '#c8d0d0'\n      ]\n    };\n\n    let rng = null;\n    let cityGroup = new THREE.Group();\n    scene.add(cityGroup);\n\n    // Materials and textures (procedural)\n    const textures = {};\n    const materials = {\n      building: null,\n      road: null,\n      sidewalk: null,\n      trafficPole: null,\n      trafficBlack: null,\n      trafficRed: null,\n      trafficYellow: null,\n      trafficGreen: null\n    };\n\n    function createRNG(seedStr) {\n      // cyrb128 + sfc32\n      function cyrb128(str) {\n        let h1 = 1779033703, h2 = 3144134277,\n            h3 = 1013904242, h4 = 2773480762;\n        for (let i = 0, k; i < str.length; i++) {\n          k = str.charCodeAt(i);\n          h1 = h2 ^ Math.imul(h1 ^ k, 597399067);\n          h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);\n          h3 = h4 ^ Math.imul(h3 ^ k, 951274213);\n          h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);\n        }\n        h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);\n        h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);\n        h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);\n        h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);\n        return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];\n      }\n      function sfc32(a, b, c, d) {\n        return function() {\n          a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;\n          let t = (a + b) | 0;\n          a = b ^ b >>> 9;\n          b = c + (c << 3) | 0;\n          c = (c << 21 | c >>> 11);\n          d = d + 1 | 0;\n          t = t + d | 0;\n          c = c + t | 0;\n          return (t >>> 0) / 4294967296;\n        }\n      }\n      const s = cyrb128(seedStr || 'default-seed');\n      return sfc32(s[0], s[1], s[2], s[3]);\n    }\n\n    function seededRand(min = 0, max = 1) {\n      return min + (max - min) * rng();\n    }\n\n    // Procedural texture generators\n    function makeRoadTexture() {\n      // Dark asphalt with subtle noise and dashed center line\n      const w = 256, h = 1024;\n      const c = document.createElement('canvas');\n      c.width = w; c.height = h;\n      const ctx = c.getContext('2d');\n\n      // Asphalt base\n      ctx.fillStyle = '#1a1a1a';\n      ctx.fillRect(0,0,w,h);\n\n      // Noise\n      const img = ctx.getImageData(0,0,w,h);\n      const data = img.data;\n      for (let i = 0; i < data.length; i += 4) {\n        const n = (Math.random()*20)|0; // small noise\n        data[i  ] = 26 + n;\n        data[i+1] = 26 + n;\n        data[i+2] = 26 + n;\n        data[i+3] = 255;\n      }\n      ctx.putImageData(img, 0, 0);\n\n      // Dashes center\n      ctx.strokeStyle = '#e7e7e7';\n      ctx.lineWidth = 6;\n      ctx.setLineDash([40, 50]);\n      ctx.beginPath();\n      ctx.moveTo(w/2, 0);\n      ctx.lineTo(w/2, h);\n      ctx.stroke();\n\n      const tex = new THREE.CanvasTexture(c);\n      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n      tex.anisotropy = 8;\n      tex.colorSpace = THREE.SRGBColorSpace;\n      return tex;\n    }\n\n    function makeSidewalkTexture() {\n      const w = 256, h = 256;\n      const c = document.createElement('canvas');\n      c.width = w; c.height = h;\n      const ctx = c.getContext('2d');\n\n      // Base\n      ctx.fillStyle = '#6d6d6d';\n      ctx.fillRect(0,0,w,h);\n\n      // Tile lines\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n      ctx.lineWidth = 2;\n      const step = 32;\n      for (let x = 0; x <= w; x += step) {\n        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();\n      }\n      for (let y = 0; y <= h; y += step) {\n        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();\n      }\n\n      const tex = new THREE.CanvasTexture(c);\n      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n      tex.repeat.set(8, 8);\n      tex.anisotropy = 8;\n      tex.colorSpace = THREE.SRGBColorSpace;\n      return tex;\n    }\n\n    function makeWindowEmissiveTexture(seed) {\n      // Grid of windows with random on/off per cell; deterministic via seed\n      const r = createRNG('windows-' + seed);\n      const w = 256, h = 512;\n      const cols = 8, rows = 16;\n      const padX = 8, padY = 8;\n      const cellW = Math.floor((w - padX*2) / cols);\n      const cellH = Math.floor((h - padY*2) / rows);\n\n      const c = document.createElement('canvas');\n      c.width = w; c.height = h;\n      const ctx = c.getContext('2d');\n      ctx.fillStyle = '#000000';\n      ctx.fillRect(0,0,w,h);\n\n      for (let y = 0; y < rows; y++) {\n        for (let x = 0; x < cols; x++) {\n          const on = r() > 0.55; // ~45% windows lit by default\n          const jitter = r()*0.25;\n          const hue = 48 + r()*8; // warm lights\n          const sat = 70 + r()*10;\n          const light = on ? 75 + jitter*10 : 5 + jitter*5;\n          ctx.fillStyle = `hsl(${hue} ${sat}% ${light}%)`;\n          const rx = padX + x*cellW + 3 + r()*2;\n          const ry = padY + y*cellH + 3 + r()*2;\n          const rw = cellW - 6;\n          const rh = cellH - 6;\n          ctx.fillRect(rx, ry, rw, rh);\n        }\n      }\n\n      const tex = new THREE.CanvasTexture(c);\n      tex.wrapS = THREE.RepeatWrapping;\n      tex.wrapT = THREE.RepeatWrapping;\n      tex.repeat.set(1, 1);\n      tex.anisotropy = 8;\n      tex.colorSpace = THREE.SRGBColorSpace;\n      return tex;\n    }\n\n    // Traffic light structures\n    const trafficLights = []; // { group, dir: 'NS'|'EW', bulbs: {r,y,g}, offset }\n    function createTrafficLightAt(pos, offsetPhase = 0) {\n      const group = new THREE.Group();\n      group.position.copy(pos);\n\n      // Pole\n      const poleGeo = new THREE.CylinderGeometry(0.15, 0.15, 4, 8);\n      const pole = new THREE.Mesh(poleGeo, materials.trafficPole);\n      pole.position.set(0, 2, 0);\n      group.add(pole);\n\n      // Cross arms for EW and NS\n      const armGeo = new THREE.BoxGeometry(0.15, 0.15, 2.0);\n      const armEW = new THREE.Mesh(armGeo, materials.trafficPole);\n      armEW.position.set(0, 3.2, 0);\n      group.add(armEW);\n\n      const armNS = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.15, 0.15), materials.trafficPole);\n      armNS.position.set(0, 3.2, 0);\n      group.add(armNS);\n\n      // Bulb module\n      function makeBulbSet(direction) {\n        // Traffic head: black box + three bulbs\n        const head = new THREE.Group();\n        const headBody = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.9, 0.3), materials.trafficBlack);\n        head.add(headBody);\n\n        const bulbR = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 12), materials.trafficRed);\n        const bulbY = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 12), materials.trafficYellow);\n        const bulbG = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 12), materials.trafficGreen);\n        bulbR.position.set(0, 0.26, 0.18);\n        bulbY.position.set(0, 0.0, 0.18);\n        bulbG.position.set(0, -0.26, 0.18);\n        head.add(bulbR, bulbY, bulbG);\n        head.userData.bulbs = { r: bulbR, y: bulbY, g: bulbG };\n\n        // Place two heads per direction, one each side of the intersection arm\n        const dirGroup = new THREE.Group();\n        if (direction === 'EW') {\n          const h1 = head.clone(true);\n          const h2 = head.clone(true);\n          h1.position.set(0, 3.2, 1.0);\n          h2.position.set(0, 3.2, -1.0);\n          dirGroup.add(h1, h2);\n          // Orient to face East and West (\u00b1Z)\n          h1.rotation.y = 0;   // +Z\n          h2.rotation.y = Math.PI; // -Z\n        } else {\n          const h1 = head.clone(true);\n          const h2 = head.clone(true);\n          h1.position.set(1.0, 3.2, 0);\n          h2.position.set(-1.0, 3.2, 0);\n          dirGroup.add(h1, h2);\n          // Orient to face North and South (\u00b1X)\n          h1.rotation.y = -Math.PI/2; // +X\n          h2.rotation.y = Math.PI/2;  // -X\n        }\n        // Gather bulb refs\n        const bulbs = [];\n        dirGroup.traverse(o => {\n          if (o?.userData?.bulbs) bulbs.push(o.userData.bulbs);\n        });\n        return { dirGroup, bulbs };\n      }\n\n      const ns = makeBulbSet('NS');\n      const ew = makeBulbSet('EW');\n      group.add(ns.dirGroup, ew.dirGroup);\n\n      cityGroup.add(group);\n      trafficLights.push({ group, dir: 'NS', bulbs: ns.bulbs, offset: offsetPhase });\n      trafficLights.push({ group, dir: 'EW', bulbs: ew.bulbs, offset: offsetPhase });\n\n      return group;\n    }\n\n    function setTrafficState(bulbList, state, intensity = 2.5) {\n      // state: 'red' | 'yellow' | 'green'\n      for (const bulbs of bulbList) {\n        bulbs.r.material.emissiveIntensity = (state === 'red') ? intensity : 0.0;\n        bulbs.y.material.emissiveIntensity = (state === 'yellow') ? intensity : 0.0;\n        bulbs.g.material.emissiveIntensity = (state === 'green') ? intensity : 0.0;\n      }\n    }\n\n    // Build Roads\n    function buildRoadNetwork() {\n      const g = new THREE.Group();\n      const { blocksX, blocksZ, blockSize, streetWidth } = CITY;\n\n      const spacingX = blockSize + streetWidth;\n      const spacingZ = blockSize + streetWidth;\n      const totalX = blocksX * spacingX + streetWidth;\n      const totalZ = blocksZ * spacingZ + streetWidth;\n      const originX = -totalX / 2 + streetWidth/2;\n      const originZ = -totalZ / 2 + streetWidth/2;\n\n      // Ground base\n      const groundGeo = new THREE.PlaneGeometry(totalX + 100, totalZ + 100);\n      const groundMat = new THREE.MeshStandardMaterial({\n        color: 0x2b2b2b,\n        roughness: 1.0,\n        metalness: 0.0\n      });\n      const ground = new THREE.Mesh(groundGeo, groundMat);\n      ground.rotation.x = -Math.PI / 2;\n      ground.position.y = -0.05;\n      ground.receiveShadow = true;\n      g.add(ground);\n\n      // Road material (repeat by length)\n      const roadMatV = new THREE.MeshStandardMaterial({\n        map: textures.road,\n        roughness: 0.95,\n        metalness: 0.05\n      });\n      roadMatV.map.repeat.set(1, blocksZ + 2);\n\n      const roadMatH = new THREE.MeshStandardMaterial({\n        map: textures.road.clone(),\n        roughness: 0.95,\n        metalness: 0.05\n      });\n      roadMatH.map.center.set(0.5, 0.5);\n      roadMatH.map.rotation = Math.PI / 2;\n      roadMatH.map.repeat.set(1, blocksX + 2);\n\n      // Sidewalk material\n      const sidewalkMat = new THREE.MeshStandardMaterial({\n        map: textures.sidewalk,\n        roughness: 0.9,\n        metalness: 0.05\n      });\n\n      // Vertical roads (along Z)\n      for (let i = 0; i <= blocksX; i++) {\n        const x = originX + i * spacingX;\n        const roadGeo = new THREE.BoxGeometry(streetWidth, 0.1, totalZ);\n        const road = new THREE.Mesh(roadGeo, roadMatV);\n        road.position.set(x, 0, 0);\n        road.receiveShadow = true;\n        g.add(road);\n\n        // Sidewalk edges alongside vertical road\n        const sidewalkGeo = new THREE.BoxGeometry(2, 0.2, totalZ);\n        const sw1 = new THREE.Mesh(sidewalkGeo, sidewalkMat);\n        sw1.position.set(x - streetWidth/2 - 1, 0.05, 0);\n        const sw2 = new THREE.Mesh(sidewalkGeo, sidewalkMat);\n        sw2.position.set(x + streetWidth/2 + 1, 0.05, 0);\n        g.add(sw1, sw2);\n      }\n\n      // Horizontal roads (along X)\n      for (let j = 0; j <= blocksZ; j++) {\n        const z = originZ + j * spacingZ;\n        const roadGeo = new THREE.BoxGeometry(totalX, 0.1, streetWidth);\n        const road = new THREE.Mesh(roadGeo, roadMatH);\n        road.position.set(0, 0, z);\n        road.receiveShadow = true;\n        g.add(road);\n\n        // Sidewalk edges alongside horizontal road\n        const sidewalkGeo = new THREE.BoxGeometry(totalX, 0.2, 2);\n        const sw1 = new THREE.Mesh(sidewalkGeo, sidewalkMat);\n        sw1.position.set(0, 0.05, z - streetWidth/2 - 1);\n        const sw2 = new THREE.Mesh(sidewalkGeo, sidewalkMat);\n        sw2.position.set(0, 0.05, z + streetWidth/2 + 1);\n        g.add(sw1, sw2);\n      }\n\n      cityGroup.add(g);\n\n      return { totalX, totalZ, originX, originZ, spacingX, spacingZ };\n    }\n\n    // Build buildings\n    let buildingMeshes = [];\n    function buildBuildings(layoutInfo) {\n      const { blocksX, blocksZ, blockSize, streetWidth, marginInsideBlock, buildingMin, buildingMax, buildingHeightMin, buildingHeightMax, buildingColorPalette } = CITY;\n      const { originX, originZ, spacingX, spacingZ } = layoutInfo;\n\n      const palette = buildingColorPalette.map(c => new THREE.Color(c));\n      const group = new THREE.Group();\n\n      for (let ix = 0; ix < blocksX; ix++) {\n        for (let iz = 0; iz < blocksZ; iz++) {\n          // Randomly decide if this block is a park/empty\n          const blockCenterX = originX + ix * spacingX + streetWidth/2 + blockSize/2;\n          const blockCenterZ = originZ + iz * spacingZ + streetWidth/2 + blockSize/2;\n\n          const isPark = rng() < 0.10;\n          const clusterCount = isPark ? 0 : Math.floor(seededRand(buildingMin, buildingMax + 1));\n          const used = [];\n\n          for (let k = 0; k < clusterCount; k++) {\n            const w = Math.floor(seededRand(6, Math.max(8, blockSize/2)));\n            const d = Math.floor(seededRand(6, Math.max(8, blockSize/2)));\n            const h = Math.floor(seededRand(buildingHeightMin, buildingHeightMax));\n            const x = blockCenterX + seededRand(-blockSize/2 + marginInsideBlock, blockSize/2 - marginInsideBlock);\n            const z = blockCenterZ + seededRand(-blockSize/2 + marginInsideBlock, blockSize/2 - marginInsideBlock);\n\n            // Avoid too much overlap\n            let skip = false;\n            for (const u of used) {\n              if (Math.abs(u.x - x) < (u.w + w) * 0.6 && Math.abs(u.z - z) < (u.d + d) * 0.6) {\n                skip = true; break;\n              }\n            }\n            if (skip) continue;\n            used.push({ x, z, w, d });\n\n            const geo = new THREE.BoxGeometry(w, h, d);\n            const mat = materials.building.clone();\n            const color = palette[(Math.random() * palette.length) | 0].clone();\n            // Slight variation with seed\n            const cshift = seededRand(-0.05, 0.05);\n            color.offsetHSL(0, 0, cshift);\n            mat.color = color;\n            const mesh = new THREE.Mesh(geo, mat);\n            mesh.position.set(x, h / 2, z);\n            mesh.castShadow = false;\n            mesh.receiveShadow = true;\n            group.add(mesh);\n            buildingMeshes.push(mesh);\n          }\n\n          // Optional simple park: grass patch if no buildings\n          if (isPark) {\n            const gPlane = new THREE.Mesh(\n              new THREE.PlaneGeometry(blockSize - 2, blockSize - 2),\n              new THREE.MeshStandardMaterial({ color: 0x335533, roughness: 1.0, metalness: 0.0 })\n            );\n            gPlane.rotation.x = -Math.PI/2;\n            gPlane.position.set(blockCenterX, 0.02, blockCenterZ);\n            group.add(gPlane);\n          }\n        }\n      }\n\n      cityGroup.add(group);\n    }\n\n    // Build traffic lights at intersections\n    function buildTrafficLights(layoutInfo) {\n      const { blocksX, blocksZ, streetWidth, originX, originZ, spacingX, spacingZ } = layoutInfo;\n      const intersections = new THREE.Group();\n      for (let i = 0; i <= blocksX; i++) {\n        for (let j = 0; j <= blocksZ; j++) {\n          const x = originX + i * spacingX;\n          const z = originZ + j * spacingZ;\n          // Offset different intersections slightly for traffic phase variety\n          const offset = (i + j) * 0.7;\n          createTrafficLightAt(new THREE.Vector3(x, 0, z), offset);\n        }\n      }\n      cityGroup.add(intersections);\n    }\n\n    // Materials setup\n    function setupMaterials(seed) {\n      textures.road = makeRoadTexture();\n      textures.sidewalk = makeSidewalkTexture();\n      textures.windows = makeWindowEmissiveTexture(seed);\n\n      materials.building = new THREE.MeshStandardMaterial({\n        color: 0xbababa,\n        roughness: 0.85,\n        metalness: 0.1,\n        emissive: new THREE.Color(0xfff4d2),\n        emissiveMap: textures.windows,\n        emissiveIntensity: 0.0\n      });\n\n      materials.road = new THREE.MeshStandardMaterial({\n        map: textures.road,\n        roughness: 0.95,\n        metalness: 0.05\n      });\n\n      materials.sidewalk = new THREE.MeshStandardMaterial({\n        map: textures.sidewalk,\n        roughness: 0.9,\n        metalness: 0.05\n      });\n\n      materials.trafficPole = new THREE.MeshStandardMaterial({\n        color: 0x444444,\n        roughness: 0.8,\n        metalness: 0.4\n      });\n\n      materials.trafficBlack = new THREE.MeshStandardMaterial({\n        color: 0x111111,\n        roughness: 0.9,\n        metalness: 0.2\n      });\n\n      const makeBulbMaterial = (hex) => new THREE.MeshStandardMaterial({\n        color: hex,\n        emissive: new THREE.Color(hex),\n        emissiveIntensity: 0.0,\n        roughness: 0.5,\n        metalness: 0.0\n      });\n      materials.trafficRed = makeBulbMaterial(0xff2b2b);\n      materials.trafficYellow = makeBulbMaterial(0xfff06a);\n      materials.trafficGreen = makeBulbMaterial(0x5aff6a);\n    }\n\n    // Build entire city\n    function buildCity(seed) {\n      // Clear previous\n      for (let i = cityGroup.children.length - 1; i >= 0; i--) {\n        const obj = cityGroup.children[i];\n        obj.traverse(o => {\n          if (o.isMesh) {\n            o.geometry?.dispose?.();\n            // Shared textures are reused\n          }\n        });\n        cityGroup.remove(obj);\n      }\n      buildingMeshes = [];\n      trafficLights.length = 0;\n\n      setupMaterials(seed);\n\n      const layout = buildRoadNetwork();\n      buildBuildings(layout);\n      buildTrafficLights(layout);\n\n      // Set minimap camera bounds based on city size\n      const pad = 40;\n      miniMapCamera.left = - (layout.totalX / 2 + pad);\n      miniMapCamera.right = (layout.totalX / 2 + pad);\n      miniMapCamera.top = (layout.totalZ / 2 + pad);\n      miniMapCamera.bottom = - (layout.totalZ / 2 + pad);\n      miniMapCamera.position.set(0, 1000, 0);\n      miniMapCamera.updateProjectionMatrix();\n    }\n\n    // Day/Night cycle\n    const cycle = {\n      secondsPerDay: 90, // one full day-night in this many seconds\n      lastEnvUpdate: -999,\n      envUpdateInterval: 0.4\n    };\n\n    function getDayProgress(time) {\n      return (time % cycle.secondsPerDay) / cycle.secondsPerDay; // 0..1\n    }\n\n    function updateDayNight(time) {\n      const p = getDayProgress(time);\n      // Map progress to elevation and azimuth\n      // Elevation: -5 at night lowest, to 60 at noon highest (deg)\n      // Use sine curve for smooth daylight\n      const elevation = -5 + 65 * Math.max(-1, Math.sin(p * Math.PI * 2));\n      // Azimuth sweeps slowly\n      const azimuth = 180 + p * 360;\n\n      setSkyUniforms(skyBG, elevation, azimuth);\n      setSkyUniforms(skyEnv, elevation, azimuth);\n\n      const isDay = elevation > 0;\n      const daylightFactor = THREE.MathUtils.clamp((elevation + 5) / 65, 0, 1);\n\n      ambient.intensity = 0.12 + 0.55 * daylightFactor;\n      sunLight.intensity = 0.2 + 2.0 * Math.max(0, daylightFactor);\n      sunLight.position.setScalar(1).multiply(skyBG.material.uniforms['sunPosition'].value).multiplyScalar(500);\n\n      // Building emissive stronger at night\n      const nightFactor = 1.0 - daylightFactor;\n      const emissiveIntensity = THREE.MathUtils.lerp(0.0, 1.6, Math.pow(nightFactor, 0.9));\n      for (const m of buildingMeshes) {\n        m.material.emissiveIntensity = emissiveIntensity;\n      }\n\n      // Slight exposure variation\n      renderer.toneMappingExposure = 0.7 + 0.8 * daylightFactor;\n\n      // Update environment periodically (expensive)\n      if (time - cycle.lastEnvUpdate > cycle.envUpdateInterval) {\n        updateEnvironment();\n        cycle.lastEnvUpdate = time;\n      }\n\n      // Update time label (HH:MM approx)\n      const hours = Math.floor(p * 24);\n      const minutes = Math.floor((p * 24 - hours) * 60);\n      timeLabel.textContent = `Time: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;\n    }\n\n    // Traffic lights animation\n    function updateTrafficLights(time) {\n      const period = 20.0; // total cycle seconds\n      const greenTime = 8.0;\n      const yellowTime = 2.0;\n      const redTime = greenTime + yellowTime; // 10\n\n      for (const tl of trafficLights) {\n        const t = (time + tl.offset) % period;\n        let state = 'red';\n        if (tl.dir === 'NS') {\n          if (t < greenTime) state = 'green';\n          else if (t < greenTime + yellowTime) state = 'yellow';\n          else state = 'red';\n        } else {\n          const t2 = (t - redTime + period) % period;\n          if (t2 < greenTime) state = 'green';\n          else if (t2 < greenTime + yellowTime) state = 'yellow';\n          else state = 'red';\n        }\n        setTrafficState(tl.bulbs, state, 2.5);\n      }\n    }\n\n    // Seed management\n    function setSeed(seed) {\n      rng = createRNG(seed);\n    }\n\n    function randomSeed() {\n      // generate a simple random seed string\n      const s = Math.random().toString(36).slice(2, 10);\n      return s;\n    }\n\n    function regenerateFromSeed(seed) {\n      setSeed(seed);\n      buildCity(seed);\n      // Position camera to a sensible starting spot\n      camera.position.set(0.6, 0.4, 0.6).multiplyScalar(Math.max(CITY.blocksX, CITY.blocksZ) * (CITY.blockSize + CITY.streetWidth));\n      camera.position.y = 120;\n      camera.lookAt(0, 0, 0);\n    }\n\n    // UI wiring\n    regenBtn.addEventListener('click', () => {\n      const seed = (seedInput.value || '').trim() || 'default';\n      location.hash = encodeURIComponent(seed);\n      regenerateFromSeed(seed);\n    });\n    randomBtn.addEventListener('click', () => {\n      const seed = randomSeed();\n      seedInput.value = seed;\n      location.hash = encodeURIComponent(seed);\n      regenerateFromSeed(seed);\n    });\n\n    // Initialize with URL hash or default\n    function initialSeed() {\n      const h = decodeURIComponent(location.hash.replace(/^#/, '')).trim();\n      return h || 'city-' + (new Date().getFullYear());\n    }\n\n    // Resize handling and mini-map viewport\n    function onResize() {\n      const w = window.innerWidth;\n      const h = window.innerHeight;\n      renderer.setSize(w, h);\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n    }\n    window.addEventListener('resize', onResize);\n\n    // Render loop\n    const clock = new THREE.Clock();\n\n    function renderMiniMap() {\n      const w = window.innerWidth;\n      const h = window.innerHeight;\n      const size = Math.min(220, Math.floor(Math.min(w, h) * 0.28));\n      const margin = 16;\n\n      renderer.clearDepth(); // keep color, clear depth\n      renderer.setScissorTest(true);\n      renderer.setViewport(w - size - margin, margin, size, size);\n      renderer.setScissor(w - size - margin, margin, size, size);\n      renderer.setClearColor(0x000000, 0.0);\n      // Make camera look straight down\n      miniMapCamera.lookAt(0, 0, 0);\n      renderer.render(scene, miniMapCamera);\n      renderer.setScissorTest(false);\n    }\n\n    function animate() {\n      const dt = clock.getDelta();\n      const elapsed = clock.elapsedTime;\n\n      controls.movementSpeed = (window.navigator.platform.includes('Mac') ? 70 : 60) * (window?.event?.shiftKey ? 2.0 : 1.0);\n      controls.update(dt);\n\n      updateDayNight(elapsed);\n      updateTrafficLights(elapsed);\n\n      renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);\n      renderer.setScissorTest(false);\n      renderer.setClearColor(0x000000, 1);\n      renderer.render(scene, camera);\n\n      renderMiniMap();\n\n      requestAnimationFrame(animate);\n    }\n\n    // Boot\n    (function start() {\n      const seed = initialSeed();\n      seedInput.value = seed;\n      setSeed(seed);\n      setupMaterials(seed);\n      const layout = buildRoadNetwork(); // prebuild to set minimap\n      // Rebuild everything from seed to ensure determinism for buildings/lights\n      regenerateFromSeed(seed);\n\n      // Initial sky/environment set\n      setSkyUniforms(skyBG, 30, 180);\n      setSkyUniforms(skyEnv, 30, 180);\n      updateEnvironment();\n\n      onResize();\n      animate();\n    })();\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 232.90528988838196,
    "status": "success",
    "timestamp": "2025-08-29 17:42:01"
  },
  {
    "test_name": "terrain_flight_mode",
    "prompt": "Create a complete HTML file with Three.js that generates procedural terrain using heightmaps or Perlin noise with rivers, trees (instanced meshes), and LOD. Add a simple 'drone/plane' controller to fly above terrain with pitch/roll/yaw, speed boost, and collision avoidance. The HTML file should be self-contained with Three.js loaded from CDN and include all terrain generation code inline. Save the output as 'terrain_flight.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Procedural Terrain Flight - Three.js</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body { margin: 0; padding: 0; overflow: hidden; background: #0a0d12; }\n    #hud {\n      position: absolute; left: 10px; top: 10px; color: #e8f0ff; font: 12px/1.4 -apple-system, Segoe UI, Roboto, Arial, sans-serif;\n      background: rgba(0,0,0,0.35); padding: 10px 12px; border-radius: 8px; user-select: none;\n      box-shadow: 0 4px 18px rgba(0,0,0,0.3); backdrop-filter: blur(6px);\n      max-width: 380px;\n    }\n    #hud .title { font-size: 14px; font-weight: 700; letter-spacing: 0.4px; margin-bottom: 6px; }\n    #hud .row { opacity: 0.92; }\n    #hud .kbd { display: inline-block; padding: 1px 6px; margin: 1px 2px; border-radius: 4px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.18); }\n    #status {\n      position: absolute; right: 10px; top: 10px; color: #cfe3ff; font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\n      background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 6px; white-space: pre; text-align: right; min-width: 160px;\n      box-shadow: 0 4px 18px rgba(0,0,0,0.3); backdrop-filter: blur(6px);\n    }\n    #credit {\n      position: absolute; right: 10px; bottom: 10px; color: #9bb6ff; opacity: 0.8; font: 11px/1.25 system-ui, Arial, sans-serif;\n      background: rgba(0,0,0,0.25); padding: 6px 8px; border-radius: 6px;\n    }\n    a { color: #b4d1ff; text-decoration: none; border-bottom: 1px dotted rgba(180,209,255,0.6); }\n    a:hover { color: #e7f1ff; border-bottom-color: rgba(231,241,255,0.9); }\n    canvas { display: block; }\n  </style>\n</head>\n<body>\n  <div id=\"hud\">\n    <div class=\"title\">Procedural Terrain Flight</div>\n    <div class=\"row\">- Terrain: Fractal noise, carved river, instanced trees, LOD</div>\n    <div class=\"row\">- Fly a small drone/plane with collision avoidance</div>\n    <div class=\"row\" style=\"margin-top:6px\"><b>Controls</b></div>\n    <div class=\"row\">Throttle: <span class=\"kbd\">W</span> accelerate, <span class=\"kbd\">S</span> brake</div>\n    <div class=\"row\">Yaw: <span class=\"kbd\">\u2190</span> / <span class=\"kbd\">\u2192</span></div>\n    <div class=\"row\">Pitch: <span class=\"kbd\">\u2191</span> / <span class=\"kbd\">\u2193</span></div>\n    <div class=\"row\">Roll: <span class=\"kbd\">A</span> / <span class=\"kbd\">D</span></div>\n    <div class=\"row\">Boost: <span class=\"kbd\">Shift</span> | Toggle camera: <span class=\"kbd\">C</span></div>\n    <div class=\"row\">Pause: <span class=\"kbd\">P</span> | Reset: <span class=\"kbd\">R</span></div>\n  </div>\n  <div id=\"status\"></div>\n  <div id=\"credit\">Three.js from CDN \u2022 Save this file as: terrain_flight.html</div>\n\n  <script src=\"https://unpkg.com/three@0.160.0/build/three.min.js\"></script>\n  <script>\n  (() => {\n    'use strict';\n\n    // ---------- Parameters ----------\n    const WORLD_SIZE = 2000;           // Size of the terrain plane in world units\n    const BASE_SEGMENTS = 256;         // Base grid resolution (high LOD) per side\n    const TREE_COUNT = 3000;           // Number of trees (instanced)\n    const RIVER_STEP = 16;             // Distance between river path points\n    const RIVER_WIDTH = 36;            // Visual river width (surface)\n    const RIVER_VALLEY_WIDTH = 60;     // Valley width used to carve terrain\n    const RIVER_VALLEY_DEPTH = 18;     // How deep to carve the river valley\n    const NOISE_ELEVATION = 120;       // Max terrain elevation amplitude\n    const TERRAIN_OFFSET_Y = -10;      // Shifts whole terrain up/down\n    const CLEARANCE_BASE = 8;          // Base clearance above terrain for craft\n    const CLEARANCE_TREE_EXTRA = 8;    // Extra clearance to avoid trees\n    const LOOKAHEAD_DIST = 40;         // Collision look-ahead forward distance\n    const BOUNDS_MARGIN = 40;          // Margin before turning back at world edge\n\n    // ---------- Renderer, Scene, Camera ----------\n    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setSize(innerWidth, innerHeight);\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.1;\n    document.body.appendChild(renderer.domElement);\n\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x82a5d6);\n    scene.fog = new THREE.FogExp2(0x7ea2cf, 0.0008);\n\n    const camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 5000);\n    camera.position.set(0, 40, 100);\n\n    // ---------- Lights ----------\n    const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x32423a, 0.85);\n    scene.add(hemi);\n\n    const sun = new THREE.DirectionalLight(0xfff2cf, 0.9);\n    sun.position.set(-300, 400, 200);\n    sun.castShadow = false;\n    scene.add(sun);\n\n    // ---------- Random & Noise ----------\n    // Seeded PRNG\n    const seed = (Date.now() ^ 0x9e3779b9) >>> 0;\n    function mulberry32(a) {\n      return function() {\n        let t = a += 0x6D2B79F5;\n        t = Math.imul(t ^ (t >>> 15), t | 1);\n        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n      }\n    }\n    const rnd = mulberry32(seed);\n\n    // 2D value noise with smooth interpolation + fractal Brownian motion\n    function hash2i(x, y) {\n      // Integer hash -> 32-bit unsigned\n      let h = x * 374761393 + y * 668265263; // large primes\n      h = (h ^ (h >>> 13)) >>> 0;\n      h = Math.imul(h, 1274126177) >>> 0;\n      return (h ^ (h >>> 16)) >>> 0;\n    }\n    function rand2i(x, y) {\n      return (hash2i(x, y) / 4294967296) * 2 - 1; // [-1,1]\n    }\n    function smoothstep(t) {\n      return t * t * (3 - 2 * t);\n    }\n    function lerp(a, b, t) { return a + (b - a) * t; }\n\n    function valueNoise2D(x, y) {\n      const xi = Math.floor(x), yi = Math.floor(y);\n      const xf = x - xi, yf = y - yi;\n      const r00 = rand2i(xi, yi);\n      const r10 = rand2i(xi + 1, yi);\n      const r01 = rand2i(xi, yi + 1);\n      const r11 = rand2i(xi + 1, yi + 1);\n      const u = smoothstep(xf);\n      const v = smoothstep(yf);\n      const x1 = lerp(r00, r10, u);\n      const x2 = lerp(r01, r11, u);\n      return lerp(x1, x2, v); // roughly [-1,1]\n    }\n    function fbm2(x, y, octaves = 6, lacunarity = 2.0, gain = 0.5) {\n      let amp = 1.0, freq = 1.0, sum = 0.0, norm = 0.0;\n      for (let i = 0; i < octaves; i++) {\n        sum += valueNoise2D(x * freq, y * freq) * amp;\n        norm += amp;\n        amp *= gain;\n        freq *= lacunarity;\n      }\n      return sum / norm; // [-1,1] approximately\n    }\n\n    // ---------- River Path Generation ----------\n    function genRiverPath() {\n      // Start on left edge, random Z within bounds\n      const half = WORLD_SIZE * 0.5;\n      let x = -half;\n      let z = (rnd() * 0.6 + 0.2) * WORLD_SIZE - half; // within middle 60%\n      let theta = (rnd() - 0.5) * 0.4; // small initial deviation\n      const pts = [];\n      const maxSteps = Math.ceil(WORLD_SIZE / RIVER_STEP) + 200;\n      const meander = 0.25;\n      const turnBias = (rnd() - 0.5) * 0.1;\n\n      let steps = 0;\n      while (x < half && steps < maxSteps) {\n        pts.push(new THREE.Vector2(x, z));\n        // Meander using fractal noise\n        const t = steps * 0.08;\n        const n = fbm2(t + seed * 0.001, (t - 7.123) * 0.7, 3, 2, 0.6);\n        theta += (n + turnBias) * 0.05;\n        theta = THREE.MathUtils.clamp(theta, -0.8, 0.8);\n\n        // Step forward\n        x += Math.cos(theta) * RIVER_STEP;\n        z += Math.sin(theta) * RIVER_STEP;\n\n        // Keep within bounds\n        const zClamp = half - 20;\n        if (z < -zClamp) { z = -zClamp; theta = 0.1; }\n        if (z >  zClamp) { z =  zClamp; theta = -0.1; }\n\n        steps++;\n      }\n      // Ensure right edge endpoint\n      pts.push(new THREE.Vector2(half, z));\n      return pts;\n    }\n\n    // Distance squared from point p to segment ab (2D)\n    function distSqPointToSegment(p, a, b) {\n      const abx = b.x - a.x, abz = b.y - a.y; // using Vector2 where .y is z\n      const apx = p.x - a.x, apz = p.y - a.y;\n      const ab2 = abx * abx + abz * abz;\n      if (ab2 <= 1e-6) {\n        const dx = apx, dz = apz; return dx * dx + dz * dz;\n      }\n      const t = THREE.MathUtils.clamp((apx * abx + apz * abz) / ab2, 0, 1);\n      const cx = a.x + t * abx, cz = a.y + t * abz;\n      const dx = p.x - cx, dz = p.y - cz;\n      return dx * dx + dz * dz;\n    }\n\n    // ---------- Heightfield Generation ----------\n    const gridN = BASE_SEGMENTS + 1;\n    const heights = new Float32Array(gridN * gridN);\n    const halfSize = WORLD_SIZE * 0.5;\n\n    // Pre-generate river path\n    const riverPath = genRiverPath();\n\n    // Generate base heightfield from FBM noise\n    const baseFreq = 1.0 / 260; // base frequency scaled to world size\n    for (let j = 0; j < gridN; j++) {\n      for (let i = 0; i < gridN; i++) {\n        const idx = j * gridN + i;\n        const x = -halfSize + (i / BASE_SEGMENTS) * WORLD_SIZE;\n        const z = -halfSize + (j / BASE_SEGMENTS) * WORLD_SIZE;\n\n        // Multi-layer noise: base, ridges, low-frequency bias\n        const n1 = fbm2(x * baseFreq, z * baseFreq, 5, 2.0, 0.5);\n        const n2 = fbm2(x * baseFreq * 0.3, z * baseFreq * 0.3, 3, 2.2, 0.55);\n        const ridge = Math.abs(fbm2(x * baseFreq * 1.9, z * baseFreq * 1.9, 4, 2.0, 0.5));\n        let h = n1 * 0.65 + n2 * 0.25 + ridge * 0.1;\n\n        heights[idx] = h;\n      }\n    }\n\n    // Normalize heights to [-1,1] then scale to elevation\n    (function normalizeHeights() {\n      let min = Infinity, max = -Infinity;\n      for (let k = 0; k < heights.length; k++) { const v = heights[k]; if (v < min) min = v; if (v > max) max = v; }\n      const scale = max - min > 1e-6 ? 2.0 / (max - min) : 1.0;\n      const bias = -1 - min * scale;\n      for (let k = 0; k < heights.length; k++) heights[k] = heights[k] * scale + bias;\n    })();\n\n    // Carve river valley by subtracting a Gaussian profile near river path\n    (function carveRiver() {\n      const sigma = RIVER_VALLEY_WIDTH * 0.55;\n      const twoSigma2 = 2 * sigma * sigma;\n      // For optimization, precompute path segments\n      const segments = [];\n      for (let i = 0; i < riverPath.length - 1; i++) {\n        segments.push([riverPath[i], riverPath[i + 1]]);\n      }\n      for (let j = 0; j < gridN; j++) {\n        for (let i = 0; i < gridN; i++) {\n          const idx = j * gridN + i;\n          const x = -halfSize + (i / BASE_SEGMENTS) * WORLD_SIZE;\n          const z = -halfSize + (j / BASE_SEGMENTS) * WORLD_SIZE;\n          const p = new THREE.Vector2(x, z);\n          // Find minimum squared distance to path segments\n          let d2 = Infinity;\n          for (let s = 0; s < segments.length; s++) {\n            const [a, b] = segments[s];\n            const dsq = distSqPointToSegment(p, a, b);\n            if (dsq < d2) d2 = dsq;\n          }\n          const d = Math.sqrt(d2);\n          const valley = RIVER_VALLEY_DEPTH * Math.exp(- (d * d) / twoSigma2);\n          heights[idx] -= (valley / NOISE_ELEVATION); // subtract in normalized space\n        }\n      }\n      // Slight smoothing pass to reduce ridges around valley\n      const tmp = heights.slice(0);\n      for (let j = 1; j < gridN - 1; j++) {\n        for (let i = 1; i < gridN - 1; i++) {\n          const idx = j * gridN + i;\n          const sum = (\n            tmp[idx] * 4 +\n            tmp[idx - 1] + tmp[idx + 1] + tmp[idx - gridN] + tmp[idx + gridN]\n          ) / 8;\n          heights[idx] = THREE.MathUtils.lerp(tmp[idx], sum, 0.35);\n        }\n      }\n    })();\n\n    // Scale heights to world elevation and offset\n    for (let k = 0; k < heights.length; k++) {\n      heights[k] = heights[k] * NOISE_ELEVATION + TERRAIN_OFFSET_Y;\n    }\n\n    // ----------- Height sampling (bilinear) -----------\n    function getHeightAt(x, z) {\n      // Convert world (x,z) to grid domain\n      const gx = (x + halfSize) / WORLD_SIZE * BASE_SEGMENTS;\n      const gz = (z + halfSize) / WORLD_SIZE * BASE_SEGMENTS;\n      const i = Math.floor(gx), j = Math.floor(gz);\n      const tx = THREE.MathUtils.clamp(gx - i, 0, 1);\n      const tz = THREE.MathUtils.clamp(gz - j, 0, 1);\n      const i0 = THREE.MathUtils.clamp(i, 0, BASE_SEGMENTS);\n      const j0 = THREE.MathUtils.clamp(j, 0, BASE_SEGMENTS);\n      const i1 = THREE.MathUtils.clamp(i + 1, 0, BASE_SEGMENTS);\n      const j1 = THREE.MathUtils.clamp(j + 1, 0, BASE_SEGMENTS);\n      const idx00 = j0 * gridN + i0;\n      const idx10 = j0 * gridN + i1;\n      const idx01 = j1 * gridN + i0;\n      const idx11 = j1 * gridN + i1;\n      const h00 = heights[idx00], h10 = heights[idx10], h01 = heights[idx01], h11 = heights[idx11];\n      const hx0 = lerp(h00, h10, tx);\n      const hx1 = lerp(h01, h11, tx);\n      return lerp(hx0, hx1, tz);\n    }\n    function getSlopeAt(x, z) {\n      const e = 1.5; // small sample offset\n      const h = getHeightAt(x, z);\n      const hx = getHeightAt(x + e, z);\n      const hz = getHeightAt(x, z + e);\n      const dhdx = (hx - h) / e;\n      const dhdz = (hz - h) / e;\n      return Math.sqrt(dhdx * dhdx + dhdz * dhdz);\n    }\n\n    // ----------- Terrain Geometry (LOD with vertex colors) -----------\n    function buildTerrainGeometry(segments) {\n      const geo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, segments, segments);\n      geo.rotateX(-Math.PI / 2);\n\n      const pos = geo.attributes.position;\n      const colors = new Float32Array(pos.count * 3);\n      const color = new THREE.Color();\n\n      for (let v = 0; v < pos.count; v++) {\n        const vx = pos.getX(v);\n        const vz = pos.getZ(v);\n        const h = getHeightAt(vx, vz);\n        pos.setY(v, h);\n\n        const slope = getSlopeAt(vx, vz);\n\n        // Color ramp based on height and slope\n        // Low: river banks -> wet dark\n        // Mid: grass\n        // High/steep: rock, very high: snow\n        const hNorm = (h - (TERRAIN_OFFSET_Y - NOISE_ELEVATION)) / (NOISE_ELEVATION * 2.2);\n        let r = 0, g = 0, b = 0;\n        if (h < -5) {\n          color.setRGB(0.18, 0.24, 0.28); // darker lowlands\n        } else if (slope > 0.8) {\n          color.setRGB(0.45, 0.43, 0.40); // rocky\n        } else {\n          // Blend grass to snow\n          const t = THREE.MathUtils.smoothstep(hNorm, 0.2, 0.8);\n          const grass = new THREE.Color(0.33, 0.50, 0.28);\n          const dirt = new THREE.Color(0.38, 0.34, 0.26);\n          const snow = new THREE.Color(0.92, 0.94, 0.96);\n          const base = dirt.lerp(grass, 0.7);\n          color.copy(base).lerp(snow, Math.pow(t, 2.2));\n        }\n        colors[v * 3 + 0] = color.r;\n        colors[v * 3 + 1] = color.g;\n        colors[v * 3 + 2] = color.b;\n      }\n      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n      geo.computeVertexNormals();\n      return geo;\n    }\n\n    const terrainMaterial = new THREE.MeshStandardMaterial({\n      vertexColors: true,\n      roughness: 0.95,\n      metalness: 0.0,\n      envMapIntensity: 0.1\n    });\n\n    const terrainLOD = new THREE.LOD();\n    const highGeo = buildTerrainGeometry(BASE_SEGMENTS);\n    const midGeo  = buildTerrainGeometry(128);\n    const lowGeo  = buildTerrainGeometry(64);\n    const highMesh = new THREE.Mesh(highGeo, terrainMaterial);\n    const midMesh  = new THREE.Mesh(midGeo, terrainMaterial);\n    const lowMesh  = new THREE.Mesh(lowGeo, terrainMaterial);\n    highMesh.receiveShadow = false; midMesh.receiveShadow = false; lowMesh.receiveShadow = false;\n\n    terrainLOD.addLevel(highMesh, 0);\n    terrainLOD.addLevel(midMesh, 800);\n    terrainLOD.addLevel(lowMesh, 1400);\n    scene.add(terrainLOD);\n\n    // ----------- River Mesh (ribbon following bed height) -----------\n    function buildRiverMesh() {\n      const positions = [];\n      const uvs = [];\n      const indices = [];\n      let index = 0;\n      const halfW = RIVER_WIDTH * 0.5;\n\n      for (let i = 0; i < riverPath.length; i++) {\n        const c = riverPath[i];\n        const prev = riverPath[Math.max(0, i - 1)];\n        const next = riverPath[Math.min(riverPath.length - 1, i + 1)];\n        const tx = next.x - prev.x;\n        const tz = next.y - prev.y;\n        const len = Math.hypot(tx, tz) || 1;\n        const nx = -tz / len; // 2D normal (x,z plane)\n        const nz =  tx / len;\n\n        const cx = c.x;\n        const cz = c.y;\n\n        const centerH = getHeightAt(cx, cz);\n        const waterY = centerH + 0.6; // slightly above bed\n\n        // Left and right edges\n        const lx = cx + nx * halfW;\n        const lz = cz + nz * halfW;\n        const rx = cx - nx * halfW;\n        const rz = cz - nz * halfW;\n\n        positions.push(lx, waterY, lz);\n        positions.push(rx, waterY, rz);\n\n        uvs.push(0, i / (riverPath.length - 1));\n        uvs.push(1, i / (riverPath.length - 1));\n\n        if (i < riverPath.length - 1) {\n          indices.push(index, index + 1, index + 2);\n          indices.push(index + 1, index + 3, index + 2);\n        }\n        index += 2;\n      }\n\n      const geo = new THREE.BufferGeometry();\n      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n      geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n      geo.setIndex(indices);\n      geo.computeVertexNormals();\n\n      const mat = new THREE.MeshPhysicalMaterial({\n        color: 0x3aa0ff,\n        transmission: 0.0,\n        opacity: 0.65,\n        transparent: true,\n        roughness: 0.25,\n        metalness: 0.0,\n        reflectivity: 0.2,\n        clearcoat: 0.6,\n        clearcoatRoughness: 0.7\n      });\n\n      const mesh = new THREE.Mesh(geo, mat);\n      mesh.renderOrder = 1;\n      return mesh;\n    }\n    const riverMesh = buildRiverMesh();\n    scene.add(riverMesh);\n\n    // ----------- Instanced Trees -----------\n    const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x6b4e2e, roughness: 0.9, metalness: 0.0 });\n    const treeLeafMaterial  = new THREE.MeshStandardMaterial({ color: 0x2f6f37, roughness: 0.8, metalness: 0.0 });\n\n    const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 3.2, 6);\n    const leafGeo = new THREE.ConeGeometry(1.6, 3.4, 8);\n    leafGeo.translate(0, 1.7, 0);\n\n    const trunks = new THREE.InstancedMesh(trunkGeo, treeTrunkMaterial, TREE_COUNT);\n    const leaves = new THREE.InstancedMesh(leafGeo, treeLeafMaterial, TREE_COUNT);\n    trunks.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n    leaves.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n\n    const dummy = new THREE.Object3D();\n\n    function isNearRiver(x, z, threshold) {\n      const p = new THREE.Vector2(x, z);\n      let d2min = Infinity;\n      for (let i = 0; i < riverPath.length - 1; i++) {\n        const a = riverPath[i], b = riverPath[i + 1];\n        const d2 = distSqPointToSegment(p, a, b);\n        if (d2 < d2min) d2min = d2;\n      }\n      return d2min < threshold * threshold;\n    }\n\n    let instanceIndex = 0;\n    for (let t = 0; t < TREE_COUNT * 4 && instanceIndex < TREE_COUNT; t++) {\n      const x = (rnd() * 2 - 1) * (WORLD_SIZE * 0.5 - 8);\n      const z = (rnd() * 2 - 1) * (WORLD_SIZE * 0.5 - 8);\n      const y = getHeightAt(x, z);\n\n      if (y < -4) continue; // avoid lowlands\n      if (isNearRiver(x, z, RIVER_WIDTH * 1.2)) continue; // keep banks clear\n      const slope = getSlopeAt(x, z);\n      if (slope > 0.6) continue; // too steep\n\n      // Random scale & slight variety\n      const scale = 0.8 + rnd() * 0.7;\n      const yaw = rnd() * Math.PI * 2;\n\n      // Trunk\n      dummy.position.set(x, y, z);\n      dummy.rotation.set(0, yaw, 0);\n      dummy.scale.setScalar(scale);\n      dummy.updateMatrix();\n      trunks.setMatrixAt(instanceIndex, dummy.matrix);\n\n      // Leaves (stacked for fuller canopies)\n      dummy.position.set(x, y + 2.6 * scale, z);\n      dummy.rotation.set(0, yaw, 0);\n      dummy.scale.setScalar(scale);\n      dummy.updateMatrix();\n      leaves.setMatrixAt(instanceIndex, dummy.matrix);\n\n      instanceIndex++;\n    }\n    trunks.count = instanceIndex;\n    leaves.count = instanceIndex;\n    scene.add(trunks);\n    scene.add(leaves);\n\n    // ----------- Craft (drone/plane) and Controller -----------\n    const craft = new THREE.Group();\n    scene.add(craft);\n\n    // Simple craft model\n    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x98c3ff, roughness: 0.5, metalness: 0.2 });\n    const accentMat = new THREE.MeshStandardMaterial({ color: 0xffc857, roughness: 0.6, metalness: 0.1 });\n\n    const fuselage = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 3.2, 10), bodyMat);\n    fuselage.rotation.z = Math.PI * 0.5;\n    fuselage.castShadow = false;\n    craft.add(fuselage);\n\n    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.6, 0.8, 10), accentMat);\n    nose.position.set(1.8, 0, 0);\n    nose.rotation.z = -Math.PI * 0.5;\n    craft.add(nose);\n\n    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.08), bodyMat);\n    tail.position.set(-1.5, 0.4, 0);\n    craft.add(tail);\n\n    const wing = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.06, 2.4), bodyMat);\n    wing.position.set(0, 0, 0);\n    wing.rotation.y = 0;\n    craft.add(wing);\n\n    const camHolder = new THREE.Object3D();\n    camHolder.position.set(0, 0.6, 0);\n    craft.add(camHolder);\n\n    // Camera modes\n    let firstPerson = false;\n    function updateCameraMode() {\n      if (firstPerson) {\n        camera.position.set(0.2, 0.3, 0.3);\n        camera.rotation.set(0, 0, 0);\n        camHolder.add(camera);\n      } else {\n        camera.position.set(-0.6, 0.9, -4.6);\n        camera.rotation.set(0, 0, 0);\n        camHolder.add(camera);\n      }\n    }\n    updateCameraMode();\n\n    craft.position.set(-WORLD_SIZE * 0.35, getHeightAt(-WORLD_SIZE * 0.35, 0) + 25, 0);\n    craft.rotation.set(0, Math.PI * 0.25, 0);\n\n    const controls = {\n      throttle: 12,\n      minSpeed: 4,\n      maxSpeed: 70,\n      yawRate: THREE.MathUtils.degToRad(60),\n      pitchRate: THREE.MathUtils.degToRad(50),\n      rollRate: THREE.MathUtils.degToRad(80),\n      damping: 0.98,\n      boost: false,\n      paused: false\n    };\n\n    const keys = Object.create(null);\n    addEventListener('keydown', (e) => {\n      keys[e.code] = true;\n      if (e.code === 'KeyC') { firstPerson = !firstPerson; updateCameraMode(); }\n      if (e.code === 'KeyP') { controls.paused = !controls.paused; }\n      if (e.code === 'KeyR') { resetCraft(); }\n    });\n    addEventListener('keyup', (e) => { keys[e.code] = false; });\n\n    function resetCraft() {\n      craft.position.set(0, getHeightAt(0, 0) + 30, -WORLD_SIZE * 0.2);\n      craft.rotation.set(0, 0, 0);\n      controls.throttle = 12;\n    }\n\n    // ----------- Update loop / physics-ish -----------\n    const clock = new THREE.Clock();\n    let lastTime = performance.now();\n\n    function step() {\n      const dt = Math.min(clock.getDelta(), 0.05);\n      const now = performance.now();\n      if (!controls.paused) update(dt);\n      terrainLOD.update(camera);\n      renderer.render(scene, camera);\n      lastTime = now;\n      requestAnimationFrame(step);\n    }\n\n    function update(dt) {\n      // Input handling\n      const boost = keys['ShiftLeft'] || keys['ShiftRight'];\n      controls.boost = boost;\n\n      // Throttle control\n      if (keys['KeyW']) controls.throttle += 20 * dt;\n      if (keys['KeyS']) controls.throttle -= 30 * dt;\n      const maxSpd = boost ? controls.maxSpeed * 1.6 : controls.maxSpeed;\n      controls.throttle = THREE.MathUtils.clamp(controls.throttle, controls.minSpeed, maxSpd);\n\n      // Orientation changes\n      const euler = new THREE.Euler().copy(craft.rotation);\n\n      if (keys['ArrowLeft'])  euler.y += controls.yawRate * dt;\n      if (keys['ArrowRight']) euler.y -= controls.yawRate * dt;\n\n      if (keys['ArrowUp'])    euler.x -= controls.pitchRate * dt;\n      if (keys['ArrowDown'])  euler.x += controls.pitchRate * dt;\n\n      if (keys['KeyA'])       euler.z += controls.rollRate * dt;\n      if (keys['KeyD'])       euler.z -= controls.rollRate * dt;\n\n      // Gentle auto-level roll\n      euler.z *= Math.pow(controls.damping, dt * 60);\n\n      // Clamp pitch to avoid extreme flips\n      euler.x = THREE.MathUtils.clamp(euler.x, -Math.PI / 2 + 0.15, Math.PI / 2 - 0.15);\n\n      craft.rotation.copy(euler);\n\n      // Move forward along local -Z (Three.js forward)\n      const forward = new THREE.Vector3(0, 0, -1).applyEuler(craft.rotation).normalize();\n      const speed = controls.throttle;\n      craft.position.addScaledVector(forward, speed * dt);\n\n      // Collision avoidance (terrain + basic tree clearance)\n      const groundHere = getHeightAt(craft.position.x, craft.position.z);\n      const clearance = CLEARANCE_BASE + CLEARANCE_TREE_EXTRA * 0.6; // basic margin\n      const minY = groundHere + clearance;\n      if (craft.position.y < minY) {\n        craft.position.y = minY;\n        // Pitch up gently if scraping ground\n        craft.rotation.x = THREE.MathUtils.lerp(craft.rotation.x, -0.1, 0.15);\n      }\n\n      // Look-ahead predictive check\n      const lookAhead = LOOKAHEAD_DIST + speed * 0.6;\n      const ahead = new THREE.Vector3().copy(craft.position).addScaledVector(forward, lookAhead);\n      const groundAhead = getHeightAt(ahead.x, ahead.z) + clearance + 2;\n      const pathY = craft.position.y + forward.y * lookAhead;\n      if (pathY < groundAhead) {\n        // Nudge up and yaw slightly following terrain normal\n        craft.rotation.x -= THREE.MathUtils.degToRad(30) * dt;\n        craft.position.y = THREE.MathUtils.lerp(craft.position.y, groundAhead + 2, 0.08);\n      }\n\n      // Keep within world bounds, turn back softly\n      const half = WORLD_SIZE * 0.5 - 2;\n      if (craft.position.x < -half + BOUNDS_MARGIN) craft.rotation.y += controls.yawRate * 0.8 * dt;\n      if (craft.position.x >  half - BOUNDS_MARGIN) craft.rotation.y -= controls.yawRate * 0.8 * dt;\n      if (craft.position.z < -half + BOUNDS_MARGIN) craft.rotation.y += controls.yawRate * 0.8 * dt;\n      if (craft.position.z >  half - BOUNDS_MARGIN) craft.rotation.y -= controls.yawRate * 0.8 * dt;\n\n      // Update status HUD\n      updateHUD(speed);\n    }\n\n    function updateHUD(speed) {\n      const pos = craft.position;\n      const yGround = getHeightAt(pos.x, pos.z);\n      const altitude = pos.y - yGround;\n      const el = document.getElementById('status');\n      el.textContent =\n        'Speed: ' + speed.toFixed(1) + (controls.boost ? ' (boost)' : '') + '\\n' +\n        'Alt:   ' + altitude.toFixed(1) + ' m\\n' +\n        'Pos:   ' + pos.x.toFixed(0) + ', ' + pos.y.toFixed(0) + ', ' + pos.z.toFixed(0) + '\\n' +\n        'Cam:   ' + (firstPerson ? 'First-person' : 'Chase') + '\\n' +\n        (controls.paused ? 'Paused' : '');\n    }\n\n    // ----------- Resize ----------\n    addEventListener('resize', () => {\n      camera.aspect = innerWidth / innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(innerWidth, innerHeight);\n    });\n\n    // ----------- Start loop -----------\n    requestAnimationFrame(step);\n  })();\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 165.55571508407593,
    "status": "success",
    "timestamp": "2025-08-29 17:44:46"
  },
  {
    "test_name": "product_configurator",
    "prompt": "Create a complete HTML file with Three.js that implements a 3D product configurator. Create a 3D model (like a car, chair, or phone) with color, material, texture, and part toggles. Add environment reflections, soft shadows, and camera bookmarks. Include export current config as JSON and PNG snapshot functionality. The HTML file should be self-contained with Three.js loaded from CDN and include all 3D models as procedural geometry. Save the output as 'product_configurator.html'.",
    "response": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Product Configurator - Office Chair (Three.js)</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\" />\n  <style>\n    html, body { margin: 0; padding: 0; height: 100%; background: #0e0f13; color: #eee; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Liberation Sans\", sans-serif; }\n    #app { position: fixed; inset: 0; display: grid; grid-template-columns: 320px 1fr; grid-template-rows: 100%; }\n    #ui {\n      background: linear-gradient(180deg, rgba(18,19,24,0.95), rgba(10,11,14,0.95));\n      backdrop-filter: blur(8px);\n      border-right: 1px solid rgba(255,255,255,0.07);\n      padding: 14px 16px 14px 16px;\n      overflow: auto;\n    }\n    #viewport { position: relative; }\n    #canvas { width: 100%; height: 100%; display: block; }\n    h1 { font-size: 16px; margin: 6px 0 12px; letter-spacing: 0.4px; color: #f5f6f8; }\n    h2 { font-size: 12px; margin: 16px 0 8px; text-transform: uppercase; color: #b9c0cc; letter-spacing: 0.12em; }\n    .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; }\n    .row label { width: 120px; font-size: 12px; color: #c9d1dd; }\n    .row input[type=\"color\"] { width: 44px; height: 28px; padding: 0; border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; background: transparent; }\n    .row select, .row input[type=\"range\"], .row input[type=\"number\"], .row button, .row input[type=\"checkbox\"] {\n      flex: 1; font-size: 13px; padding: 8px; border-radius: 8px;\n      background: #171a21; color: #e7ecf4; border: 1px solid rgba(255,255,255,0.12);\n    }\n    .row input[type=\"checkbox\"] { flex: 0 0 auto; width: 18px; height: 18px; margin: 0 8px 0 0; }\n    .row button { cursor: pointer; }\n    .row span.value { width: 48px; text-align: right; color: #9aa6b2; font-size: 12px; }\n    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }\n    .muted { color: #9aa6b2; font-size: 12px; }\n    .footer { position: sticky; bottom: 0; padding-top: 10px; background: linear-gradient(180deg, transparent, rgba(0,0,0,0.24) 50%, rgba(0,0,0,0.5)); }\n    .pill {\n      display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,0.06);\n      font-size: 12px; color: #c5cfdb; border: 1px solid rgba(255,255,255,0.08);\n    }\n    .bookmark-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }\n    .bookmark-buttons button { padding: 8px; }\n    .export-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }\n    .badge { font-size: 11px; color: #7ea0ff; background: rgba(126,160,255,0.12); border: 1px solid rgba(126,160,255,0.25); border-radius: 6px; padding: 2px 6px; }\n    .small { font-size: 11px; color: #aeb8c4; }\n    a { color: #9dc1ff; text-decoration: none; }\n  </style>\n</head>\n<body>\n<div id=\"app\">\n  <div id=\"ui\">\n    <h1>3D Product Configurator <span class=\"badge\">Office Chair</span></h1>\n\n    <h2>Upholstery</h2>\n    <div class=\"row\">\n      <label for=\"upholsteryColor\">Color</label>\n      <input id=\"upholsteryColor\" type=\"color\" value=\"#3b82f6\" />\n    </div>\n    <div class=\"row\">\n      <label for=\"upholsteryMaterial\">Material</label>\n      <select id=\"upholsteryMaterial\">\n        <option value=\"leather\">Leather (gloss)</option>\n        <option value=\"fabric\" selected>Fabric (matte)</option>\n        <option value=\"suede\">Suede (soft)</option>\n      </select>\n    </div>\n    <div class=\"row\">\n      <label for=\"upholsteryPattern\">Pattern</label>\n      <select id=\"upholsteryPattern\">\n        <option value=\"none\">None</option>\n        <option value=\"checker\">Checker</option>\n        <option value=\"stripes\">Stripes</option>\n        <option value=\"noise\">Noise</option>\n      </select>\n    </div>\n    <div class=\"row\">\n      <label for=\"patternScale\">Pattern Scale</label>\n      <input id=\"patternScale\" type=\"range\" min=\"0.5\" max=\"6\" step=\"0.5\" value=\"2\" />\n      <span class=\"value\" id=\"patternScaleValue\">2.0x</span>\n    </div>\n\n    <h2>Base & Frame</h2>\n    <div class=\"row\">\n      <label for=\"baseFinish\">Finish</label>\n      <select id=\"baseFinish\">\n        <option value=\"chrome\">Chrome</option>\n        <option value=\"black\" selected>Black</option>\n        <option value=\"white\">White</option>\n      </select>\n    </div>\n    <div class=\"row\">\n      <label for=\"metalRoughness\">Roughness</label>\n      <input id=\"metalRoughness\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.35\" />\n      <span class=\"value\" id=\"metalRoughnessValue\">0.35</span>\n    </div>\n    <div class=\"row\">\n      <label for=\"envIntensity\">Env. Reflections</label>\n      <input id=\"envIntensity\" type=\"range\" min=\"0\" max=\"3\" step=\"0.01\" value=\"1.0\" />\n      <span class=\"value\" id=\"envIntensityValue\">1.00</span>\n    </div>\n\n    <h2>Parts</h2>\n    <div class=\"row\">\n      <input id=\"toggleArmrests\" type=\"checkbox\" checked />\n      <label for=\"toggleArmrests\">Armrests</label>\n    </div>\n    <div class=\"row\">\n      <input id=\"toggleHeadrest\" type=\"checkbox\" />\n      <label for=\"toggleHeadrest\">Headrest</label>\n    </div>\n    <div class=\"row\">\n      <input id=\"toggleCasters\" type=\"checkbox\" checked />\n      <label for=\"toggleCasters\">Casters</label>\n    </div>\n\n    <h2>Camera</h2>\n    <div class=\"bookmark-buttons\">\n      <button data-bookmark=\"overview\">Overview</button>\n      <button data-bookmark=\"front\">Front</button>\n      <button data-bookmark=\"left\">Left</button>\n      <button data-bookmark=\"right\">Right</button>\n      <button data-bookmark=\"closeup\">Close-up</button>\n      <button data-bookmark=\"top\">Top</button>\n    </div>\n\n    <h2>Export</h2>\n    <div class=\"export-buttons\">\n      <button id=\"exportJSON\">Export JSON</button>\n      <button id=\"snapshotPNG\">Snapshot PNG</button>\n    </div>\n    <div class=\"row\">\n      <button id=\"reset\" title=\"Reset to defaults\">Reset</button>\n      <button id=\"randomize\" title=\"Randomize\">Randomize</button>\n    </div>\n\n    <div class=\"footer\">\n      <div class=\"pill\" style=\"margin-top: 10px;\">\n        <span>Tip: Hold left mouse to orbit, right to pan, scroll to zoom.</span>\n      </div>\n      <div class=\"muted\" style=\"margin-top: 10px;\">\n        Soft shadows, environment reflections, camera bookmarks, JSON export and PNG snapshot included. All geometry and textures are procedural; Three.js loaded from CDN.\n      </div>\n    </div>\n  </div>\n  <div id=\"viewport\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n</div>\n\n<script type=\"module\">\nimport * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';\nimport { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';\nimport { RoomEnvironment } from 'https://unpkg.com/three@0.160.1/examples/jsm/environments/RoomEnvironment.js';\n\nconst state = {\n  upholsteryColor: '#3b82f6',\n  upholsteryMaterial: 'fabric', // leather | fabric | suede\n  upholsteryPattern: 'none', // none | checker | stripes | noise\n  patternScale: 2,\n  baseFinish: 'black', // chrome | black | white\n  metalRoughness: 0.35,\n  envIntensity: 1.0,\n  parts: { armrests: true, headrest: false, casters: true },\n  cameraBookmark: 'overview'\n};\n\nconst ui = {\n  upholsteryColor: document.getElementById('upholsteryColor'),\n  upholsteryMaterial: document.getElementById('upholsteryMaterial'),\n  upholsteryPattern: document.getElementById('upholsteryPattern'),\n  patternScale: document.getElementById('patternScale'),\n  patternScaleValue: document.getElementById('patternScaleValue'),\n  baseFinish: document.getElementById('baseFinish'),\n  metalRoughness: document.getElementById('metalRoughness'),\n  metalRoughnessValue: document.getElementById('metalRoughnessValue'),\n  envIntensity: document.getElementById('envIntensity'),\n  envIntensityValue: document.getElementById('envIntensityValue'),\n  toggleArmrests: document.getElementById('toggleArmrests'),\n  toggleHeadrest: document.getElementById('toggleHeadrest'),\n  toggleCasters: document.getElementById('toggleCasters'),\n  exportJSON: document.getElementById('exportJSON'),\n  snapshotPNG: document.getElementById('snapshotPNG'),\n  reset: document.getElementById('reset'),\n  randomize: document.getElementById('randomize'),\n  bookmarkButtons: Array.from(document.querySelectorAll('.bookmark-buttons button'))\n};\n\nconst canvas = document.getElementById('canvas');\n\n// Renderer\nconst renderer = new THREE.WebGLRenderer({\n  canvas,\n  antialias: true,\n  alpha: false,\n  preserveDrawingBuffer: true // enables toDataURL for snapshots\n});\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\nrenderer.setSize(window.innerWidth - 320, window.innerHeight);\nrenderer.shadowMap.enabled = true;\nrenderer.shadowMap.type = THREE.PCFSoftShadowMap;\nrenderer.outputColorSpace = THREE.SRGBColorSpace;\nrenderer.toneMapping = THREE.ACESFilmicToneMapping;\nrenderer.toneMappingExposure = 1.0;\n\n// Scene\nconst scene = new THREE.Scene();\nscene.background = new THREE.Color(0x0e0f13);\n\n// Environment Reflection\nconst pmrem = new THREE.PMREMGenerator(renderer);\nconst env = new RoomEnvironment(renderer);\nconst envRT = pmrem.fromScene(env, 0.04);\nscene.environment = envRT.texture;\n\n// Camera & Controls\nconst camera = new THREE.PerspectiveCamera(50, (window.innerWidth-320)/window.innerHeight, 0.1, 100);\ncamera.position.set(3.2, 2.2, 4.0);\n\nconst controls = new OrbitControls(camera, renderer.domElement);\ncontrols.target.set(0, 0.9, 0);\ncontrols.enableDamping = true;\ncontrols.dampingFactor = 0.06;\ncontrols.minDistance = 1.0;\ncontrols.maxDistance = 12.0;\ncontrols.maxPolarAngle = Math.PI * 0.495;\n\n// Lights\nconst hemi = new THREE.HemisphereLight(0xbfd3ff, 0x232428, 0.6);\nscene.add(hemi);\n\nconst dirLight = new THREE.DirectionalLight(0xffffff, 1.2);\ndirLight.position.set(4, 7, 5);\ndirLight.castShadow = true;\ndirLight.shadow.mapSize.set(2048, 2048);\ndirLight.shadow.camera.left = -6;\ndirLight.shadow.camera.right = 6;\ndirLight.shadow.camera.top = 6;\ndirLight.shadow.camera.bottom = -6;\ndirLight.shadow.camera.near = 1;\ndirLight.shadow.camera.far = 20;\ndirLight.shadow.bias = -0.0005;\nscene.add(dirLight);\n\nconst fillLight = new THREE.SpotLight(0x88aaff, 0.15, 0, Math.PI/5, 0.4, 1.2);\nfillLight.position.set(-6, 4, -4);\nfillLight.target.position.set(0, 1, 0);\nfillLight.castShadow = false;\nscene.add(fillLight);\nscene.add(fillLight.target);\n\n// Ground\nconst groundGeo = new THREE.CircleGeometry(7.5, 64);\nconst groundMat = new THREE.MeshStandardMaterial({ color: 0x0c0d11, roughness: 0.9, metalness: 0.0 });\nconst ground = new THREE.Mesh(groundGeo, groundMat);\nground.rotation.x = -Math.PI/2;\nground.position.y = 0;\nground.receiveShadow = true;\nscene.add(ground);\n\n// Chair model container\nconst chairGroup = new THREE.Group();\nchairGroup.position.y = 0;\nscene.add(chairGroup);\n\n// Materials\nconst maxAniso = renderer.capabilities.getMaxAnisotropy();\nconst matRefs = {\n  upholstery: new THREE.MeshPhysicalMaterial({\n    color: new THREE.Color(state.upholsteryColor),\n    roughness: 0.7,\n    metalness: 0.0,\n    clearcoat: 0.0,\n    clearcoatRoughness: 0.0,\n    sheen: 1.0,\n    sheenRoughness: 0.8,\n    sheenColor: new THREE.Color(0xffffff),\n    envMapIntensity: state.envIntensity\n  }),\n  baseMetal: new THREE.MeshStandardMaterial({\n    color: 0x101217,\n    roughness: state.metalRoughness,\n    metalness: 1.0,\n    envMapIntensity: state.envIntensity\n  }),\n  plastic: new THREE.MeshStandardMaterial({\n    color: 0x1a1f27,\n    roughness: 0.6,\n    metalness: 0.0,\n    envMapIntensity: state.envIntensity\n  })\n};\n\n// Pattern textures (procedural)\nfunction makeCanvasTexture(drawFn, size = 1024, repeat = 1) {\n  const c = document.createElement('canvas');\n  c.width = c.height = size;\n  const ctx = c.getContext('2d');\n  drawFn(ctx, size);\n  const tex = new THREE.CanvasTexture(c);\n  tex.anisotropy = maxAniso;\n  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n  tex.colorSpace = THREE.SRGBColorSpace;\n  tex.repeat.set(repeat, repeat);\n  return tex;\n}\nfunction patternChecker(ctx, size) {\n  const colors = ['#ffffff', '#d7dbe6'];\n  const n = 8;\n  const cell = size / n;\n  for (let y = 0; y < n; y++) {\n    for (let x = 0; x < n; x++) {\n      ctx.fillStyle = colors[(x + y) % 2];\n      ctx.fillRect(x * cell, y * cell, cell, cell);\n    }\n  }\n}\nfunction patternStripes(ctx, size) {\n  const bands = 16;\n  const bandSize = size / bands;\n  for (let i = 0; i < bands; i++) {\n    ctx.fillStyle = i % 2 ? '#e9ecf4' : '#ffffff';\n    ctx.fillRect(0, i * bandSize, size, bandSize);\n  }\n  // subtle diagonal overlay\n  ctx.strokeStyle = 'rgba(0,0,0,0.03)';\n  ctx.lineWidth = 1;\n  for (let i = -size; i < size*2; i += 12) {\n    ctx.beginPath();\n    ctx.moveTo(i, 0);\n    ctx.lineTo(i - size, size);\n    ctx.stroke();\n  }\n}\nfunction patternNoise(ctx, size) {\n  const img = ctx.createImageData(size, size);\n  for (let i = 0; i < img.data.length; i += 4) {\n    const n = 235 + (Math.random() * 20)|0;\n    img.data[i] = img.data[i+1] = img.data[i+2] = n;\n    img.data[i+3] = 255;\n  }\n  ctx.putImageData(img, 0, 0);\n  ctx.globalAlpha = 0.15;\n  ctx.fillStyle = '#ffffff';\n  ctx.fillRect(0, 0, size, size);\n  ctx.globalAlpha = 1;\n}\nfunction patternBrushedMetal(ctx, size) {\n  ctx.fillStyle = '#e6e8ef';\n  ctx.fillRect(0, 0, size, size);\n  ctx.globalAlpha = 0.25;\n  ctx.fillStyle = '#c6cbd6';\n  for (let y = 0; y < size; y++) {\n    const w = (Math.random() * size * 0.1) | 0;\n    ctx.fillRect((Math.random() * size)|0, y, w, 1);\n  }\n  ctx.globalAlpha = 1;\n}\n\n// Build Chair (procedural)\nconst chair = buildChair();\nchairGroup.add(chair.group);\n\nfunction buildChair() {\n  const group = new THREE.Group();\n\n  // Base column\n  const columnGeo = new THREE.CylinderGeometry(0.08, 0.12, 0.55, 24);\n  const column = new THREE.Mesh(columnGeo, matRefs.baseMetal);\n  column.position.set(0, 0.55/2, 0);\n  column.castShadow = true; column.receiveShadow = true;\n  group.add(column);\n\n  // Height adjust collar (detail)\n  const collarGeo = new THREE.TorusGeometry(0.12, 0.02, 16, 64);\n  const collar = new THREE.Mesh(collarGeo, matRefs.baseMetal);\n  collar.rotation.x = Math.PI/2;\n  collar.position.y = 0.18;\n  collar.castShadow = true; collar.receiveShadow = true;\n  group.add(collar);\n\n  // Star base\n  const star = new THREE.Group();\n  const spokeLen = 0.9;\n  const spokeGeo = new THREE.BoxGeometry(spokeLen, 0.06, 0.12);\n  for (let i = 0; i < 5; i++) {\n    const spoke = new THREE.Mesh(spokeGeo, matRefs.baseMetal);\n    spoke.position.set(Math.cos(i*2*Math.PI/5) * spokeLen/2, 0.03, Math.sin(i*2*Math.PI/5) * spokeLen/2);\n    spoke.rotation.y = i*2*Math.PI/5;\n    spoke.castShadow = true; spoke.receiveShadow = true;\n    star.add(spoke);\n\n    // Caster (wheel)\n    const caster = new THREE.Group();\n    const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.09, 0.03, 16, 32), matRefs.plastic);\n    wheel.rotation.x = Math.PI/2;\n    wheel.castShadow = true; wheel.receiveShadow = true;\n    caster.add(wheel);\n\n    const fork = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.1, 12), matRefs.baseMetal);\n    fork.position.y = 0.12;\n    fork.castShadow = true; fork.receiveShadow = true;\n    caster.add(fork);\n\n    caster.position.copy(spoke.position).add(new THREE.Vector3(Math.cos(spoke.rotation.y) * (spokeLen/2+0.1), 0.09, Math.sin(spoke.rotation.y) * (spokeLen/2+0.1)));\n    caster.name = 'caster';\n    star.add(caster);\n  }\n  group.add(star);\n\n  // Seat support\n  const seatPole = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.25, 24), matRefs.baseMetal);\n  seatPole.position.y = 0.55 + 0.125;\n  seatPole.castShadow = true; seatPole.receiveShadow = true;\n  group.add(seatPole);\n\n  // Seat cushion (box)\n  const seatGeo = new THREE.BoxGeometry(0.55, 0.09, 0.5);\n  const seat = new THREE.Mesh(seatGeo, matRefs.upholstery);\n  seat.position.set(0, 0.55 + 0.25 + 0.045, 0);\n  seat.castShadow = true; seat.receiveShadow = false;\n  seat.name = 'seat';\n  group.add(seat);\n\n  // Backrest support\n  const backBar = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.6, 16), matRefs.baseMetal);\n  backBar.position.set(0, seat.position.y + 0.03, -0.22);\n  backBar.position.y += 0.3;\n  backBar.castShadow = true; backBar.receiveShadow = true;\n  group.add(backBar);\n\n  // Backrest\n  const backGeo = new THREE.BoxGeometry(0.5, 0.65, 0.06);\n  const back = new THREE.Mesh(backGeo, matRefs.upholstery);\n  back.position.set(0, seat.position.y + 0.36, -0.18);\n  back.rotation.x = -0.08;\n  back.castShadow = true; back.receiveShadow = false;\n  back.name = 'back';\n  group.add(back);\n\n  // Armrests\n  const armGroup = new THREE.Group();\n  armGroup.name = 'armrests';\n\n  const armSupportGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.22, 12);\n  const armPadGeo = new THREE.CapsuleGeometry(0.08, 0.24, 8, 16);\n\n  const armL = new THREE.Group();\n  const armLSupport = new THREE.Mesh(armSupportGeo, matRefs.baseMetal);\n  armLSupport.position.set(-0.32, seat.position.y + 0.14, 0.06);\n  armLSupport.rotation.z = 0.06;\n  armLSupport.castShadow = true; armLSupport.receiveShadow = true;\n  const armLPad = new THREE.Mesh(armPadGeo, matRefs.plastic);\n  armLPad.rotation.z = Math.PI/2;\n  armLPad.position.set(-0.32, seat.position.y + 0.24, 0.06);\n  armLPad.castShadow = true;\n  armL.add(armLSupport, armLPad);\n\n  const armR = armL.clone(true);\n  armR.children[0].position.x *= -1;\n  armR.children[1].position.x *= -1;\n\n  armGroup.add(armL, armR);\n  group.add(armGroup);\n\n  // Headrest\n  const headGroup = new THREE.Group();\n  headGroup.name = 'headrest';\n  const headSupport = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.22, 12), matRefs.baseMetal);\n  headSupport.position.set(0, back.position.y + 0.28, -0.18);\n  headSupport.castShadow = true; headSupport.receiveShadow = true;\n  const headPad = new THREE.Mesh(new THREE.CapsuleGeometry(0.1, 0.18, 8, 16), matRefs.upholstery);\n  headPad.position.set(0, back.position.y + 0.38, -0.12);\n  headPad.rotation.x = -0.25;\n  headPad.castShadow = true; headPad.receiveShadow = false;\n  headGroup.add(headSupport, headPad);\n  group.add(headGroup);\n\n  // Slight tilt on entire chair for visual interest\n  group.rotation.y = 0.2;\n\n  return {\n    group,\n    parts: {\n      seat,\n      back,\n      armrests: armGroup,\n      headrest: headGroup,\n      casters: star.children.filter(o => o.name === 'caster')\n    }\n  };\n}\n\n// Camera bookmarks\nconst bookmarks = {\n  overview: { pos: new THREE.Vector3(3.2, 2.2, 4.0), target: new THREE.Vector3(0, 0.9, 0) },\n  front:    { pos: new THREE.Vector3(0.0, 1.6, 4.2), target: new THREE.Vector3(0, 1.0, 0) },\n  left:     { pos: new THREE.Vector3(-4.0, 1.4, 0.2), target: new THREE.Vector3(0, 1.0, 0) },\n  right:    { pos: new THREE.Vector3(4.0, 1.4, 0.2), target: new THREE.Vector3(0, 1.0, 0) },\n  closeup:  { pos: new THREE.Vector3(0.8, 1.2, 0.6), target: new THREE.Vector3(0, 1.0, 0) },\n  top:      { pos: new THREE.Vector3(0.5, 6.0, 0.5), target: new THREE.Vector3(0, 0.7, 0) }\n};\nlet camAnim = null;\nfunction gotoBookmark(name, duration = 800) {\n  const bm = bookmarks[name];\n  if (!bm) return;\n  state.cameraBookmark = name;\n  const from = { pos: camera.position.clone(), target: controls.target.clone() };\n  const to = { pos: bm.pos.clone(), target: bm.target.clone() };\n  const t0 = performance.now();\n  camAnim = { t0, duration, from, to };\n}\n\nui.bookmarkButtons.forEach(btn => btn.addEventListener('click', () => gotoBookmark(btn.dataset.bookmark)));\n\n// UI events\nui.upholsteryColor.addEventListener('input', () => {\n  state.upholsteryColor = ui.upholsteryColor.value;\n  updateUpholsteryMaterial();\n});\nui.upholsteryMaterial.addEventListener('change', () => {\n  state.upholsteryMaterial = ui.upholsteryMaterial.value;\n  updateUpholsteryMaterial();\n});\nui.upholsteryPattern.addEventListener('change', () => {\n  state.upholsteryPattern = ui.upholsteryPattern.value;\n  updateUpholsteryPattern();\n});\nui.patternScale.addEventListener('input', () => {\n  state.patternScale = parseFloat(ui.patternScale.value);\n  ui.patternScaleValue.textContent = state.patternScale.toFixed(1) + 'x';\n  updateUpholsteryPattern();\n});\nui.baseFinish.addEventListener('change', () => {\n  state.baseFinish = ui.baseFinish.value;\n  updateBaseMaterial();\n});\nui.metalRoughness.addEventListener('input', () => {\n  state.metalRoughness = parseFloat(ui.metalRoughness.value);\n  ui.metalRoughnessValue.textContent = state.metalRoughness.toFixed(2);\n  updateBaseMaterial();\n});\nui.envIntensity.addEventListener('input', () => {\n  state.envIntensity = parseFloat(ui.envIntensity.value);\n  ui.envIntensityValue.textContent = state.envIntensity.toFixed(2);\n  updateEnvIntensity();\n});\nui.toggleArmrests.addEventListener('change', () => setPartVisibility('armrests', ui.toggleArmrests.checked));\nui.toggleHeadrest.addEventListener('change', () => setPartVisibility('headrest', ui.toggleHeadrest.checked));\nui.toggleCasters.addEventListener('change', () => setCastersVisibility(ui.toggleCasters.checked));\n\nui.exportJSON.addEventListener('click', exportJSON);\nui.snapshotPNG.addEventListener('click', snapshotPNG);\nui.reset.addEventListener('click', () => { loadState(defaultState()); });\nui.randomize.addEventListener('click', () => { randomizeState(); });\n\n// Helper: apply environment intensity to all PBR materials\nfunction updateEnvIntensity() {\n  const intensity = state.envIntensity;\n  [matRefs.upholstery, matRefs.baseMetal, matRefs.plastic].forEach(m => {\n    m.envMapIntensity = intensity;\n    m.needsUpdate = true;\n  });\n  renderer.toneMappingExposure = 0.95 + intensity * 0.05;\n}\n\n// Update upholstery material (color, shading model)\nfunction updateUpholsteryMaterial() {\n  const c = new THREE.Color(state.upholsteryColor);\n  matRefs.upholstery.color.copy(c);\n\n  // Adjust material parameters based on material type\n  if (state.upholsteryMaterial === 'leather') {\n    matRefs.upholstery.roughness = 0.35;\n    matRefs.upholstery.clearcoat = 0.8;\n    matRefs.upholstery.clearcoatRoughness = 0.2;\n    matRefs.upholstery.sheen = 0.7;\n    matRefs.upholstery.sheenRoughness = 0.5;\n  } else if (state.upholsteryMaterial === 'fabric') {\n    matRefs.upholstery.roughness = 0.75;\n    matRefs.upholstery.clearcoat = 0.0;\n    matRefs.upholstery.clearcoatRoughness = 0.0;\n    matRefs.upholstery.sheen = 1.0;\n    matRefs.upholstery.sheenRoughness = 0.85;\n  } else if (state.upholsteryMaterial === 'suede') {\n    matRefs.upholstery.roughness = 0.95;\n    matRefs.upholstery.clearcoat = 0.0;\n    matRefs.upholstery.clearcoatRoughness = 0.0;\n    matRefs.upholstery.sheen = 1.0;\n    matRefs.upholstery.sheenRoughness = 0.95;\n  }\n\n  updateUpholsteryPattern();\n}\n\n// Update pattern texture\nfunction updateUpholsteryPattern() {\n  const scale = state.patternScale;\n  let tex = null;\n  if (state.upholsteryPattern === 'checker') {\n    tex = makeCanvasTexture(patternChecker, 1024, scale);\n  } else if (state.upholsteryPattern === 'stripes') {\n    tex = makeCanvasTexture(patternStripes, 1024, scale);\n  } else if (state.upholsteryPattern === 'noise') {\n    tex = makeCanvasTexture(patternNoise, 512, scale * 2);\n  }\n  matRefs.upholstery.map = tex;\n  if (tex) {\n    tex.needsUpdate = true;\n    matRefs.upholstery.map = tex;\n  }\n  matRefs.upholstery.needsUpdate = true;\n}\n\n// Update base/frame material (finish and roughness)\nfunction updateBaseMaterial() {\n  const finish = state.baseFinish;\n  if (finish === 'chrome') {\n    matRefs.baseMetal.color.set(0xffffff);\n    matRefs.baseMetal.metalness = 1.0;\n    matRefs.baseMetal.roughness = state.metalRoughness * 0.5;\n    matRefs.baseMetal.map = makeCanvasTexture(patternBrushedMetal, 1024, 2);\n  } else if (finish === 'black') {\n    matRefs.baseMetal.color.set(0x12161d);\n    matRefs.baseMetal.metalness = 0.8;\n    matRefs.baseMetal.roughness = state.metalRoughness;\n    matRefs.baseMetal.map = null;\n  } else if (finish === 'white') {\n    matRefs.baseMetal.color.set(0xf3f5f9);\n    matRefs.baseMetal.metalness = 0.2;\n    matRefs.baseMetal.roughness = Math.max(0.25, state.metalRoughness);\n    matRefs.baseMetal.map = null;\n  }\n  matRefs.baseMetal.needsUpdate = true;\n}\n\n// Part visibility\nfunction setPartVisibility(partName, visible) {\n  if (partName === 'armrests') {\n    chair.parts.armrests.visible = visible;\n    state.parts.armrests = visible;\n  } else if (partName === 'headrest') {\n    chair.parts.headrest.visible = visible;\n    state.parts.headrest = visible;\n  }\n}\nfunction setCastersVisibility(visible) {\n  chair.parts.casters.forEach(c => c.visible = visible);\n  state.parts.casters = visible;\n}\n\n// Export JSON\nfunction exportJSON() {\n  const config = {\n    upholsteryColor: state.upholsteryColor,\n    upholsteryMaterial: state.upholsteryMaterial,\n    upholsteryPattern: state.upholsteryPattern,\n    patternScale: state.patternScale,\n    baseFinish: state.baseFinish,\n    metalRoughness: state.metalRoughness,\n    envIntensity: state.envIntensity,\n    parts: { ...state.parts },\n    camera: {\n      position: camera.position.toArray(),\n      target: controls.target.toArray(),\n      bookmark: state.cameraBookmark\n    },\n    timestamp: new Date().toISOString(),\n    product: 'Office Chair'\n  };\n  const str = JSON.stringify(config, null, 2);\n  downloadBlob(str, 'chair_config.json', 'application/json');\n}\n\n// Snapshot PNG\nfunction snapshotPNG() {\n  // temporarily hide UI background to avoid reflection changes (not necessary, just snapshot canvas)\n  renderer.render(scene, camera); // ensure latest frame\n  const dataURL = renderer.domElement.toDataURL('image/png');\n  downloadDataURL(dataURL, 'chair_snapshot.png');\n}\n\nfunction downloadBlob(content, filename, type) {\n  const blob = new Blob([content], { type });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url; a.download = filename; a.click();\n  setTimeout(() => URL.revokeObjectURL(url), 1000);\n}\nfunction downloadDataURL(dataURL, filename) {\n  const a = document.createElement('a');\n  a.href = dataURL; a.download = filename; a.click();\n}\n\n// Randomize\nfunction randomizeState() {\n  const colors = ['#f43f5e','#f59e0b','#22c55e','#06b6d4','#3b82f6','#8b5cf6','#ec4899','#a3a3a3','#111827'];\n  state.upholsteryColor = colors[(Math.random()*colors.length)|0];\n  state.upholsteryMaterial = ['leather','fabric','suede'][(Math.random()*3)|0];\n  state.upholsteryPattern = ['none','checker','stripes','noise'][(Math.random()*4)|0];\n  state.patternScale = +(Math.random()*5.5 + 0.5).toFixed(1);\n  state.baseFinish = ['chrome','black','white'][(Math.random()*3)|0];\n  state.metalRoughness = +(Math.random()).toFixed(2);\n  state.envIntensity = +(Math.random()*2.5 + 0.3).toFixed(2);\n  state.parts.armrests = Math.random() > 0.2;\n  state.parts.headrest = Math.random() > 0.6;\n  state.parts.casters = Math.random() > 0.05;\n  applyStateToUI();\n  applyStateToScene();\n}\n\n// Defaults and load\nfunction defaultState() {\n  return JSON.parse(JSON.stringify({\n    upholsteryColor: '#3b82f6',\n    upholsteryMaterial: 'fabric',\n    upholsteryPattern: 'none',\n    patternScale: 2,\n    baseFinish: 'black',\n    metalRoughness: 0.35,\n    envIntensity: 1.0,\n    parts: { armrests: true, headrest: false, casters: true },\n    cameraBookmark: 'overview'\n  }));\n}\nfunction loadState(s) {\n  Object.assign(state, defaultState(), s || {});\n  applyStateToUI();\n  applyStateToScene();\n  gotoBookmark(state.cameraBookmark, 600);\n}\nfunction applyStateToUI() {\n  ui.upholsteryColor.value = state.upholsteryColor;\n  ui.upholsteryMaterial.value = state.upholsteryMaterial;\n  ui.upholsteryPattern.value = state.upholsteryPattern;\n  ui.patternScale.value = state.patternScale;\n  ui.patternScaleValue.textContent = state.patternScale.toFixed(1) + 'x';\n  ui.baseFinish.value = state.baseFinish;\n  ui.metalRoughness.value = state.metalRoughness;\n  ui.metalRoughnessValue.textContent = state.metalRoughness.toFixed(2);\n  ui.envIntensity.value = state.envIntensity;\n  ui.envIntensityValue.textContent = state.envIntensity.toFixed(2);\n  ui.toggleArmrests.checked = state.parts.armrests;\n  ui.toggleHeadrest.checked = state.parts.headrest;\n  ui.toggleCasters.checked = state.parts.casters;\n}\nfunction applyStateToScene() {\n  updateEnvIntensity();\n  updateUpholsteryMaterial();\n  updateBaseMaterial();\n  setPartVisibility('armrests', state.parts.armrests);\n  setPartVisibility('headrest', state.parts.headrest);\n  setCastersVisibility(state.parts.casters);\n}\n\n// Resize\nfunction onResize() {\n  const w = window.innerWidth - 320;\n  const h = window.innerHeight;\n  renderer.setSize(w, h, false);\n  camera.aspect = w / h;\n  camera.updateProjectionMatrix();\n}\nwindow.addEventListener('resize', onResize);\n\n// Animate\nconst clock = new THREE.Clock();\nfunction animate() {\n  const dt = clock.getDelta();\n  // Camera tween\n  if (camAnim) {\n    const t = (performance.now() - camAnim.t0) / camAnim.duration;\n    const k = t >= 1 ? 1 : smoothstep(0, 1, t);\n    const pos = camAnim.from.pos.clone().lerp(camAnim.to.pos, k);\n    const tgt = camAnim.from.target.clone().lerp(camAnim.to.target, k);\n    camera.position.copy(pos);\n    controls.target.copy(tgt);\n    if (t >= 1) camAnim = null;\n  }\n\n  controls.update();\n  renderer.render(scene, camera);\n  requestAnimationFrame(animate);\n}\nfunction smoothstep(a, b, t) {\n  const x = Math.min(1, Math.max(0, (t - a) / (b - a)));\n  return x * x * (3 - 2 * x);\n}\n\n// Kickoff\napplyGroundGradient();\nloadState(state);\ngotoBookmark('overview', 0);\nanimate();\n\n// Subtle radial gradient on ground for aesthetics\nfunction applyGroundGradient() {\n  const size = 512;\n  const c = document.createElement('canvas');\n  c.width = c.height = size;\n  const ctx = c.getContext('2d');\n  const grad = ctx.createRadialGradient(size/2, size/2, size*0.15, size/2, size/2, size*0.5);\n  grad.addColorStop(0, '#12141a');\n  grad.addColorStop(1, '#0a0b0f');\n  ctx.fillStyle = grad; ctx.fillRect(0,0,size,size);\n  const tex = new THREE.CanvasTexture(c);\n  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;\n  tex.colorSpace = THREE.SRGBColorSpace;\n  ground.material.map = tex;\n  ground.material.needsUpdate = true;\n}\n\n// Ensure all meshes cast/receive shadows appropriately\nscene.traverse(obj => {\n  if (obj.isMesh) {\n    obj.castShadow = obj.castShadow || true;\n    if (obj === ground) obj.receiveShadow = true;\n  }\n});\n\n// Expose for potential debugging\nwindow.scene = scene; window.camera = camera; window.chair = chairGroup;\n\n</script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 109.78093194961548,
    "status": "success",
    "timestamp": "2025-08-29 17:46:36"
  },
  {
    "test_name": "webxr_art_gallery",
    "prompt": "Create a complete HTML file with Three.js and WebXR that builds a VR gallery with teleport navigation, hand/controller rays to select artworks, modal info panels, spatial audio, baked/lightmapped room, and performance budget for stable frame rate. Include fallback for non-VR devices with mouse controls. The HTML file should be self-contained with Three.js and WebXR libraries loaded from CDN. Save the output as 'webxr_gallery.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>WebXR VR Gallery</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" />\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      background: #0a0a0a;\n      height: 100%;\n      overflow: hidden;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n      color: #eaeaea;\n    }\n    #overlay {\n      position: fixed;\n      inset: 0;\n      pointer-events: none; /* turned on when modal visible */\n      display: flex;\n      flex-direction: column;\n      justify-content: space-between;\n      z-index: 10;\n    }\n    .topbar {\n      display: flex;\n      gap: 12px;\n      padding: 10px 12px;\n      color: #cfcfcf;\n      opacity: 0.85;\n      font-size: 14px;\n      background: linear-gradient(to bottom, rgba(0,0,0,0.55), rgba(0,0,0,0));\n      user-select: none;\n    }\n    .hud {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    .pill {\n      padding: 6px 10px;\n      border-radius: 999px;\n      background: rgba(255,255,255,0.08);\n      border: 1px solid rgba(255,255,255,0.12);\n      backdrop-filter: blur(4px);\n    }\n    #fps {\n      margin-left: auto;\n    }\n    #help {\n      padding: 0 12px 12px 12px;\n      color: #bdbdbd;\n      font-size: 12px;\n      opacity: 0.8;\n    }\n    .modal-backdrop {\n      position: fixed;\n      inset: 0;\n      background: rgba(0,0,0,0.55);\n      display: none;\n      align-items: center;\n      justify-content: center;\n      pointer-events: auto;\n    }\n    .modal {\n      width: min(90vw, 520px);\n      max-height: 80vh;\n      overflow: auto;\n      background: #121212;\n      border: 1px solid rgba(255,255,255,0.12);\n      box-shadow: 0 10px 40px rgba(0,0,0,0.55);\n      border-radius: 12px;\n      color: #eaeaea;\n    }\n    .modal header {\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      padding: 12px 16px;\n      border-bottom: 1px solid rgba(255,255,255,0.08);\n      position: sticky;\n      top: 0;\n      background: #121212;\n    }\n    .modal h3 {\n      margin: 0;\n      font-weight: 600;\n      font-size: 18px;\n    }\n    .modal .meta {\n      padding: 8px 16px 0 16px;\n      color: #bdbdbd;\n      font-size: 13px;\n    }\n    .modal .body {\n      padding: 12px 16px 16px 16px;\n      line-height: 1.45;\n      font-size: 14px;\n    }\n    .xbtn {\n      border: 1px solid rgba(255,255,255,0.14);\n      background: rgba(255,255,255,0.06);\n      color: #fff;\n      border-radius: 8px;\n      padding: 6px 10px;\n      cursor: pointer;\n    }\n    .xbtn:hover { background: rgba(255,255,255,0.12); }\n    canvas { display: block; }\n    .a11y {\n      position: fixed;\n      bottom: 8px;\n      left: 8px;\n      pointer-events: none;\n      color: #9d9d9d;\n      font-size: 12px;\n      opacity: 0.7;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"overlay\">\n    <div class=\"topbar\">\n      <div class=\"hud\">\n        <div class=\"pill\">VR Gallery</div>\n        <div class=\"pill\">Teleport: Controller trigger on floor \u2022 Mouse click on floor</div>\n        <div class=\"pill\">Select artwork: Point & trigger \u2022 Pinch on hand-tracking</div>\n        <div class=\"pill\">Rotate/Look (non\u2011VR): Drag \u2022 Pan/Move: Right-drag / WASD</div>\n      </div>\n      <div id=\"fps\" class=\"pill\">FPS: --</div>\n    </div>\n    <div id=\"help\">\n      Enter VR to experience room\u2011scale navigation. If your device supports hand tracking, pinch your index and thumb to select. This scene uses baked\u2011style lightmaps and spatial audio cues near each artwork for performance and immersion.\n    </div>\n    <div id=\"modalBackdrop\" class=\"modal-backdrop\" role=\"dialog\" aria-modal=\"true\">\n      <div class=\"modal\">\n        <header>\n          <h3 id=\"modalTitle\">Artwork</h3>\n          <button class=\"xbtn\" id=\"modalClose\" title=\"Close\">Close</button>\n        </header>\n        <div class=\"meta\" id=\"modalMeta\"></div>\n        <div class=\"body\" id=\"modalBody\"></div>\n      </div>\n    </div>\n  </div>\n  <div class=\"a11y\">Tip: On mobile, use the Enter VR button.</div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';\n    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';\n    import { VRButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js';\n    import { XRControllerModelFactory } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js';\n    import { XRHandModelFactory } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/XRHandModelFactory.js';\n\n    // Scene globals\n    let renderer, scene, camera, controls, userRig;\n    let floor, teleportables = [], selectables = [], frames = [];\n    let reticle;\n    let controller1, controller2, controllerGrip1, controllerGrip2;\n    let hand1, hand2, handPointer1, handPointer2;\n    const tempMatrix = new THREE.Matrix4();\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n\n    // Audio\n    const listener = new THREE.AudioListener();\n    const positionalAudios = [];\n    let audioActivated = false;\n\n    // Performance budget\n    let targetFPS = 72; // aim for 72+ in VR, 60 on desktop\n    let frameTimes = [];\n    let pixelRatioMin = 0.8, pixelRatioMax = Math.min(window.devicePixelRatio, 1.5);\n    let currentPixelRatio = Math.min(window.devicePixelRatio, 1.25);\n    let lastPerfAdjust = 0;\n    const fpsLabel = document.getElementById('fps');\n\n    // Modal elements\n    const modalBackdrop = document.getElementById('modalBackdrop');\n    const modalClose = document.getElementById('modalClose');\n    const modalTitle = document.getElementById('modalTitle');\n    const modalMeta = document.getElementById('modalMeta');\n    const modalBody = document.getElementById('modalBody');\n\n    // Simple helpers\n    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }\n    function copyUVtoUV2(geometry){\n      const uv = geometry.attributes.uv;\n      geometry.setAttribute('uv2', new THREE.BufferAttribute(uv.array.slice(0), 2)); // copy\n    }\n\n    // Texture generators (self-contained, no external assets)\n    function makeCanvasTexture(draw, w=1024, h=1024){\n      const c = document.createElement('canvas'); c.width = w; c.height = h;\n      const ctx = c.getContext('2d');\n      draw(ctx, w, h);\n      const tex = new THREE.CanvasTexture(c);\n      tex.colorSpace = THREE.SRGBColorSpace;\n      tex.anisotropy = 4;\n      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n      return tex;\n    }\n    const lightMapTex = makeCanvasTexture((ctx,w,h)=>{\n      const g = ctx.createRadialGradient(w*0.5, h*0.55, w*0.2, w*0.5, h*0.5, w*0.9);\n      g.addColorStop(0, '#ffffff');\n      g.addColorStop(1, '#3a3a3a');\n      ctx.fillStyle = g;\n      ctx.fillRect(0,0,w,h);\n      // soft vignetting corners\n      ctx.globalCompositeOperation = 'multiply';\n      ctx.fillStyle = 'rgba(0,0,0,0.25)';\n      ctx.beginPath();\n      ctx.rect(0,0,w,h);\n      ctx.fill();\n    });\n    const wallTex = makeCanvasTexture((ctx,w,h)=>{\n      ctx.fillStyle = '#d9d9d6';\n      ctx.fillRect(0,0,w,h);\n      // subtle vertical banding\n      for(let x=0; x<w; x+=32){\n        const shade = 215 + Math.floor(8*Math.sin(x*0.03));\n        ctx.fillStyle = `rgba(${shade},${shade},${shade},0.25)`;\n        ctx.fillRect(x,0,16,h);\n      }\n      // noise\n      const img = ctx.getImageData(0,0,w,h);\n      for(let i=0; i<img.data.length; i+=4){\n        const n = (Math.random()*16)|0;\n        img.data[i  ] = clamp(img.data[i]-n,0,255);\n        img.data[i+1] = clamp(img.data[i+1]-n,0,255);\n        img.data[i+2] = clamp(img.data[i+2]-n,0,255);\n      }\n      ctx.putImageData(img,0,0);\n    }, 1024, 1024);\n    wallTex.repeat.set(2,1);\n\n    const floorTex = makeCanvasTexture((ctx,w,h)=>{\n      // checker\n      const cols = 8, rows = 8;\n      const cw = w/cols, ch = h/rows;\n      for(let y=0;y<rows;y++){\n        for(let x=0;x<cols;x++){\n          const odd = (x+y)%2===1;\n          ctx.fillStyle = odd ? '#c1c1c1' : '#b2b2b2';\n          ctx.fillRect(x*cw, y*ch, cw, ch);\n        }\n      }\n      // grout lines\n      ctx.strokeStyle = 'rgba(0,0,0,0.15)';\n      ctx.lineWidth = 6;\n      for(let x=0;x<=cols;x++){ ctx.beginPath(); ctx.moveTo(x*cw,0); ctx.lineTo(x*cw,h); ctx.stroke(); }\n      for(let y=0;y<=rows;y++){ ctx.beginPath(); ctx.moveTo(0,y*ch); ctx.lineTo(w,y*ch); ctx.stroke(); }\n    }, 1024, 1024);\n    floorTex.repeat.set(2,2);\n\n    const ceilingTex = makeCanvasTexture((ctx,w,h)=>{\n      const g = ctx.createLinearGradient(0,0,0,h);\n      g.addColorStop(0,'#e8e8e8');\n      g.addColorStop(1,'#cccccc');\n      ctx.fillStyle = g;\n      ctx.fillRect(0,0,w,h);\n    });\n\n    function makeArtworkTexture(title, subtitle, colors){\n      return makeCanvasTexture((ctx,w,h)=>{\n        // background gradient\n        const g = ctx.createLinearGradient(0,0,w,h);\n        g.addColorStop(0, colors[0]);\n        g.addColorStop(1, colors[1]);\n        ctx.fillStyle = g;\n        ctx.fillRect(0,0,w,h);\n        // artistic shapes\n        ctx.globalAlpha = 0.35;\n        for(let i=0;i<18;i++){\n          ctx.fillStyle = `hsl(${(i*37)%360} 70% 60%)`;\n          const r = (Math.random()*0.25+0.05)*Math.min(w,h);\n          ctx.beginPath();\n          ctx.arc(Math.random()*w, Math.random()*h, r, 0, Math.PI*2);\n          ctx.fill();\n        }\n        ctx.globalAlpha = 1;\n        // title text band\n        ctx.fillStyle = 'rgba(0,0,0,0.45)';\n        ctx.fillRect(0,h-140,w,140);\n        ctx.fillStyle = '#fff';\n        ctx.font = 'bold 42px system-ui, sans-serif';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'bottom';\n        ctx.fillText(title, 36, h-56);\n        ctx.font = 'normal 24px system-ui, sans-serif';\n        ctx.fillStyle = '#f0f0f0cc';\n        ctx.fillText(subtitle, 36, h-22);\n      }, 1024, 1024);\n    }\n\n    // Build scene\n    init();\n    animate();\n\n    function init(){\n      scene = new THREE.Scene();\n      scene.background = new THREE.Color(0x101012);\n\n      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 100);\n      camera.position.set(0, 1.6, 3.5);\n      camera.add(listener);\n\n      userRig = new THREE.Group();\n      userRig.position.set(0, 0, 0);\n      userRig.add(camera);\n      scene.add(userRig);\n\n      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      renderer.setPixelRatio(currentPixelRatio);\n      renderer.outputColorSpace = THREE.SRGBColorSpace;\n      renderer.shadowMap.enabled = false; // baked style\n      renderer.xr.enabled = true;\n      renderer.xr.setFoveation(1.0); // prefer performance\n      renderer.xr.setReferenceSpaceType('local-floor');\n      document.body.appendChild(renderer.domElement);\n\n      // VR Button with DOM Overlay and hand-tracking optional\n      const overlay = document.getElementById('overlay');\n      const vrButton = VRButton.createButton(renderer, {\n        requiredFeatures: [ 'local-floor' ],\n        optionalFeatures: [ 'hand-tracking', 'layers', 'dom-overlay' ],\n        domOverlay: { root: overlay }\n      });\n      document.body.appendChild(vrButton);\n\n      // Controls for non-VR\n      controls = new OrbitControls(camera, renderer.domElement);\n      controls.target.set(0, 1.6, 0);\n      controls.enableDamping = true;\n      controls.enablePan = true;\n      controls.panSpeed = 0.7;\n      controls.rotateSpeed = 0.5;\n      controls.maxPolarAngle = Math.PI * 0.49;\n      controls.minDistance = 0.5;\n      controls.maxDistance = 20;\n\n      buildRoom();\n      buildArtworks();\n\n      // Reticle for teleport target\n      reticle = new THREE.Mesh(\n        new THREE.RingGeometry(0.14, 0.16, 32),\n        new THREE.MeshBasicMaterial({ color: 0x44ff88, transparent: true, opacity: 0.85 })\n      );\n      reticle.rotation.x = -Math.PI/2;\n      reticle.visible = false;\n      scene.add(reticle);\n\n      // Controllers\n      const controllerModelFactory = new XRControllerModelFactory();\n      controller1 = renderer.xr.getController(0);\n      controller2 = renderer.xr.getController(1);\n      [controller1, controller2].forEach((con, idx)=>{\n        con.userData = { index: idx, selecting: false, hover: null, teleportCooldown: 0 };\n        con.addEventListener('selectstart', onSelectStart);\n        con.addEventListener('selectend', onSelectEnd);\n        con.addEventListener('connected', function(event){\n          this.add(buildControllerRay());\n        });\n        con.addEventListener('disconnected', function(){\n          this.remove(this.children[0]);\n        });\n        userRig.add(con);\n      });\n      controllerGrip1 = renderer.xr.getControllerGrip(0);\n      controllerGrip2 = renderer.xr.getControllerGrip(1);\n      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));\n      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));\n      userRig.add(controllerGrip1);\n      userRig.add(controllerGrip2);\n\n      // Hands\n      const handFactory = new XRHandModelFactory();\n      hand1 = renderer.xr.getHand(0);\n      hand2 = renderer.xr.getHand(1);\n      hand1.add(handFactory.createHandModel(hand1, 'mesh'));\n      hand2.add(handFactory.createHandModel(hand2, 'mesh'));\n      // Simple hand \"ray\" viz as thin line from index tip forward\n      handPointer1 = makeHandPointer();\n      handPointer2 = makeHandPointer();\n      hand1.add(handPointer1);\n      hand2.add(handPointer2);\n      hand1.addEventListener('pinchstart', onHandPinch);\n      hand2.addEventListener('pinchstart', onHandPinch);\n      userRig.add(hand1);\n      userRig.add(hand2);\n\n      // Pointer/mouse interactions\n      renderer.domElement.addEventListener('pointermove', onPointerMove);\n      renderer.domElement.addEventListener('pointerdown', (e)=>{ activateAudio(); });\n      renderer.domElement.addEventListener('click', onPointerClick);\n      window.addEventListener('resize', onWindowResize);\n\n      // Modal close\n      modalClose.addEventListener('click', hideModal);\n      modalBackdrop.addEventListener('click', (e)=>{ if (e.target === modalBackdrop) hideModal(); });\n\n      // Keyboard WASD movement for non-VR\n      initKeyboard();\n    }\n\n    function buildControllerRay(){\n      const geometry = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);\n      const material = new THREE.LineBasicMaterial({ color: 0x57c7ff, transparent: true, opacity: 0.9 });\n      const line = new THREE.Line(geometry, material);\n      line.name = 'ray';\n      line.scale.z = 5;\n      return line;\n    }\n\n    function makeHandPointer(){\n      const geo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);\n      const mat = new THREE.LineDashedMaterial({ color: 0xffff66, dashSize: 0.06, gapSize: 0.04, transparent: true, opacity: 0.75 });\n      const line = new THREE.Line(geo, mat);\n      line.computeLineDistances();\n      line.scale.z = 3.5;\n      line.visible = true;\n      return line;\n    }\n\n    function buildRoom(){\n      const lightMapIntensity = 1.1;\n      // Floor\n      const floorGeo = new THREE.PlaneGeometry(10, 10);\n      copyUVtoUV2(floorGeo);\n      const floorMat = new THREE.MeshBasicMaterial({ map: floorTex, lightMap: lightMapTex, lightMapIntensity });\n      floor = new THREE.Mesh(floorGeo, floorMat);\n      floor.rotation.x = -Math.PI/2;\n      floor.position.y = 0;\n      floor.receiveShadow = false;\n      scene.add(floor);\n      teleportables.push(floor);\n\n      // Ceiling\n      const ceilGeo = new THREE.PlaneGeometry(10, 10);\n      copyUVtoUV2(ceilGeo);\n      const ceilMat = new THREE.MeshBasicMaterial({ map: ceilingTex, lightMap: lightMapTex, lightMapIntensity: 0.8 });\n      const ceiling = new THREE.Mesh(ceilGeo, ceilMat);\n      ceiling.rotation.x = Math.PI/2;\n      ceiling.position.set(0, 3.0, 0);\n      scene.add(ceiling);\n\n      // Walls\n      const wallMat = new THREE.MeshBasicMaterial({ map: wallTex, lightMap: lightMapTex, lightMapIntensity });\n      const w = 10, h = 3.0;\n      const wallGeo = new THREE.PlaneGeometry(w, h);\n      copyUVtoUV2(wallGeo);\n\n      const wall1 = new THREE.Mesh(wallGeo, wallMat);\n      wall1.position.set(0, h/2, -w/2);\n      // face inside\n      wall1.rotation.y = Math.PI;\n      scene.add(wall1);\n\n      const wall2 = new THREE.Mesh(wallGeo, wallMat);\n      wall2.position.set(0, h/2, w/2);\n      // back face automatically inside\n      scene.add(wall2);\n\n      const wall3 = new THREE.Mesh(wallGeo, wallMat);\n      wall3.position.set(-w/2, h/2, 0);\n      wall3.rotation.y = Math.PI/2;\n      scene.add(wall3);\n\n      const wall4 = new THREE.Mesh(wallGeo, wallMat);\n      wall4.position.set(w/2, h/2, 0);\n      wall4.rotation.y = -Math.PI/2;\n      scene.add(wall4);\n\n      // Soft ambient (very low) to avoid absolute black edges\n      const amb = new THREE.AmbientLight(0xffffff, 0.15);\n      scene.add(amb);\n    }\n\n    function buildArtworks(){\n      const frameDepth = 0.04;\n      const frameColor = 0x222222;\n      const artData = [\n        { title: 'Aurora Drift', subtitle: 'E. Vega \u2022 2023', desc: 'A generative composition inspired by auroral turbulence and fluid dynamics. Tones and hues converge into a tranquil drift.', colors: ['#2b5876', '#4e4376'], pos: new THREE.Vector3(-3, 1.5, -4.4), rotY: 0 },\n        { title: 'Solaris Bloom', subtitle: 'R. Ocampo \u2022 2024', desc: 'Procedural blossoms emerge from a solar gradient, exploring the border between chaos and symmetry.', colors: ['#f857a6', '#ff5858'], pos: new THREE.Vector3(3, 1.5, -4.4), rotY: 0 },\n        { title: 'Fragments', subtitle: 'T. Kato \u2022 2022', desc: 'Shards of memory layered as translucent forms. An homage to the patina of time.', colors: ['#00c6ff', '#0072ff'], pos: new THREE.Vector3(-4.4, 1.5, 0), rotY: Math.PI/2 },\n        { title: 'Nocturne Grid', subtitle: 'M. Sato \u2022 2021', desc: 'Minimalist grid in nocturnal palette, focusing on rhythm and negative space.', colors: ['#232526', '#414345'], pos: new THREE.Vector3(4.4, 1.5, 0), rotY: -Math.PI/2 },\n      ];\n\n      artData.forEach((d, i)=>{\n        const artTex = makeArtworkTexture(d.title, d.subtitle, d.colors);\n        const artMat = new THREE.MeshBasicMaterial({ map: artTex, lightMap: lightMapTex, lightMapIntensity: 0.9 });\n        const artGeo = new THREE.PlaneGeometry(1.6, 1.1);\n        copyUVtoUV2(artGeo);\n        const artMesh = new THREE.Mesh(artGeo, artMat);\n        artMesh.position.copy(d.pos);\n        artMesh.rotation.y = d.rotY;\n        artMesh.userData.info = d;\n        artMesh.name = 'art';\n\n        // Frame (simple border)\n        const frameOuter = new THREE.BoxGeometry(1.7, 1.2, frameDepth);\n        const frameInner = new THREE.BoxGeometry(1.62, 1.12, frameDepth + 0.001);\n        const frameMat = new THREE.MeshBasicMaterial({ color: frameColor, lightMap: lightMapTex, lightMapIntensity: 1.0 });\n        const frame = new THREE.Mesh(frameOuter, frameMat);\n        // Carve inner by scaling z to near 0 and using z-fighting offset trick: place art in front\n        const innerMask = new THREE.Mesh(frameInner, new THREE.MeshBasicMaterial({ color: 0x000000 }));\n        innerMask.position.z = -0.001;\n        frame.add(innerMask);\n        frame.position.copy(d.pos).add(new THREE.Vector3(0,0,0.02)); // slight offset to avoid z-fight\n        frame.rotation.y = d.rotY;\n        frame.userData.isFrame = true;\n\n        // Place art slightly in front of frame\n        artMesh.position.z += 0.03;\n\n        scene.add(frame);\n        scene.add(artMesh);\n        selectables.push(artMesh);\n        frames.push(frame);\n\n        // Spatial audio per artwork (gentle pad/beep)\n        const audio = new THREE.PositionalAudio(listener);\n        const buffer = makeBeepBuffer(listener.context, 220 + i*60, 0.9);\n        audio.setBuffer(buffer);\n        audio.setRefDistance(1.2);\n        audio.setRolloffFactor(2.0);\n        audio.setDistanceModel('exponential');\n        audio.setLoop(true);\n        audio.setVolume(0.25);\n        artMesh.add(audio);\n        positionalAudios.push(audio);\n      });\n    }\n\n    function activateAudio(){\n      if (audioActivated) return;\n      audioActivated = true;\n      positionalAudios.forEach(a => { try { a.play(); } catch(e){} });\n    }\n\n    function makeBeepBuffer(ctx, freq=440, duration=1.0){\n      const rate = ctx.sampleRate;\n      const len = Math.floor(duration * rate);\n      const buffer = ctx.createBuffer(1, len, rate);\n      const data = buffer.getChannelData(0);\n      for(let i=0;i<len;i++){\n        const t = i / rate;\n        const env = Math.min(1, t*4) * Math.max(0, 1 - (t/duration)*0.8); // simple attack/decay\n        data[i] = Math.sin(2*Math.PI*freq*t) * 0.3 * env + Math.sin(2*Math.PI*(freq*2)*t) * 0.1 * env;\n      }\n      return buffer;\n    }\n\n    function onSelectStart(e){\n      this.userData.selecting = true;\n      activateAudio();\n      // On select, decide: if pointing at artwork -> show modal, else if floor -> teleport\n      const hit = intersectFromController(this, selectables);\n      if (hit) {\n        showModal(hit.object.userData.info);\n        pulseFrame(hit.object, true);\n        return;\n      }\n      const floorHit = intersectFromController(this, teleportables);\n      if (floorHit) {\n        teleportTo(floorHit.point);\n      }\n    }\n    function onSelectEnd(e){\n      this.userData.selecting = false;\n    }\n\n    function onHandPinch(e){\n      // On pinch, use hand \"ray\" to select or teleport\n      const hand = e.target;\n      const hit = intersectFromHand(hand, selectables);\n      if (hit) {\n        showModal(hit.object.userData.info);\n        pulseFrame(hit.object, true);\n        return;\n      }\n      const floorHit = intersectFromHand(hand, teleportables);\n      if (floorHit) teleportTo(floorHit.point);\n    }\n\n    function intersectFromController(controller, targets){\n      tempMatrix.identity().extractRotation(controller.matrixWorld);\n      const rayOrigin = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);\n      const rayDirection = new THREE.Vector3(0,0,-1).applyMatrix4(tempMatrix);\n      raycaster.set(rayOrigin, rayDirection);\n      raycaster.far = 10;\n      const intersects = raycaster.intersectObjects(targets, false);\n      return intersects.length ? intersects[0] : null;\n    }\n\n    function intersectFromHand(hand, targets){\n      const tip = hand.getObjectByName('index-finger-tip');\n      const knuckle = hand.getObjectByName('index-finger-metacarpal') || hand.getObjectByName('index-finger-phalanx-proximal');\n      if (!tip || !knuckle) return null;\n      const a = new THREE.Vector3(), b = new THREE.Vector3();\n      tip.getWorldPosition(a); knuckle.getWorldPosition(b);\n      const dir = a.clone().sub(b).normalize();\n      raycaster.set(a, dir);\n      raycaster.far = 7;\n      const intersects = raycaster.intersectObjects(targets, false);\n      return intersects.length ? intersects[0] : null;\n    }\n\n    function pulseFrame(artMesh, highlight){\n      const idx = selectables.indexOf(artMesh);\n      if (idx >= 0){\n        const frame = frames[idx];\n        frame.material.color.set(highlight ? 0x66ffcc : 0x222222);\n        setTimeout(()=>{ frame.material.color.set(0x222222); }, 500);\n      }\n    }\n\n    function teleportTo(point){\n      // Clamp within room bounds (slightly inset from walls)\n      const margin = 0.6;\n      const half = 5 - margin;\n      const x = clamp(point.x, -half, half);\n      const z = clamp(point.z, -half, half);\n      userRig.position.set(x, 0, z);\n    }\n\n    function onPointerMove(e){\n      const rect = renderer.domElement.getBoundingClientRect();\n      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n      mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;\n      // Hover highlight\n      raycaster.setFromCamera(mouse, camera);\n      const hits = raycaster.intersectObjects(selectables, false);\n      frames.forEach(f=>f.material.color.set(0x222222));\n      if (hits.length){\n        const idx = selectables.indexOf(hits[0].object);\n        if (idx>=0) frames[idx].material.color.set(0x66ffcc);\n      }\n    }\n    function onPointerClick(e){\n      // On click: if clicked on art -> modal; else if clicked on floor -> teleport\n      const rect = renderer.domElement.getBoundingClientRect();\n      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n      mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;\n      raycaster.setFromCamera(mouse, camera);\n      let hits = raycaster.intersectObjects(selectables, false);\n      if (hits.length){\n        showModal(hits[0].object.userData.info);\n        pulseFrame(hits[0].object, true);\n        return activateAudio();\n      }\n      hits = raycaster.intersectObjects(teleportables, false);\n      if (hits.length){\n        teleportTo(hits[0].point);\n        activateAudio();\n      }\n    }\n\n    function showModal(info){\n      modalTitle.textContent = info.title;\n      modalMeta.textContent = info.subtitle;\n      modalBody.textContent = info.desc;\n      modalBackdrop.style.display = 'flex';\n      document.getElementById('overlay').style.pointerEvents = 'auto';\n    }\n    function hideModal(){\n      modalBackdrop.style.display = 'none';\n      document.getElementById('overlay').style.pointerEvents = 'none';\n    }\n\n    function onWindowResize(){\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    // Keyboard movement for desktop fallback\n    const keys = { w:false, a:false, s:false, d:false, q:false, e:false };\n    function initKeyboard(){\n      window.addEventListener('keydown', (e)=>{\n        if (e.repeat) return;\n        setKey(e.code, true);\n      });\n      window.addEventListener('keyup', (e)=>{\n        setKey(e.code, false);\n      });\n    }\n    function setKey(code,val){\n      if (code==='KeyW') keys.w = val;\n      if (code==='KeyA') keys.a = val;\n      if (code==='KeyS') keys.s = val;\n      if (code==='KeyD') keys.d = val;\n      if (code==='KeyQ') keys.q = val;\n      if (code==='KeyE') keys.e = val;\n    }\n    function updateKeyboard(dt){\n      if (renderer.xr.isPresenting) return; // camera controlled by XR\n      const speed = 2.5; // m/s\n      const v = new THREE.Vector3();\n      camera.getWorldDirection(v);\n      v.y = 0; v.normalize();\n      const right = new THREE.Vector3().crossVectors(v, new THREE.Vector3(0,1,0)).normalize().negate();\n      const move = new THREE.Vector3();\n      if (keys.w) move.add(v);\n      if (keys.s) move.addScaledVector(v, -1);\n      if (keys.a) move.addScaledVector(right, -1);\n      if (keys.d) move.addScaledVector(right, 1);\n      if (keys.q) camera.position.y -= speed*dt;\n      if (keys.e) camera.position.y += speed*dt;\n      if (move.lengthSq()>0){\n        move.normalize().multiplyScalar(speed*dt);\n        camera.position.add(move);\n        controls.target.add(move);\n      }\n    }\n\n    // Per-frame animation\n    const clock = new THREE.Clock();\n    function animate(){\n      renderer.setAnimationLoop(render);\n    }\n\n    function render(){\n      const dt = clock.getDelta();\n      updateKeyboard(dt);\n      controls.update();\n\n      // Controller and hand hover + reticle\n      updateControllerInteractions();\n      updateHandPointers();\n      updatePerformance(dt);\n\n      renderer.render(scene, camera);\n    }\n\n    function updateControllerInteractions(){\n      let reticleVisible = false;\n\n      [controller1, controller2].forEach((con)=>{\n        if (!con) return;\n        // Floor targeting\n        const floorHit = intersectFromController(con, teleportables);\n        if (floorHit){\n          reticle.position.copy(floorHit.point);\n          reticle.position.y += 0.01;\n          reticleVisible = true;\n        }\n        // Highlight arts on hover\n        frames.forEach(f=>f.material.color.set(0x222222));\n        const hit = intersectFromController(con, selectables);\n        if (hit){\n          const idx = selectables.indexOf(hit.object);\n          if (idx>=0) frames[idx].material.color.set(0x66ffcc);\n        }\n      });\n\n      reticle.visible = reticleVisible;\n    }\n\n    function updateHandPointers(){\n      [hand1, hand2].forEach((hand, idx)=>{\n        const tip = hand && hand.getObjectByName && hand.getObjectByName('index-finger-tip');\n        const knuckle = hand && hand.getObjectByName && hand.getObjectByName('index-finger-metacarpal');\n        const line = idx===0 ? handPointer1 : handPointer2;\n        if (hand && tip && knuckle && line){\n          const a = new THREE.Vector3(), b = new THREE.Vector3();\n          tip.getWorldPosition(a); knuckle.getWorldPosition(b);\n          const dir = a.clone().sub(b).normalize();\n          // Position the line at the tip and orient along dir\n          line.position.copy(tip.worldToLocal(a.clone())); // place relative to hand\n          const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dir.clone().negate());\n          line.quaternion.copy(q);\n          // Hover highlighting\n          raycaster.set(a, dir);\n          const hit = raycaster.intersectObjects(selectables, false)[0];\n          if (hit){\n            const idx2 = selectables.indexOf(hit.object);\n            if (idx2>=0) frames[idx2].material.color.set(0x66ffcc);\n          }\n          // Floor reticle from hand\n          const floorHit = raycaster.intersectObjects(teleportables, false)[0];\n          if (floorHit){\n            reticle.position.copy(floorHit.point);\n            reticle.position.y += 0.01;\n            reticle.visible = true;\n          }\n        }\n      });\n    }\n\n    // Performance management: dynamic pixel ratio + FPS display\n    function updatePerformance(dt){\n      // FPS EMA\n      const fps = 1 / Math.max(1e-6, dt);\n      frameTimes.push(fps);\n      if (frameTimes.length > 30) frameTimes.shift();\n      const avgFps = frameTimes.reduce((a,b)=>a+b,0)/frameTimes.length;\n      fpsLabel.textContent = 'FPS: ' + avgFps.toFixed(0);\n\n      const now = performance.now();\n      const isVR = renderer.xr.isPresenting;\n      const target = isVR ? targetFPS : 60;\n      if (now - lastPerfAdjust > 1200){\n        // Adjust pixel ratio gently to chase target\n        if (avgFps < target - 6){\n          currentPixelRatio = clamp(currentPixelRatio * 0.92, pixelRatioMin, pixelRatioMax);\n          renderer.setPixelRatio(currentPixelRatio);\n        } else if (avgFps > target + 6){\n          currentPixelRatio = clamp(currentPixelRatio * 1.05, pixelRatioMin, pixelRatioMax);\n          renderer.setPixelRatio(currentPixelRatio);\n        }\n        lastPerfAdjust = now;\n      }\n    }\n\n    // Accessibility: keyboard Escape closes modal\n    window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') hideModal(); });\n\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 142.40460300445557,
    "status": "success",
    "timestamp": "2025-08-29 17:48:58"
  },
  {
    "test_name": "physics_playground",
    "prompt": "Create a complete HTML file with Three.js integrated with a lightweight physics engine (cannon-es or similar) that includes stackable boxes, spheres, hinge joints, ragdoll, and interactive dragging with the mouse. Add reset button, gravity slider, and slow-motion toggle. The HTML file should be self-contained with Three.js and physics engine loaded from CDN. Save the output as 'physics_playground.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Physics Playground - Three.js + cannon-es</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      background: #0e0f12;\n      color: #eaeaea;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;\n      height: 100%;\n    }\n    #ui {\n      position: absolute;\n      top: 12px;\n      left: 12px;\n      padding: 10px 12px;\n      background: rgba(0, 0, 0, 0.55);\n      border: 1px solid rgba(255,255,255,0.1);\n      border-radius: 8px;\n      backdrop-filter: blur(6px);\n      z-index: 10;\n      user-select: none;\n    }\n    #ui h1 {\n      margin: 0 0 8px 0;\n      font-size: 14px;\n      font-weight: 600;\n      color: #fff;\n      opacity: 0.95;\n    }\n    #ui .row {\n      display: flex;\n      align-items: center;\n      gap: 10px;\n      margin: 6px 0;\n      flex-wrap: wrap;\n    }\n    #ui button, #ui input[type=\"range\"], #ui input[type=\"checkbox\"], #ui label {\n      cursor: pointer;\n    }\n    #ui button {\n      background: #3a7afe;\n      color: white;\n      border: 0;\n      padding: 6px 10px;\n      border-radius: 6px;\n      font-weight: 600;\n      box-shadow: 0 2px 0 rgba(0,0,0,0.25);\n    }\n    #ui button:active {\n      transform: translateY(1px);\n      box-shadow: 0 1px 0 rgba(0,0,0,0.25);\n    }\n    #ui .small {\n      font-size: 12px;\n      color: #cfcfcf;\n      opacity: 0.9;\n      line-height: 1.35;\n    }\n    #help {\n      position: absolute;\n      bottom: 12px;\n      left: 12px;\n      padding: 8px 10px;\n      background: rgba(0, 0, 0, 0.45);\n      border-radius: 8px;\n      font-size: 12px;\n      color: #dcdcdc;\n      max-width: min(420px, calc(100vw - 24px));\n    }\n    a, a:visited {\n      color: #9ad1ff;\n      text-decoration: none;\n    }\n    .value {\n      min-width: 56px;\n      display: inline-block;\n      text-align: right;\n      font-variant-numeric: tabular-nums;\n      color: #a2ffa2;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"ui\">\n    <h1>Physics Playground</h1>\n    <div class=\"row\">\n      <button id=\"resetBtn\" title=\"Reset scene\">Reset</button>\n      <label title=\"Slow motion\">\n        <input type=\"checkbox\" id=\"slowMoChk\" />\n        Slow motion\n      </label>\n    </div>\n    <div class=\"row\">\n      <label for=\"gravitySlider\">Gravity Y</label>\n      <input id=\"gravitySlider\" type=\"range\" min=\"-20\" max=\"0\" step=\"0.1\" value=\"-9.8\" />\n      <span class=\"value\" id=\"gravityVal\">-9.8</span>\n    </div>\n    <div class=\"small\">\n      - Drag dynamic objects with Left Mouse (or touch)<br />\n      - Orbit: Right Mouse / two-finger drag, Zoom: Wheel / pinch\n    </div>\n  </div>\n  <div id=\"help\">\n    Included: stackable boxes and spheres, hinge demo (door), simple ragdoll, mouse dragging, gravity control, slow-motion, and reset.\n  </div>\n\n  <script type=\"module\">\n    // Import Three.js and cannon-es from CDNs\n    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';\n    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';\n    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';\n\n    // THREE globals\n    let scene, renderer, camera, controls, clock;\n    let dynamicGroup; // holds all dynamic meshes for easy reset\n\n    // CANNON globals\n    let world;\n    let physicsPairs = []; // { mesh, body }\n    let constraints = [];  // store constraints for cleanup\n\n    // Mouse drag interaction\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n    let dragPlane = null;\n    let isDragging = false;\n    let grabbed = {\n      body: null,\n      constraint: null,\n      localPivot: new CANNON.Vec3(),\n      anchorBody: null,\n      lastAnchorPos: new THREE.Vector3()\n    };\n\n    // Simulation control\n    let timeScale = 1.0; // 1.0 normal speed, <1 slow motion\n    const fixedTimeStep = 1 / 60;\n    const maxSubSteps = 10;\n\n    // Materials (visual)\n    const materials = {\n      ground: new THREE.MeshStandardMaterial({ color: 0x30343b, metalness: 0.0, roughness: 0.8 }),\n      box:    new THREE.MeshStandardMaterial({ color: 0x6fa8dc, metalness: 0.1, roughness: 0.7 }),\n      boxAlt: new THREE.MeshStandardMaterial({ color: 0xf6b26b, metalness: 0.1, roughness: 0.7 }),\n      sphere: new THREE.MeshStandardMaterial({ color: 0x93c47d, metalness: 0.1, roughness: 0.5 }),\n      rag:    new THREE.MeshStandardMaterial({ color: 0xc27ba0, metalness: 0.0, roughness: 0.9 }),\n      door:   new THREE.MeshStandardMaterial({ color: 0xbcbcbc, metalness: 0.0, roughness: 0.9 }),\n    };\n\n    // UI elements\n    const ui = {\n      resetBtn: null,\n      slowMoChk: null,\n      gravitySlider: null,\n      gravityVal: null\n    };\n\n    init();\n\n    function init() {\n      initThree();\n      initPhysicsWorld();\n      buildSceneContents();\n      setupUI();\n      animate();\n      window.addEventListener('resize', onResize);\n    }\n\n    function initThree() {\n      scene = new THREE.Scene();\n      scene.background = new THREE.Color(0x0e0f12);\n      clock = new THREE.Clock();\n\n      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);\n      camera.position.set(8, 6, 10);\n\n      renderer = new THREE.WebGLRenderer({ antialias: true });\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n      renderer.shadowMap.enabled = true;\n      renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      renderer.outputColorSpace = THREE.SRGBColorSpace;\n      document.body.appendChild(renderer.domElement);\n\n      controls = new OrbitControls(camera, renderer.domElement);\n      controls.enableDamping = true;\n      controls.dampingFactor = 0.05;\n      controls.maxDistance = 50;\n      controls.target.set(0, 1, 0);\n      controls.update();\n\n      // Lights\n      const hemi = new THREE.HemisphereLight(0xffffff, 0x202020, 0.8);\n      scene.add(hemi);\n\n      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);\n      dirLight.position.set(10, 12, 8);\n      dirLight.castShadow = true;\n      dirLight.shadow.mapSize.set(2048, 2048);\n      dirLight.shadow.camera.near = 1;\n      dirLight.shadow.camera.far = 50;\n      dirLight.shadow.camera.left = -20;\n      dirLight.shadow.camera.right = 20;\n      dirLight.shadow.camera.top = 20;\n      dirLight.shadow.camera.bottom = -20;\n      scene.add(dirLight);\n\n      // Grid & ambient feel\n      const grid = new THREE.GridHelper(100, 100, 0x666666, 0x333333);\n      grid.position.y = 0.001;\n      scene.add(grid);\n\n      // Mouse inputs for dragging\n      renderer.domElement.addEventListener('pointerdown', onPointerDown);\n      window.addEventListener('pointermove', onPointerMove);\n      window.addEventListener('pointerup', onPointerUp);\n    }\n\n    function initPhysicsWorld() {\n      world = new CANNON.World({\n        gravity: new CANNON.Vec3(0, -9.82, 0)\n      });\n      world.broadphase = new CANNON.SAPBroadphase(world);\n      world.allowSleep = true;\n      world.solver.iterations = 10;\n\n      // Default materials\n      const defaultMat = new CANNON.Material('default');\n      const slippery = new CANNON.Material('slippery');\n\n      const defaultContact = new CANNON.ContactMaterial(defaultMat, defaultMat, {\n        friction: 0.4,\n        restitution: 0.15\n      });\n      const slipContact = new CANNON.ContactMaterial(defaultMat, slippery, {\n        friction: 0.1,\n        restitution: 0.05\n      });\n      world.defaultContactMaterial = defaultContact;\n      world.addContactMaterial(defaultContact);\n      world.addContactMaterial(slipContact);\n\n      // Create groups\n      dynamicGroup = new THREE.Group();\n      scene.add(dynamicGroup);\n\n      // Ground\n      const groundSize = 100;\n      const groundGeom = new THREE.BoxGeometry(groundSize, 1, groundSize);\n      const groundMesh = new THREE.Mesh(groundGeom, materials.ground);\n      groundMesh.position.set(0, -0.5, 0);\n      groundMesh.receiveShadow = true;\n      scene.add(groundMesh);\n\n      const groundBody = new CANNON.Body({\n        mass: 0,\n        shape: new CANNON.Box(new CANNON.Vec3(groundSize / 2, 0.5, groundSize / 2)),\n        material: defaultMat\n      });\n      groundBody.position.copy(threeToCannonVec(groundMesh.position));\n      world.addBody(groundBody);\n    }\n\n    function buildSceneContents() {\n      // Clear dynamic content if any\n      clearDynamic();\n\n      // Add stackable boxes and spheres\n      buildStacks();\n\n      // Hinge demo: simple door on a post\n      addHingeDoor(new THREE.Vector3(-6, 0.9, -2));\n\n      // Add a ragdoll\n      addRagdoll(new THREE.Vector3(2.5, 2.5, 0));\n    }\n\n    function clearDynamic() {\n      // Remove existing constraints\n      constraints.forEach(c => world.removeConstraint(c));\n      constraints.length = 0;\n\n      // Remove bodies for dynamic items (leaving ground)\n      physicsPairs.forEach(p => {\n        try { world.removeBody(p.body); } catch (e) {}\n      });\n      physicsPairs.length = 0;\n\n      // Remove dynamic meshes\n      while (dynamicGroup.children.length) {\n        const child = dynamicGroup.children.pop();\n        child.geometry?.dispose?.();\n        if (Array.isArray(child.material)) {\n          child.material.forEach(m => m.dispose?.());\n        } else {\n          child.material?.dispose?.();\n        }\n        scene.remove(child);\n      }\n\n      // Reset dragging if active\n      if (isDragging) {\n        endDrag();\n      }\n    }\n\n    function setupUI() {\n      ui.resetBtn = document.getElementById('resetBtn');\n      ui.slowMoChk = document.getElementById('slowMoChk');\n      ui.gravitySlider = document.getElementById('gravitySlider');\n      ui.gravityVal = document.getElementById('gravityVal');\n\n      ui.resetBtn.addEventListener('click', () => {\n        // Recreate world to fully reset simulation state\n        scene.remove(dynamicGroup);\n        initPhysicsWorld();\n        buildSceneContents();\n        updateGravityFromUI();\n      });\n\n      ui.slowMoChk.addEventListener('change', (e) => {\n        timeScale = e.target.checked ? 0.2 : 1.0;\n      });\n\n      ui.gravitySlider.addEventListener('input', () => {\n        updateGravityFromUI();\n      });\n      updateGravityFromUI();\n    }\n\n    function updateGravityFromUI() {\n      const gy = parseFloat(ui.gravitySlider.value);\n      ui.gravityVal.textContent = gy.toFixed(1);\n      world.gravity.set(0, gy, 0);\n    }\n\n    // Builders\n\n    function buildStacks() {\n      const baseX = -1.5;\n      const baseZ = 2.5;\n\n      // Tower of boxes\n      const levels = 6;\n      for (let i = 0; i < levels; i++) {\n        const size = new THREE.Vector3(0.6, 0.4, 0.6);\n        const x = baseX + (Math.random() - 0.5) * 0.3;\n        const y = 0.2 + i * (size.y + 0.01);\n        const z = baseZ + (Math.random() - 0.5) * 0.3;\n        addBox(size, new THREE.Vector3(x, y, z), 1.0, i % 2 ? materials.box : materials.boxAlt);\n      }\n\n      // Stack of alternating boxes and spheres\n      const colX = 0.0;\n      const colZ = -2.5;\n      for (let i = 0; i < 5; i++) {\n        if (i % 2 === 0) {\n          const s = 0.5;\n          addBox(new THREE.Vector3(s, s, s), new THREE.Vector3(colX, 0.25 + i * (s + 0.02), colZ), 0.8, materials.boxAlt);\n        } else {\n          const r = 0.32;\n          addSphere(r, new THREE.Vector3(colX, r + i * (r * 2 + 0.02), colZ), 0.6, materials.sphere);\n        }\n      }\n\n      // A few loose spheres\n      for (let i = 0; i < 8; i++) {\n        const r = 0.25 + Math.random() * 0.15;\n        const px = -2 + Math.random() * 4;\n        const py = 2 + Math.random() * 2;\n        const pz = -3 + Math.random() * 6;\n        addSphere(r, new THREE.Vector3(px, py, pz), 0.5, materials.sphere);\n      }\n    }\n\n    function addHingeDoor(position) {\n      // Create a \"post\" (static) and a \"door\" (dynamic) connected with hinge\n      const doorW = 1.2, doorH = 1.8, doorD = 0.12;\n\n      // Visual post (optional)\n      const postGeom = new THREE.BoxGeometry(0.15, doorH + 0.2, 0.2);\n      const postMesh = new THREE.Mesh(postGeom, materials.door);\n      postMesh.position.set(position.x - doorW/2 - 0.075, position.y, position.z);\n      postMesh.castShadow = true;\n      postMesh.receiveShadow = true;\n      dynamicGroup.add(postMesh); // keep in dynamicGroup for easy cleanup, though it's static in physics\n\n      const postBody = new CANNON.Body({ mass: 0 });\n      postBody.addShape(new CANNON.Box(new CANNON.Vec3(0.075, (doorH + 0.2)/2, 0.1)));\n      postBody.position.copy(threeToCannonVec(postMesh.position));\n      world.addBody(postBody);\n\n      const doorGeom = new THREE.BoxGeometry(doorW, doorH, doorD);\n      const doorMesh = new THREE.Mesh(doorGeom, materials.door);\n      doorMesh.position.copy(position);\n      doorMesh.castShadow = true;\n      doorMesh.receiveShadow = true;\n      dynamicGroup.add(doorMesh);\n\n      const doorBody = new CANNON.Body({ mass: 5 });\n      doorBody.addShape(new CANNON.Box(new CANNON.Vec3(doorW/2, doorH/2, doorD/2)));\n      doorBody.position.copy(threeToCannonVec(doorMesh.position));\n      world.addBody(doorBody);\n\n      linkBodyMesh(doorBody, doorMesh);\n\n      // Hinge axis: vertical Y\n      const hinge = new CANNON.HingeConstraint(doorBody, postBody, {\n        pivotA: new CANNON.Vec3(-doorW/2, 0, 0), // left edge of door\n        axisA: new CANNON.Vec3(0, 1, 0),\n        pivotB: new CANNON.Vec3(0.075, 0, 0),    // center of post (offset to align)\n        axisB: new CANNON.Vec3(0, 1, 0),\n        collideConnected: false\n      });\n      hinge.setLimits(-Math.PI * 0.95, Math.PI * 0.95, 0.9, 0.3);\n      world.addConstraint(hinge);\n      constraints.push(hinge);\n    }\n\n    function addRagdoll(origin = new THREE.Vector3()) {\n      // Simple box/sphere ragdoll with hinge joints\n\n      // Dimensions\n      const torsoSize = new THREE.Vector3(0.4, 0.6, 0.2);\n      const pelvisSize = new THREE.Vector3(0.35, 0.3, 0.2);\n      const headRadius = 0.15;\n      const upperArm = new THREE.Vector3(0.3, 0.12, 0.12);\n      const lowerArm = new THREE.Vector3(0.3, 0.1, 0.1);\n      const upperLeg = new THREE.Vector3(0.2, 0.45, 0.2);\n      const lowerLeg = new THREE.Vector3(0.18, 0.45, 0.18);\n\n      // Bodies\n      const pelvis = addBox(pelvisSize, origin.clone().add(new THREE.Vector3(0, 1.2, 0)), 2.0, materials.rag).body;\n      const torso  = addBox(torsoSize,  origin.clone().add(new THREE.Vector3(0, 1.2 + (pelvisSize.y/2 + torsoSize.y/2), 0)), 2.5, materials.rag).body;\n      const head   = addSphere(headRadius, origin.clone().add(new THREE.Vector3(0, 1.2 + pelvisSize.y + torsoSize.y + headRadius, 0)), 0.8, materials.rag).body;\n\n      // Arms L/R\n      const shoulderY = pelvis.position.y + pelvisSize.y/2 + torsoSize.y/2;\n      const shoulderOffsetX = torsoSize.x/2 + upperArm.x/2;\n      const elbowOffset = (upperArm.x/2 + lowerArm.x/2);\n\n      const uArmL = addBox(upperArm, new THREE.Vector3().copy(origin).setX(origin.x - shoulderOffsetX).setY(shoulderY).setZ(origin.z), 1.0, materials.rag).body;\n      const lArmL = addBox(lowerArm, new THREE.Vector3().copy(origin).setX(origin.x - shoulderOffsetX - lowerArm.x - 0.02).setY(shoulderY).setZ(origin.z), 0.8, materials.rag).body;\n\n      const uArmR = addBox(upperArm, new THREE.Vector3().copy(origin).setX(origin.x + shoulderOffsetX).setY(shoulderY).setZ(origin.z), 1.0, materials.rag).body;\n      const lArmR = addBox(lowerArm, new THREE.Vector3().copy(origin).setX(origin.x + shoulderOffsetX + lowerArm.x + 0.02).setY(shoulderY).setZ(origin.z), 0.8, materials.rag).body;\n\n      // Legs L/R\n      const hipY = pelvis.position.y - pelvisSize.y/2 - upperLeg.y/2;\n      const kneeY = hipY - upperLeg.y/2 - lowerLeg.y/2;\n      const hipOffsetX = pelvisSize.x * 0.25;\n\n      const uLegL = addBox(upperLeg, new THREE.Vector3(origin.x - hipOffsetX, hipY, origin.z), 1.6, materials.rag).body;\n      const lLegL = addBox(lowerLeg, new THREE.Vector3(origin.x - hipOffsetX, kneeY, origin.z), 1.2, materials.rag).body;\n\n      const uLegR = addBox(upperLeg, new THREE.Vector3(origin.x + hipOffsetX, hipY, origin.z), 1.6, materials.rag).body;\n      const lLegR = addBox(lowerLeg, new THREE.Vector3(origin.x + hipOffsetX, kneeY, origin.z), 1.2, materials.rag).body;\n\n      // Constraints\n      const axisZ = new CANNON.Vec3(0, 0, 1); // bend front/back if arms lie along X\n      const axisX = new CANNON.Vec3(1, 0, 0); // nodding neck\n\n      // Pelvis to Torso (spine hinge)\n      constraints.push(addHinge(torso, pelvis,\n        new CANNON.Vec3(0, -torsoSize.y/2, 0),\n        new CANNON.Vec3(0, pelvisSize.y/2, 0),\n        axisZ, axisZ, -0.5, 0.5));\n\n      // Neck (Torso to Head)\n      constraints.push(addHinge(head, torso,\n        new CANNON.Vec3(0, -headRadius, 0),\n        new CANNON.Vec3(0, torsoSize.y/2, 0),\n        axisX, axisX, -0.5, 0.5));\n\n      // Shoulders\n      constraints.push(addHinge(uArmL, torso,\n        new CANNON.Vec3(upperArm.x/2, 0, 0),\n        new CANNON.Vec3(-torsoSize.x/2, 0, 0),\n        axisZ, axisZ, -1.2, 1.2));\n      constraints.push(addHinge(uArmR, torso,\n        new CANNON.Vec3(-upperArm.x/2, 0, 0),\n        new CANNON.Vec3(torsoSize.x/2, 0, 0),\n        axisZ, axisZ, -1.2, 1.2));\n\n      // Elbows\n      constraints.push(addHinge(lArmL, uArmL,\n        new CANNON.Vec3(lowerArm.x/2, 0, 0),\n        new CANNON.Vec3(-upperArm.x/2, 0, 0),\n        axisZ, axisZ, 0, 2.4));\n      constraints.push(addHinge(lArmR, uArmR,\n        new CANNON.Vec3(-lowerArm.x/2, 0, 0),\n        new CANNON.Vec3(upperArm.x/2, 0, 0),\n        axisZ, axisZ, 0, 2.4));\n\n      // Hips\n      constraints.push(addHinge(uLegL, pelvis,\n        new CANNON.Vec3(0, upperLeg.y/2, 0),\n        new CANNON.Vec3(-hipOffsetX + 0, -pelvisSize.y/2, 0),\n        axisZ, axisZ, -0.7, 0.7));\n      constraints.push(addHinge(uLegR, pelvis,\n        new CANNON.Vec3(0, upperLeg.y/2, 0),\n        new CANNON.Vec3(hipOffsetX + 0, -pelvisSize.y/2, 0),\n        axisZ, axisZ, -0.7, 0.7));\n\n      // Knees\n      constraints.push(addHinge(lLegL, uLegL,\n        new CANNON.Vec3(0, lowerLeg.y/2, 0),\n        new CANNON.Vec3(0, -upperLeg.y/2, 0),\n        axisZ, axisZ, 0, 2.2));\n      constraints.push(addHinge(lLegR, uLegR,\n        new CANNON.Vec3(0, lowerLeg.y/2, 0),\n        new CANNON.Vec3(0, -upperLeg.y/2, 0),\n        axisZ, axisZ, 0, 2.2));\n    }\n\n    function addHinge(bodyA, bodyB, pivotA, pivotB, axisA, axisB, lowerLimit, upperLimit) {\n      const hinge = new CANNON.HingeConstraint(bodyA, bodyB, {\n        pivotA, pivotB, axisA, axisB, collideConnected: false\n      });\n      if (typeof lowerLimit === 'number' && typeof upperLimit === 'number') {\n        hinge.setLimits(lowerLimit, upperLimit, 0.9, 0.3);\n      }\n      world.addConstraint(hinge);\n      return hinge;\n    }\n\n    // Primitive adders\n\n    function addBox(size, position, mass = 1, material = materials.box) {\n      const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n      dynamicGroup.add(mesh);\n\n      const half = new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2);\n      const shape = new CANNON.Box(half);\n      const body = new CANNON.Body({ mass });\n      body.addShape(shape);\n      body.position.copy(threeToCannonVec(position));\n      world.addBody(body);\n\n      linkBodyMesh(body, mesh);\n      return { body, mesh };\n    }\n\n    function addSphere(radius, position, mass = 1, material = materials.sphere) {\n      const geometry = new THREE.SphereGeometry(radius, 24, 18);\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n      dynamicGroup.add(mesh);\n\n      const shape = new CANNON.Sphere(radius);\n      const body = new CANNON.Body({ mass });\n      body.addShape(shape);\n      body.position.copy(threeToCannonVec(position));\n      world.addBody(body);\n\n      linkBodyMesh(body, mesh);\n      return { body, mesh };\n    }\n\n    function linkBodyMesh(body, mesh) {\n      mesh.userData.body = body;\n      body.userData = { mesh };\n      physicsPairs.push({ mesh, body });\n    }\n\n    // Dragging via PointToPointConstraint to a kinematic \"anchor\" body\n\n    function onPointerDown(e) {\n      const pos = getMouse(e);\n      mouse.copy(pos);\n      raycaster.setFromCamera(mouse, camera);\n\n      const intersects = raycaster.intersectObjects(dynamicGroup.children, false)\n        .filter(int => int.object.visible && int.object.userData?.body && int.object.userData.body.mass > 0);\n\n      if (intersects.length > 0) {\n        const hit = intersects[0];\n        const mesh = hit.object;\n        const body = mesh.userData.body;\n        const hitPoint = hit.point.clone();\n\n        // Create a dragging plane at the hit point, normal to camera direction\n        const camDir = new THREE.Vector3();\n        camera.getWorldDirection(camDir);\n        dragPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, hitPoint);\n\n        beginDrag(body, hitPoint);\n      }\n    }\n\n    function onPointerMove(e) {\n      const pos = getMouse(e);\n      mouse.copy(pos);\n\n      if (isDragging && dragPlane) {\n        raycaster.setFromCamera(mouse, camera);\n        const point = new THREE.Vector3();\n        if (raycaster.ray.intersectPlane(dragPlane, point)) {\n          moveDragAnchor(point);\n        }\n      }\n    }\n\n    function onPointerUp() {\n      if (isDragging) {\n        endDrag();\n      }\n    }\n\n    function beginDrag(body, worldPoint) {\n      isDragging = true;\n      grabbed.body = body;\n\n      // Create anchor body if needed\n      if (!grabbed.anchorBody) {\n        grabbed.anchorBody = new CANNON.Body({\n          mass: 0,\n          type: CANNON.Body.KINEMATIC,\n          shape: new CANNON.Sphere(0.01) // tiny\n        });\n        world.addBody(grabbed.anchorBody);\n      }\n\n      grabbed.anchorBody.position.set(worldPoint.x, worldPoint.y, worldPoint.z);\n      grabbed.lastAnchorPos.copy(worldPoint);\n\n      // Compute local pivot in body coordinates\n      const wp = new CANNON.Vec3(worldPoint.x, worldPoint.y, worldPoint.z);\n      const local = new CANNON.Vec3();\n      body.pointToLocalFrame(wp, local);\n      grabbed.localPivot.copy(local);\n\n      // Create constraint\n      grabbed.constraint = new CANNON.PointToPointConstraint(\n        body, grabbed.localPivot,\n        grabbed.anchorBody, new CANNON.Vec3(0, 0, 0)\n      );\n      world.addConstraint(grabbed.constraint);\n      constraints.push(grabbed.constraint);\n    }\n\n    function moveDragAnchor(worldPoint) {\n      // Update anchor position and velocity (since KINEMATIC)\n      const dt = Math.max(1e-3, clock.getDelta()); // use recent delta as estimate\n      grabbed.anchorBody.velocity.set(\n        (worldPoint.x - grabbed.lastAnchorPos.x) / dt,\n        (worldPoint.y - grabbed.lastAnchorPos.y) / dt,\n        (worldPoint.z - grabbed.lastAnchorPos.z) / dt\n      );\n      grabbed.anchorBody.position.set(worldPoint.x, worldPoint.y, worldPoint.z);\n      grabbed.lastAnchorPos.copy(worldPoint);\n    }\n\n    function endDrag() {\n      if (grabbed.constraint) {\n        world.removeConstraint(grabbed.constraint);\n        const idx = constraints.indexOf(grabbed.constraint);\n        if (idx >= 0) constraints.splice(idx, 1);\n        grabbed.constraint = null;\n      }\n      grabbed.body = null;\n      isDragging = false;\n      dragPlane = null;\n    }\n\n    function animate() {\n      requestAnimationFrame(animate);\n\n      const delta = clock.getDelta();\n      const scaled = delta * timeScale;\n      world.step(fixedTimeStep, scaled, maxSubSteps);\n\n      // Sync Three.js meshes with Cannon bodies\n      for (let i = 0; i < physicsPairs.length; i++) {\n        const { mesh, body } = physicsPairs[i];\n        mesh.position.copy(cannonToThreeVec(body.position));\n        mesh.quaternion.copy(cannonToThreeQuat(body.quaternion));\n      }\n\n      controls.update();\n      renderer.render(scene, camera);\n    }\n\n    function getMouse(e) {\n      const rect = renderer.domElement.getBoundingClientRect();\n      return new THREE.Vector2(\n        ((e.clientX - rect.left) / rect.width) * 2 - 1,\n        -((e.clientY - rect.top) / rect.height) * 2 + 1\n      );\n    }\n\n    function onResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    // Helpers: conversions\n    function threeToCannonVec(v) { return new CANNON.Vec3(v.x, v.y, v.z); }\n    function cannonToThreeVec(v) { return new THREE.Vector3(v.x, v.y, v.z); }\n    function cannonToThreeQuat(q) { return new THREE.Quaternion(q.x, q.y, q.z, q.w); }\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 211.10805797576904,
    "status": "success",
    "timestamp": "2025-08-29 17:52:30"
  },
  {
    "test_name": "data_driven_dashboard",
    "prompt": "Create a complete HTML file with Three.js that creates a 3D analytics scene turning a random dataset into bars, scatter points, and ribbons on a 3D grid. Include axis helpers, tooltips on hover, camera tween to views, theme toggle (dark/light), and CSV export of generated data. The HTML file should be self-contained with Three.js loaded from CDN and include sample data generation. Save the output as 'data_dashboard.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>3D Data Dashboard - Three.js</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0b0f1a;\n      --panel-bg: rgba(14, 23, 42, 0.6);\n      --panel-border: rgba(255,255,255,0.08);\n      --text: #e5e7eb;\n      --accent: #60a5fa;\n      --muted: #94a3b8;\n      --btn-bg: rgba(255,255,255,0.06);\n      --btn-bg-hover: rgba(255,255,255,0.12);\n      --btn-border: rgba(255,255,255,0.12);\n      --shadow: 0 10px 30px rgba(0,0,0,0.35);\n    }\n    .light {\n      --bg: #f5f7fb;\n      --panel-bg: rgba(255,255,255,0.8);\n      --panel-border: rgba(0,0,0,0.08);\n      --text: #0f172a;\n      --accent: #2563eb;\n      --muted: #475569;\n      --btn-bg: rgba(15, 23, 42, 0.04);\n      --btn-bg-hover: rgba(15, 23, 42, 0.08);\n      --btn-border: rgba(0,0,0,0.1);\n      --shadow: 0 12px 36px rgba(0,0,0,0.15);\n    }\n\n    html, body {\n      margin: 0;\n      padding: 0;\n      width: 100%;\n      height: 100%;\n      overflow: hidden;\n      background: var(--bg);\n      color: var(--text);\n      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;\n    }\n\n    #app {\n      position: fixed;\n      inset: 0;\n      display: block;\n    }\n\n    #ui {\n      position: fixed;\n      top: 16px;\n      left: 16px;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      z-index: 10;\n      user-select: none;\n    }\n\n    .panel {\n      backdrop-filter: blur(10px);\n      -webkit-backdrop-filter: blur(10px);\n      background: var(--panel-bg);\n      border: 1px solid var(--panel-border);\n      border-radius: 12px;\n      padding: 12px;\n      box-shadow: var(--shadow);\n      min-width: 280px;\n    }\n\n    .panel h2 {\n      margin: 0 0 8px;\n      font-size: 14px;\n      letter-spacing: 0.02em;\n      font-weight: 700;\n      text-transform: uppercase;\n      color: var(--muted);\n    }\n\n    .row {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n      align-items: center;\n    }\n\n    .row + .row {\n      margin-top: 8px;\n    }\n\n    button, .toggle {\n      appearance: none;\n      border: 1px solid var(--btn-border);\n      background: var(--btn-bg);\n      color: var(--text);\n      border-radius: 10px;\n      padding: 8px 12px;\n      font-size: 13px;\n      line-height: 1.2;\n      cursor: pointer;\n      transition: background 0.2s ease, border-color 0.2s ease, transform 0.06s ease;\n    }\n    button:hover, .toggle:hover {\n      background: var(--btn-bg-hover);\n    }\n    button:active {\n      transform: translateY(1px);\n    }\n\n    .toggle {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n    }\n\n    .toggle input {\n      margin: 0;\n      width: 18px;\n      height: 18px;\n      accent-color: var(--accent);\n    }\n\n    .view-buttons button {\n      flex: 1 1 auto;\n    }\n\n    #tooltip {\n      position: fixed;\n      pointer-events: none;\n      z-index: 20;\n      transform: translate(12px, 12px);\n      background: rgba(17, 24, 39, 0.9);\n      color: #e5e7eb;\n      border: 1px solid rgba(255,255,255,0.08);\n      box-shadow: 0 10px 30px rgba(0,0,0,0.35);\n      padding: 8px 10px;\n      border-radius: 8px;\n      font-size: 12px;\n      line-height: 1.35;\n      max-width: 260px;\n      opacity: 0;\n      transition: opacity 0.12s ease;\n      white-space: nowrap;\n    }\n    .light #tooltip {\n      background: rgba(255,255,255,0.95);\n      color: #0f172a;\n      border-color: rgba(0,0,0,0.08);\n    }\n\n    .legend {\n      display: flex;\n      gap: 12px;\n      font-size: 12px;\n      align-items: center;\n      flex-wrap: wrap;\n      color: var(--muted);\n    }\n    .legend .key {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n    }\n    .legend .swatch {\n      width: 12px;\n      height: 12px;\n      border-radius: 3px;\n      border: 1px solid var(--panel-border);\n    }\n\n    .footer-note {\n      position: fixed;\n      right: 16px;\n      bottom: 12px;\n      z-index: 10;\n      color: var(--muted);\n      font-size: 12px;\n      background: var(--panel-bg);\n      border: 1px solid var(--panel-border);\n      border-radius: 10px;\n      padding: 8px 10px;\n      box-shadow: var(--shadow);\n      backdrop-filter: blur(10px);\n      -webkit-backdrop-filter: blur(10px);\n    }\n  </style>\n</head>\n<body class=\"\">\n  <div id=\"app\"></div>\n\n  <div id=\"ui\">\n    <div class=\"panel\">\n      <h2>Scene Controls</h2>\n      - Views\n      <div class=\"row view-buttons\">\n        <button id=\"view-iso\">Isometric</button>\n        <button id=\"view-top\">Top</button>\n        <button id=\"view-front\">Front</button>\n        <button id=\"view-side\">Side</button>\n      </div>\n\n      - Layers\n      <div class=\"row\">\n        <label class=\"toggle\"><input id=\"toggle-bars\" type=\"checkbox\" checked /> Bars</label>\n        <label class=\"toggle\"><input id=\"toggle-scatter\" type=\"checkbox\" checked /> Scatter</label>\n        <label class=\"toggle\"><input id=\"toggle-ribbons\" type=\"checkbox\" checked /> Ribbons</label>\n      </div>\n\n      - Actions\n      <div class=\"row\">\n        <button id=\"regen\">Regenerate Data</button>\n        <button id=\"export\">Export CSV</button>\n        <button id=\"theme\">Toggle Theme</button>\n      </div>\n\n      <div class=\"row legend\" id=\"legend\">\n        <div class=\"key\"><span class=\"swatch\" id=\"swatch-bars\"></span> Bars</div>\n        <div class=\"key\"><span class=\"swatch\" id=\"swatch-scatter\"></span> Scatter</div>\n        <div class=\"key\"><span class=\"swatch\" id=\"swatch-ribbons\"></span> Ribbons</div>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"tooltip\"></div>\n\n  <div class=\"footer-note\">Tip: Hover shapes for tooltips \u2022 Drag to orbit \u2022 Shift+Drag to pan \u2022 Wheel to zoom</div>\n\n  <!-- Three.js and helpers -->\n  <script src=\"https://unpkg.com/three@0.155.0/build/three.min.js\"></script>\n  <script src=\"https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js\"></script>\n  <script src=\"https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js\"></script>\n\n  <script>\n    (() => {\n      // Core THREE elements\n      let scene, camera, renderer, controls, raycaster;\n      let gridHelper, axesHelper, ambientLight, dirLight;\n      let app = document.getElementById('app');\n      let tooltip = document.getElementById('tooltip');\n\n      // Data + objects\n      let dataValues = [];       // 2D array [xi][zi] -> value\n      let scatterData = [];      // array of {x, y, z, label}\n      let nx = 12, nz = 16;\n      let step = 1.2;\n      let yScale = 4.0;          // overall height scale\n      let barsGroup, scatterGroup, ribbonsGroup;\n      const pickables = [];      // meshes and lines for raycasting\n      let hovered = null;\n\n      // Themes\n      let themeName = 'dark';\n      const theme = {\n        dark: {\n          bg: 0x0b0f1a,\n          grid: 0x1f2a44,\n          axes: 0xaab1c5,\n          bars: 0x60a5fa,\n          barsEmissive: 0x123a6b,\n          scatter: 0x34d399,\n          ribbons: 0xf87171,\n          lights: { ambient: 0x8899aa, dir: 0xffffff }\n        },\n        light: {\n          bg: 0xf5f7fb,\n          grid: 0xcbd5e1,\n          axes: 0x1f2937,\n          bars: 0x3b82f6,\n          barsEmissive: 0x1d4ed8,\n          scatter: 0x10b981,\n          ribbons: 0xef4444,\n          lights: { ambient: 0x8899aa, dir: 0xffffff }\n        }\n      };\n\n      // Materials (created per object for highlight control)\n      let barMaterials = [];\n      let scatterMaterials = [];\n      let ribbonMaterials = [];\n\n      // UI\n      const ui = {\n        viewIso: document.getElementById('view-iso'),\n        viewTop: document.getElementById('view-top'),\n        viewFront: document.getElementById('view-front'),\n        viewSide: document.getElementById('view-side'),\n        toggleBars: document.getElementById('toggle-bars'),\n        toggleScatter: document.getElementById('toggle-scatter'),\n        toggleRibbons: document.getElementById('toggle-ribbons'),\n        regen: document.getElementById('regen'),\n        exportBtn: document.getElementById('export'),\n        themeToggle: document.getElementById('theme'),\n        swatchBars: document.getElementById('swatch-bars'),\n        swatchScatter: document.getElementById('swatch-scatter'),\n        swatchRibbons: document.getElementById('swatch-ribbons')\n      };\n\n      init();\n      generateData();\n      buildSceneFromData();\n      animate();\n\n      function init() {\n        // Scene\n        scene = new THREE.Scene();\n\n        // Camera\n        const fov = 50;\n        const aspect = window.innerWidth / window.innerHeight;\n        const near = 0.1, far = 1000;\n        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n        camera.position.set(10, 10, 10);\n\n        // Renderer\n        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: \"high-performance\" });\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.outputColorSpace = THREE.SRGBColorSpace;\n        app.appendChild(renderer.domElement);\n\n        // Controls\n        controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n        controls.dampingFactor = 0.07;\n        controls.target.set(0, 0, 0);\n        controls.maxPolarAngle = Math.PI * 0.49;\n        controls.minDistance = 2;\n        controls.maxDistance = 60;\n\n        // Raycaster\n        raycaster = new THREE.Raycaster();\n        raycaster.params.Line = { threshold: 0.2 };\n\n        // Grid + axes\n        const size = Math.max(nx, nz) * step * 1.2;\n        gridHelper = new THREE.GridHelper(size, Math.max(nx, nz), 0x444444, 0x444444);\n        gridHelper.position.y = 0;\n        scene.add(gridHelper);\n\n        axesHelper = new THREE.AxesHelper(size * 0.6);\n        axesHelper.position.y = 0.001; // slightly above grid to avoid z-fighting\n        scene.add(axesHelper);\n\n        // Lights\n        ambientLight = new THREE.AmbientLight(theme.dark.lights.ambient, 0.7);\n        scene.add(ambientLight);\n\n        dirLight = new THREE.DirectionalLight(theme.dark.lights.dir, 1.0);\n        dirLight.position.set(6, 10, 6);\n        dirLight.castShadow = false;\n        scene.add(dirLight);\n\n        // Groups\n        barsGroup = new THREE.Group();\n        scatterGroup = new THREE.Group();\n        ribbonsGroup = new THREE.Group();\n        scene.add(barsGroup, scatterGroup, ribbonsGroup);\n\n        // UI events\n        ui.viewIso.addEventListener('click', () => gotoView('iso'));\n        ui.viewTop.addEventListener('click', () => gotoView('top'));\n        ui.viewFront.addEventListener('click', () => gotoView('front'));\n        ui.viewSide.addEventListener('click', () => gotoView('side'));\n\n        ui.toggleBars.addEventListener('change', () => { barsGroup.visible = ui.toggleBars.checked; });\n        ui.toggleScatter.addEventListener('change', () => { scatterGroup.visible = ui.toggleScatter.checked; });\n        ui.toggleRibbons.addEventListener('change', () => { ribbonsGroup.visible = ui.toggleRibbons.checked; });\n\n        ui.regen.addEventListener('click', () => {\n          generateData();\n          rebuildVisuals();\n        });\n\n        ui.exportBtn.addEventListener('click', () => exportCSV());\n\n        ui.themeToggle.addEventListener('click', () => {\n          themeName = themeName === 'dark' ? 'light' : 'dark';\n          document.body.classList.toggle('light', themeName === 'light');\n          applyTheme();\n        });\n\n        // Pointer events\n        window.addEventListener('mousemove', onPointerMove);\n        window.addEventListener('resize', onResize);\n\n        // Initial theme\n        applyTheme();\n\n        // Initial camera view\n        gotoView('iso', 0);\n      }\n\n      function applyTheme() {\n        const t = theme[themeName];\n        renderer.setClearColor(t.bg, 1);\n        gridHelper.material.color.setHex(t.grid);\n        for (let i = 0; i < gridHelper.geometry.attributes.color?.count || 0; i++) {\n          // Not necessary but keep for consistency\n        }\n        // Axes material color is fixed per axis; can't change easily. We can tint by overlaying lines:\n        axesHelper.material.color.setHex(t.axes);\n\n        ambientLight.color.setHex(t.lights.ambient);\n        dirLight.color.setHex(t.lights.dir);\n\n        // Update all materials colors\n        barMaterials.forEach(m => { m.color.setHex(t.bars); m.emissive.setHex(0x000000); });\n        scatterMaterials.forEach(m => m.color.setHex(t.scatter));\n        ribbonMaterials.forEach(m => m.color.setHex(t.ribbons));\n\n        ui.swatchBars.style.background = '#' + t.bars.toString(16).padStart(6, '0');\n        ui.swatchScatter.style.background = '#' + t.scatter.toString(16).padStart(6, '0');\n        ui.swatchRibbons.style.background = '#' + t.ribbons.toString(16).padStart(6, '0');\n      }\n\n      function generateData() {\n        // Produce a smooth, interesting surface using sin/cos + multi-octave noise\n        dataValues = [];\n        const seed = Math.random() * 1000;\n        for (let xi = 0; xi < nx; xi++) {\n          const col = [];\n          for (let zi = 0; zi < nz; zi++) {\n            const u = xi / (nx - 1 || 1);\n            const v = zi / (nz - 1 || 1);\n\n            const f1 = Math.sin((u * Math.PI * 2.0) + seed * 0.13) * 0.6 + 0.4;\n            const f2 = Math.cos((v * Math.PI * 1.6) + seed * 0.17) * 0.5 + 0.5;\n            // Smooth bumps\n            const ridge = Math.sin((u + v) * Math.PI * 1.25 + seed * 0.07) * 0.35 + 0.35;\n            // Gentle noise\n            const n = perlin2(u * 2.0 + seed, v * 2.0 - seed) * 0.25 + 0.25;\n\n            let value = (f1 * 0.45 + f2 * 0.35 + ridge * 0.2) * 0.9 + n * 0.6;\n            value = Math.max(0, value);\n            col.push(value);\n          }\n          dataValues.push(col);\n        }\n\n        // Scatter data aligned to the surface + random jitter\n        scatterData = [];\n        const scatterCount = Math.floor(nx * nz * 0.6);\n        for (let i = 0; i < scatterCount; i++) {\n          const xfi = Math.random() * (nx - 1);\n          const zfi = Math.random() * (nz - 1);\n          const xi = Math.floor(xfi);\n          const zi = Math.floor(zfi);\n          const xf = xfi - xi;\n          const zf = zfi - zi;\n          const v = bilinear(\n            dataValues[clampIndex(xi, nx)][clampIndex(zi, nz)],\n            dataValues[clampIndex(xi + 1, nx)][clampIndex(zi, nz)],\n            dataValues[clampIndex(xi, nx)][clampIndex(zi + 1, nz)],\n            dataValues[clampIndex(xi + 1, nx)][clampIndex(zi + 1, nz)],\n            xf, zf\n          );\n          const jitterY = (Math.random() - 0.5) * 0.25;\n          scatterData.push({\n            x: (xfi - (nx - 1) / 2) * step + (Math.random() - 0.5) * step * 0.15,\n            z: (zfi - (nz - 1) / 2) * step + (Math.random() - 0.5) * step * 0.15,\n            y: (v + jitterY) * yScale,\n            label: `P${i}`\n          });\n        }\n      }\n\n      function buildSceneFromData() {\n        clearGroups();\n        barMaterials.length = 0;\n        scatterMaterials.length = 0;\n        ribbonMaterials.length = 0;\n\n        // Bars (grid)\n        const barGeomBase = new THREE.BoxGeometry(step * 0.7, 1, step * 0.7); // height=1, scale later\n        for (let xi = 0; xi < nx; xi++) {\n          for (let zi = 0; zi < nz; zi++) {\n            const value = dataValues[xi][zi];\n            const h = Math.max(0.02, value * yScale);\n            const gx = (xi - (nx - 1) / 2) * step;\n            const gz = (zi - (nz - 1) / 2) * step;\n\n            const mat = new THREE.MeshStandardMaterial({\n              color: theme[themeName].bars,\n              metalness: 0.1,\n              roughness: 0.4\n            });\n            barMaterials.push(mat);\n\n            const bar = new THREE.Mesh(barGeomBase.clone(), mat);\n            bar.scale.y = h;           // scale height\n            bar.position.set(gx, h / 2, gz);\n            bar.castShadow = false;\n            bar.receiveShadow = false;\n\n            bar.userData = {\n              type: 'bar',\n              xi, zi,\n              x: gx, z: gz,\n              value: value\n            };\n\n            barsGroup.add(bar);\n            pickables.push(bar);\n          }\n        }\n\n        // Scatter (spheres)\n        const sphereGeom = new THREE.SphereGeometry(step * 0.15, 16, 16);\n        scatterData.forEach((p, idx) => {\n          const mat = new THREE.MeshStandardMaterial({\n            color: theme[themeName].scatter,\n            metalness: 0.05,\n            roughness: 0.35\n          });\n          scatterMaterials.push(mat);\n          const s = new THREE.Mesh(sphereGeom, mat);\n          s.position.set(p.x, Math.max(0.02, p.y), p.z);\n          s.userData = { type: 'point', index: idx, ...p };\n          scatterGroup.add(s);\n          pickables.push(s);\n        });\n\n        // Ribbons (lines across Z for each X series)\n        for (let xi = 0; xi < nx; xi++) {\n          const points = [];\n          for (let zi = 0; zi < nz; zi++) {\n            const gx = (xi - (nx - 1) / 2) * step;\n            const gz = (zi - (nz - 1) / 2) * step;\n            const y = dataValues[xi][zi] * yScale;\n            points.push(new THREE.Vector3(gx, Math.max(0.02, y), gz));\n          }\n          const geom = new THREE.BufferGeometry().setFromPoints(points);\n          const mat = new THREE.LineBasicMaterial({ color: theme[themeName].ribbons, transparent: true, opacity: 0.95 });\n          ribbonMaterials.push(mat);\n          const line = new THREE.Line(geom, mat);\n          line.userData = { type: 'ribbon', xi, points };\n          // Improve line raycasting sensitivity\n          // The threshold is set globally in raycaster.params.Line\n          ribbonsGroup.add(line);\n          pickables.push(line);\n        }\n      }\n\n      function rebuildVisuals() {\n        // Clear pickables\n        pickables.length = 0;\n        buildSceneFromData();\n      }\n\n      function clearGroups() {\n        // Remove all children from groups and dispose geometries/materials to prevent leaks\n        [barsGroup, scatterGroup, ribbonsGroup].forEach(group => {\n          while (group.children.length) {\n            const obj = group.children.pop();\n            if (obj.geometry) obj.geometry.dispose();\n            if (obj.material) {\n              if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());\n              else obj.material.dispose();\n            }\n          }\n        });\n      }\n\n      function gotoView(name, duration = 1000) {\n        // Compute extents\n        const width = (nx - 1) * step;\n        const depth = (nz - 1) * step;\n        const maxY = yScale * 1.2;\n        const center = new THREE.Vector3(0, 0.6 * maxY, 0);\n\n        let camPos;\n        switch (name) {\n          case 'top':\n            camPos = new THREE.Vector3(0, Math.max(8, Math.max(width, depth) * 1.4), 0.01);\n            break;\n          case 'front':\n            camPos = new THREE.Vector3(0, maxY * 1.0, depth * 1.6);\n            break;\n          case 'side':\n            camPos = new THREE.Vector3(width * 1.6, maxY * 1.0, 0);\n            break;\n          case 'iso':\n          default:\n            camPos = new THREE.Vector3(width * 0.9, maxY * 1.2, depth * 0.9);\n            break;\n        }\n\n        tweenCamera(camPos, center, duration);\n      }\n\n      function tweenCamera(targetPos, targetLook, duration = 1000) {\n        const start = { x: camera.position.x, y: camera.position.y, z: camera.position.z,\n                        tx: controls.target.x, ty: controls.target.y, tz: controls.target.z };\n        const end = { x: targetPos.x, y: targetPos.y, z: targetPos.z,\n                      tx: targetLook.x, ty: targetLook.y, tz: targetLook.z };\n\n        controls.enabled = false;\n\n        new TWEEN.Tween(start)\n          .to(end, duration)\n          .easing(TWEEN.Easing.Quadratic.InOut)\n          .onUpdate(() => {\n            camera.position.set(start.x, start.y, start.z);\n            controls.target.set(start.tx, start.ty, start.tz);\n            camera.lookAt(controls.target);\n          })\n          .onComplete(() => {\n            controls.enabled = true;\n          })\n          .start();\n      }\n\n      function onResize() {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n      }\n\n      function onPointerMove(e) {\n        // Update tooltip position\n        tooltip.style.left = e.clientX + 'px';\n        tooltip.style.top = e.clientY + 'px';\n\n        // Raycast\n        const rect = renderer.domElement.getBoundingClientRect();\n        const mouse = new THREE.Vector2(\n          ((e.clientX - rect.left) / rect.width) * 2 - 1,\n          -((e.clientY - rect.top) / rect.height) * 2 + 1\n        );\n        raycaster.setFromCamera(mouse, camera);\n        raycaster.params.Line.threshold = Math.max(0.1, step * 0.35);\n\n        const intersects = raycaster.intersectObjects([scatterGroup, barsGroup, ribbonsGroup], true);\n        if (intersects.length) {\n          const it = intersects[0];\n          const obj = findPickable(it.object);\n          if (hovered !== obj) {\n            clearHover();\n            setHover(obj, it);\n          }\n          updateTooltip(obj, it.point);\n        } else {\n          clearHover();\n          hideTooltip();\n        }\n      }\n\n      function findPickable(obj) {\n        // Traverse up until direct child of one of the groups or with userData.type\n        while (obj && !obj.userData?.type) obj = obj.parent;\n        return obj || null;\n      }\n\n      function setHover(obj, intersect) {\n        hovered = obj;\n        if (!obj) return;\n\n        const t = theme[themeName];\n        if (obj.userData.type === 'bar') {\n          // Emphasize bar\n          obj.userData._origEmissive = obj.material.emissive.getHex();\n          obj.userData._origScale = obj.scale.y;\n          obj.material.emissive.setHex(t.barsEmissive);\n          obj.scale.y = obj.userData._origScale * 1.06;\n          obj.position.y = (obj.scale.y) / 2;\n          showTooltip();\n        } else if (obj.userData.type === 'point') {\n          obj.userData._origScale3 = obj.scale.clone();\n          obj.scale.multiplyScalar(1.35);\n          showTooltip();\n        } else if (obj.userData.type === 'ribbon') {\n          obj.userData._origColor = obj.material.color.getHex();\n          const hoverColor = lightenColor(t.ribbons, 0.35);\n          obj.material.color.setHex(hoverColor);\n          showTooltip();\n        }\n      }\n\n      function clearHover() {\n        if (!hovered) return;\n        if (hovered.userData.type === 'bar') {\n          if (hovered.userData._origEmissive !== undefined) {\n            hovered.material.emissive.setHex(hovered.userData._origEmissive);\n          }\n          if (hovered.userData._origScale !== undefined) {\n            hovered.scale.y = hovered.userData._origScale;\n            hovered.position.y = hovered.scale.y / 2;\n          }\n        } else if (hovered.userData.type === 'point') {\n          if (hovered.userData._origScale3) hovered.scale.copy(hovered.userData._origScale3);\n        } else if (hovered.userData.type === 'ribbon') {\n          if (hovered.userData._origColor !== undefined) {\n            hovered.material.color.setHex(hovered.userData._origColor);\n          }\n        }\n        hovered = null;\n      }\n\n      function showTooltip() {\n        tooltip.style.opacity = '1';\n      }\n\n      function hideTooltip() {\n        tooltip.style.opacity = '0';\n      }\n\n      function updateTooltip(obj, point) {\n        if (!obj) return;\n        if (obj.userData.type === 'bar') {\n          const d = obj.userData;\n          tooltip.innerHTML = [\n            '<strong>Bar</strong>',\n            `xIndex: ${d.xi}, zIndex: ${d.zi}`,\n            `x: ${fmt(d.x)}, z: ${fmt(d.z)}, y: ${fmt(d.value * yScale)}`\n          ].join('<br/>');\n        } else if (obj.userData.type === 'point') {\n          const p = obj.userData;\n          tooltip.innerHTML = [\n            '<strong>Point</strong>',\n            `label: ${p.label}`,\n            `x: ${fmt(p.x)}, z: ${fmt(p.z)}, y: ${fmt(p.y)}`\n          ].join('<br/>');\n        } else if (obj.userData.type === 'ribbon') {\n          // Find nearest zi to intersection point\n          const xi = obj.userData.xi;\n          const zi = nearestZi(point.z);\n          const value = dataValues[xi][zi];\n          tooltip.innerHTML = [\n            '<strong>Ribbon</strong>',\n            `xIndex: ${xi}, near zIndex: ${zi}`,\n            `y: ${fmt(value * yScale)}`\n          ].join('<br/>');\n        }\n      }\n\n      function nearestZi(zWorld) {\n        const z0 = - (nz - 1) / 2 * step;\n        const idx = Math.round((zWorld - z0) / step);\n        return Math.min(nz - 1, Math.max(0, idx));\n      }\n\n      function animate(time) {\n        requestAnimationFrame(animate);\n        controls.update();\n        TWEEN.update(time);\n        renderer.render(scene, camera);\n      }\n\n      function exportCSV() {\n        // Export grid data (bars)\n        const rows = [];\n        rows.push('xIndex,zIndex,x,z,value,height');\n        for (let xi = 0; xi < nx; xi++) {\n          for (let zi = 0; zi < nz; zi++) {\n            const x = (xi - (nx - 1) / 2) * step;\n            const z = (zi - (nz - 1) / 2) * step;\n            const value = dataValues[xi][zi];\n            rows.push([xi, zi, fmt(x), fmt(z), fmt(value), fmt(value * yScale)].join(','));\n          }\n        }\n        const csv = rows.join('\\n');\n        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g, '-');\n        a.download = `dataset_${stamp}.csv`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n      }\n\n      // Utils\n\n      function fmt(n) {\n        return typeof n === 'number' ? n.toFixed(3) : n;\n      }\n\n      function clampIndex(i, n) {\n        return Math.max(0, Math.min(n - 1, i));\n      }\n\n      function bilinear(v00, v10, v01, v11, u, v) {\n        const a = v00 * (1 - u) + v10 * u;\n        const b = v01 * (1 - u) + v11 * u;\n        return a * (1 - v) + b * v;\n      }\n\n      function lightenColor(hex, amt) {\n        // amt in [0..1]\n        const c = new THREE.Color(hex);\n        const hsl = { h: 0, s: 0, l: 0 };\n        c.getHSL(hsl);\n        hsl.l = Math.min(1, hsl.l + amt);\n        c.setHSL(hsl.h, hsl.s, hsl.l);\n        return c.getHex();\n      }\n\n      // Simple 2D perlin-like noise via value noise\n      function perlin2(x, y) {\n        function hash(n) {\n          return Math.sin(n) * 43758.5453123 % 1;\n        }\n        function fade(t) {\n          return t * t * t * (t * (t * 6 - 15) + 10);\n        }\n        function lerp(a, b, t) {\n          return a + (b - a) * t;\n        }\n        const xi = Math.floor(x);\n        const yi = Math.floor(y);\n        const xf = x - xi;\n        const yf = y - yi;\n        const tl = hash(xi * 49632 + yi * 325176);\n        const tr = hash((xi + 1) * 49632 + yi * 325176);\n        const bl = hash(xi * 49632 + (yi + 1) * 325176);\n        const br = hash((xi + 1) * 49632 + (yi + 1) * 325176);\n        const u = fade(xf);\n        const v = fade(yf);\n        const top = lerp(tl, tr, u);\n        const bottom = lerp(bl, br, u);\n        return lerp(top, bottom, v) * 2 - 1; // [-1..1]\n      }\n\n    })();\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 213.20290517807007,
    "status": "success",
    "timestamp": "2025-08-29 17:56:03"
  },
  {
    "test_name": "molecular_explorer",
    "prompt": "Create a complete HTML file with Three.js that renders molecules from a provided or random molecular structure with ball-and-stick and space-filling modes, bond inference, atom coloring by element, section clipping, explode animation, and snapshot export. Include sample molecules (water, caffeine, DNA segment). The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'molecular_explorer.html'.",
    "response": "<!-- File: molecular_explorer.html -->\n<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Molecular Explorer - Three.js</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\">\n<style>\n  html, body { margin: 0; height: 100%; overflow: hidden; background: #0e0e12; color: #ddd; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }\n  #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }\n  #toolbar {\n    display: flex; flex-wrap: wrap; gap: 8px; align-items: center;\n    padding: 10px; background: #15151b; border-bottom: 1px solid #2a2a35;\n  }\n  #toolbar > * { font-size: 12px; }\n  select, input[type=\"text\"], input[type=\"number\"], button, textarea {\n    background: #1e1e27; border: 1px solid #333344; color: #ddd; border-radius: 4px; padding: 6px 8px;\n  }\n  label { display: inline-flex; align-items: center; gap: 6px; }\n  .group { display: inline-flex; gap: 8px; align-items: center; padding: 6px 8px; border-radius: 6px; background: #121218; border: 1px solid #2a2a35; }\n  .sep { width: 1px; height: 26px; background: #2a2a35; margin: 0 4px; }\n  #viewer { position: relative; }\n  #hud {\n    position: absolute; right: 10px; bottom: 10px; background: rgba(0,0,0,0.4);\n    border: 1px solid #2a2a35; padding: 8px 10px; border-radius: 6px; pointer-events: none; font-size: 12px;\n  }\n  #inputPanel {\n    position: absolute; left: 10px; top: 70px; width: min(520px, 92vw);\n    background: #101018; border: 1px solid #2a2a35; border-radius: 8px; padding: 8px; display: none;\n  }\n  #inputPanel header { display: flex; align-items: center; justify-content: space-between; padding: 4px 2px; }\n  #inputPanel textarea { width: 100%; height: 200px; resize: vertical; }\n  a.link { color: #8ab4ff; text-decoration: none; border-bottom: 1px dashed #8ab4ff; }\n  input[type=\"range\"] { accent-color: #5aa9ff; }\n</style>\n</head>\n<body>\n<div id=\"app\">\n  <div id=\"toolbar\">\n    <div class=\"group\">\n      <label>Samples:\n        <select id=\"sampleSelect\">\n          <option value=\"water\">Water (H2O)</option>\n          <option value=\"caffeine\">Caffeine</option>\n          <option value=\"dna\">DNA Segment</option>\n        </select>\n      </label>\n      <button id=\"loadSampleBtn\">Load</button>\n      <button id=\"randomBtn\">Random</button>\n      <button id=\"toggleInputBtn\">Paste Text</button>\n    </div>\n\n    <div class=\"group\">\n      <label><input type=\"radio\" name=\"repr\" value=\"ballstick\" checked> Ball-and-Stick</label>\n      <label><input type=\"radio\" name=\"repr\" value=\"spacefill\"> Space-filling</label>\n      <label title=\"Hide hydrogen atoms\"><input type=\"checkbox\" id=\"hideH\"> Hide H</label>\n      <label title=\"Bond distance tolerance\"><span>Bond tol</span>\n        <input type=\"range\" id=\"bondTol\" min=\"0.2\" max=\"0.7\" step=\"0.02\" value=\"0.42\">\n        <span id=\"bondTolVal\">0.42</span>\n      </label>\n    </div>\n\n    <div class=\"group\" title=\"Explode atoms away from centroid\">\n      <label>Explode\n        <input type=\"range\" id=\"explode\" min=\"0\" max=\"100\" step=\"1\" value=\"0\">\n        <span id=\"explodeVal\">0%</span>\n      </label>\n    </div>\n\n    <div class=\"group\" title=\"Slice the scene with a clipping plane\">\n      <label><input type=\"checkbox\" id=\"clipEnable\"> Clip</label>\n      <label>Axis\n        <select id=\"clipAxis\">\n          <option value=\"x\">X</option>\n          <option value=\"y\">Y</option>\n          <option value=\"z\" selected>Z</option>\n        </select>\n      </label>\n      <label>Pos\n        <input type=\"range\" id=\"clipPos\" min=\"0\" max=\"100\" step=\"1\" value=\"50\">\n        <span id=\"clipPosVal\">50%</span>\n      </label>\n    </div>\n\n    <div class=\"group\">\n      <button id=\"resetCameraBtn\">Reset View</button>\n      <button id=\"snapshotBtn\">Snapshot</button>\n    </div>\n  </div>\n\n  <div id=\"viewer\"></div>\n\n  <div id=\"inputPanel\">\n    <header>\n      <strong>Paste molecule (XYZ or simple list \"Element x y z\", or JSON array of atoms)</strong>\n      <div>\n        <button id=\"loadTextBtn\">Load</button>\n        <button id=\"closeInputBtn\">Close</button>\n      </div>\n    </header>\n    <p style=\"margin:4px 0 8px 0; color:#aaa\">\n      Supported: XYZ format (count and comment lines optional), or one atom per line: \"C 0.0 0.0 0.0\".\n      Example:\n      <a class=\"link\" href=\"#\" id=\"exampleXYZ\">Insert example</a>\n    </p>\n    <textarea id=\"inputText\"></textarea>\n  </div>\n\n  <div id=\"hud\">\n    <div id=\"hudText\">Atoms: 0 | Bonds: 0</div>\n  </div>\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js\"></script>\n<script>\n(() => {\n  // Basic element data\n  const COLORS = {\n    H: 0xFFFFFF, C: 0x444444, N: 0x3050F8, O: 0xFF0D0D, F: 0x90E050, P: 0xFF8000, S: 0xFFFF30,\n    Cl: 0x1FF01F, Br: 0xA62929, I: 0x940094, B: 0xFFB5B5, Si: 0xD0D0E0, Na: 0xAB5CF2, K: 0x8F40D4\n  };\n  const COVALENT = { // in \u00c5\n    H:0.31, C:0.76, N:0.71, O:0.66, F:0.57, P:1.07, S:1.05, Cl:1.02, Br:1.20, I:1.39, B:0.85, Si:1.11, Na:1.66, K:2.03\n  };\n  const VDW = { // in \u00c5\n    H:1.20, C:1.70, N:1.55, O:1.52, F:1.47, P:1.80, S:1.80, Cl:1.75, Br:1.85, I:1.98, B:1.92, Si:2.10, Na:2.27, K:2.75\n  };\n  const VALENCE = { H:1, C:4, N:3, O:2, F:1, P:5, S:2, Cl:1, Br:1, I:1, B:3, Si:4, Na:1, K:1 };\n\n  // State\n  let renderer, scene, camera, controls, container;\n  let moleculeGroup = new THREE.Group();\n  let atoms = []; // {element, pos:THREE.Vector3}\n  let basePositions = []; // original positions for explode baseline\n  let bonds = []; // [i, j]\n  let representation = 'ballstick'; // or 'spacefill'\n  let hideHydrogens = false;\n  let bondTolerance = 0.42;\n  let clipEnabled = false, clipAxis = 'z', clipPercent = 50;\n  let explodePercent = 0;\n  let clipPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);\n  let atomMeshes = [];\n  let bondGroup = new THREE.Group();\n  let sphereCache = {}; // radius -> geometry cache\n  let cylinderCache = {}; // key radius->geometry\n  let currentBBox = new THREE.Box3();\n  let currentBSphere = new THREE.Sphere();\n  let lastLoadedName = '';\n\n  init();\n  loadSample('water');\n\n  function init() {\n    container = document.getElementById('viewer');\n\n    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setSize(container.clientWidth || window.innerWidth, container.clientHeight || (window.innerHeight - 60));\n    renderer.setClearColor(0x0e0e12, 1);\n    renderer.localClippingEnabled = true;\n    container.appendChild(renderer.domElement);\n\n    scene = new THREE.Scene();\n\n    camera = new THREE.PerspectiveCamera(55, renderer.domElement.clientWidth / renderer.domElement.clientHeight, 0.1, 2000);\n    camera.position.set(0, 0, 25);\n\n    controls = new THREE.OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.08;\n    controls.rotateSpeed = 0.6;\n    controls.zoomSpeed = 0.9;\n    controls.panSpeed = 0.8;\n\n    // Lights\n    scene.add(new THREE.AmbientLight(0xffffff, 0.45));\n    const dir1 = new THREE.DirectionalLight(0xffffff, 0.8);\n    dir1.position.set(10, 10, 12);\n    scene.add(dir1);\n    const dir2 = new THREE.DirectionalLight(0x88aaff, 0.5);\n    dir2.position.set(-12, -8, -10);\n    scene.add(dir2);\n\n    // Add group\n    moleculeGroup = new THREE.Group();\n    scene.add(moleculeGroup);\n\n    // Events\n    window.addEventListener('resize', onResize);\n\n    // UI bindings\n    document.getElementById('loadSampleBtn').addEventListener('click', () => {\n      const id = document.getElementById('sampleSelect').value;\n      loadSample(id);\n    });\n    document.getElementById('randomBtn').addEventListener('click', () => {\n      const mol = generateRandomMolecule(36);\n      setMolecule(mol.atoms, null, 'Random');\n    });\n    document.getElementById('toggleInputBtn').addEventListener('click', () => toggleInput(true));\n    document.getElementById('closeInputBtn').addEventListener('click', () => toggleInput(false));\n    document.getElementById('exampleXYZ').addEventListener('click', (e) => {\n      e.preventDefault();\n      document.getElementById('inputText').value = exampleXYZ();\n    });\n    document.getElementById('loadTextBtn').addEventListener('click', () => {\n      const text = document.getElementById('inputText').value.trim();\n      const parsed = parseInput(text);\n      if (!parsed || !parsed.atoms?.length) {\n        alert('Could not parse input. Provide XYZ or lines \"Element x y z\", or JSON [{element,x,y,z},...].');\n        return;\n      }\n      setMolecule(parsed.atoms, null, 'Text Input');\n      toggleInput(false);\n    });\n\n    document.querySelectorAll('input[name=\"repr\"]').forEach(el => {\n      el.addEventListener('change', (e) => {\n        representation = e.target.value;\n        rebuild();\n      });\n    });\n    document.getElementById('hideH').addEventListener('change', (e) => {\n      hideHydrogens = e.target.checked;\n      rebuild();\n    });\n    const bondTolEl = document.getElementById('bondTol');\n    bondTolEl.addEventListener('input', () => {\n      bondTolerance = parseFloat(bondTolEl.value);\n      document.getElementById('bondTolVal').textContent = bondTolerance.toFixed(2);\n      rebuild(); // recompute bonds\n    });\n    const explodeEl = document.getElementById('explode');\n    explodeEl.addEventListener('input', () => {\n      explodePercent = parseInt(explodeEl.value, 10) || 0;\n      document.getElementById('explodeVal').textContent = explodePercent + '%';\n      updateExplodedPositions();\n    });\n\n    const clipEnableEl = document.getElementById('clipEnable');\n    const clipAxisEl = document.getElementById('clipAxis');\n    const clipPosEl = document.getElementById('clipPos');\n    clipEnableEl.addEventListener('change', () => { clipEnabled = clipEnableEl.checked; updateClipping(); });\n    clipAxisEl.addEventListener('change', () => { clipAxis = clipAxisEl.value; updateClipping(); });\n    clipPosEl.addEventListener('input', () => {\n      clipPercent = parseInt(clipPosEl.value, 10) || 0;\n      document.getElementById('clipPosVal').textContent = clipPercent + '%';\n      updateClipping();\n    });\n\n    document.getElementById('resetCameraBtn').addEventListener('click', () => fitView());\n    document.getElementById('snapshotBtn').addEventListener('click', () => snapshot());\n\n    animate();\n  }\n\n  function onResize() {\n    const w = container.clientWidth || window.innerWidth;\n    const h = container.clientHeight || (window.innerHeight - document.getElementById('toolbar').offsetHeight);\n    renderer.setSize(w, h);\n    camera.aspect = w / h;\n    camera.updateProjectionMatrix();\n  }\n\n  function animate() {\n    requestAnimationFrame(animate);\n    controls.update();\n    renderer.render(scene, camera);\n  }\n\n  // UI helpers\n  function toggleInput(show) {\n    document.getElementById('inputPanel').style.display = show ? 'block' : 'none';\n    if (show && !document.getElementById('inputText').value.trim()) {\n      document.getElementById('inputText').value = exampleXYZ();\n    }\n  }\n\n  function exampleXYZ() {\n    return `5\nExample molecule: ethanol-ish\nC  -0.748  0.546  0.000\nC   0.748 -0.046  0.000\nO   1.839  0.847  0.000\nH  -1.179  1.557  0.000\nH  -1.271 -0.175  0.843`;\n  }\n\n  // Molecule pipeline\n  function setMolecule(atomList, bondList=null, name='Molecule') {\n    lastLoadedName = name;\n    atoms = atomList.map(a => ({ element: a.element, pos: new THREE.Vector3(a.x, a.y, a.z) }));\n    basePositions = atoms.map(a => a.pos.clone());\n    bonds = Array.isArray(bondList) ? bondList.slice() : inferBonds(atoms, bondTolerance);\n    updateBBox();\n    explodePercent = parseInt(document.getElementById('explode').value, 10) || 0;\n    rebuild();\n    fitView();\n    updateHud();\n  }\n\n  function rebuild() {\n    // Clear group\n    moleculeGroup.clear();\n    atomMeshes = [];\n    bondGroup = new THREE.Group();\n\n    // Atoms possibly filtered\n    const filteredIdx = [];\n    for (let i = 0; i < atoms.length; i++) {\n      if (hideHydrogens && atoms[i].element === 'H') continue;\n      filteredIdx.push(i);\n    }\n    // Map original index -> new index in filtered arrays\n    const indexMap = new Map();\n    filteredIdx.forEach((oldIdx, newIdx) => indexMap.set(oldIdx, newIdx));\n\n    // Build current positions (with explode)\n    const explodedPositions = computeExplodedPositions();\n\n    // Build atoms\n    const atomGroup = new THREE.Group();\n    for (let k = 0; k < filteredIdx.length; k++) {\n      const i = filteredIdx[k];\n      const a = atoms[i];\n      const pos = explodedPositions[i];\n      const color = COLORS[a.element] ?? 0xAAAAAA;\n      const sphere = makeAtomSphere(a.element, representation, color);\n      sphere.position.copy(pos);\n      // Apply clipping\n      applyClippingToMaterial(sphere.material);\n      atomGroup.add(sphere);\n      atomMeshes.push(sphere);\n    }\n    moleculeGroup.add(atomGroup);\n\n    // Build bonds for ball-and-stick only\n    if (representation === 'ballstick') {\n      const bondMeshGroup = new THREE.Group();\n      for (const [i, j] of bonds) {\n        if ((hideHydrogens && atoms[i].element === 'H') || (hideHydrogens && atoms[j].element === 'H')) continue;\n        const p1 = explodedPositions[i], p2 = explodedPositions[j];\n        const e1 = atoms[i].element, e2 = atoms[j].element;\n        const cyls = makeBondCylinders(p1, p2, e1, e2);\n        for (const m of cyls) {\n          applyClippingToMaterial(m.material);\n          bondMeshGroup.add(m);\n        }\n      }\n      bondGroup = bondMeshGroup;\n      moleculeGroup.add(bondGroup);\n    }\n\n    updateClipping();\n    updateHud();\n  }\n\n  function updateExplodedPositions() {\n    // Update mesh positions and bonds without full rebuild where possible\n    const explodedPositions = computeExplodedPositions();\n\n    // Update atoms\n    if (atomMeshes.length) {\n      let idx = 0;\n      for (let i = 0; i < atoms.length; i++) {\n        if (hideHydrogens && atoms[i].element === 'H') continue;\n        const mesh = atomMeshes[idx++];\n        mesh.position.copy(explodedPositions[i]);\n      }\n    }\n    // Rebuild bonds quickly\n    if (representation === 'ballstick') {\n      moleculeGroup.remove(bondGroup);\n      const bondMeshGroup = new THREE.Group();\n      for (const [i, j] of bonds) {\n        if ((hideHydrogens && atoms[i].element === 'H') || (hideHydrogens && atoms[j].element === 'H')) continue;\n        const p1 = explodedPositions[i], p2 = explodedPositions[j];\n        const e1 = atoms[i].element, e2 = atoms[j].element;\n        const cyls = makeBondCylinders(p1, p2, e1, e2);\n        for (const m of cyls) {\n          applyClippingToMaterial(m.material);\n          bondMeshGroup.add(m);\n        }\n      }\n      bondGroup = bondMeshGroup;\n      moleculeGroup.add(bondGroup);\n    }\n  }\n\n  function updateBBox() {\n    currentBBox.makeEmpty();\n    for (const a of atoms) currentBBox.expandByPoint(a.pos);\n    currentBBox.getBoundingSphere(currentBSphere);\n  }\n\n  function fitView() {\n    // Fit camera to bounding sphere\n    const sphere = currentBSphere;\n    const radius = Math.max(sphere.radius, 1);\n    const fov = THREE.MathUtils.degToRad(camera.fov);\n    const viewDist = radius / Math.sin(fov / 2);\n    const target = sphere.center;\n    controls.target.copy(target);\n    const dir = new THREE.Vector3(0, 0, 1);\n    camera.position.copy(target.clone().add(dir.multiplyScalar(viewDist * 1.2 + 5)));\n    camera.near = Math.max(0.01, radius / 50);\n    camera.far = Math.max(500, viewDist * 10);\n    camera.updateProjectionMatrix();\n    controls.update();\n  }\n\n  function updateHud() {\n    const aCount = hideHydrogens ? atoms.filter(a => a.element !== 'H').length : atoms.length;\n    const bCount = bonds.filter(([i,j]) =>\n      !(hideHydrogens && (atoms[i].element === 'H' || atoms[j].element === 'H'))).length;\n    document.getElementById('hudText').textContent =\n      `${lastLoadedName || 'Molecule'} \u2014 Atoms: ${aCount} | Bonds: ${bCount}`;\n  }\n\n  function applyClippingToMaterial(mat) {\n    if (!mat) return;\n    if (Array.isArray(mat)) { mat.forEach(m => applyClippingToMaterial(m)); return; }\n    if (clipEnabled) {\n      mat.clippingPlanes = [clipPlane];\n      mat.clipShadows = true;\n    } else {\n      mat.clippingPlanes = null;\n    }\n    mat.needsUpdate = true;\n  }\n\n  function updateClipping() {\n    // Determine plane normal\n    const n = new THREE.Vector3(\n      clipAxis === 'x' ? 1 : 0,\n      clipAxis === 'y' ? 1 : 0,\n      clipAxis === 'z' ? 1 : 0\n    );\n    // Plane position along axis\n    const min = currentBBox.min[clipAxis], max = currentBBox.max[clipAxis];\n    const pos = THREE.MathUtils.lerp(min, max, clipPercent / 100);\n    // Plane equation: n\u00b7x + d = 0 -> d = -n\u00b7p0\n    const d = -pos * n[clipAxis];\n    clipPlane.normal.copy(n);\n    clipPlane.constant = d;\n\n    // Update materials in scene\n    renderer.localClippingEnabled = clipEnabled;\n    moleculeGroup.traverse(obj => {\n      if (obj.isMesh && obj.material) applyClippingToMaterial(obj.material);\n    });\n  }\n\n  // Geometry makers\n  function makeAtomSphere(element, mode, color) {\n    let radius = 0.3;\n    if (mode === 'ballstick') {\n      radius = Math.max(0.15, (COVALENT[element] || 0.8) * 0.35);\n    } else if (mode === 'spacefill') {\n      radius = Math.max(0.4, (VDW[element] || 1.7) * 0.6);\n    }\n    const key = radius.toFixed(3);\n    let geom = sphereCache[key];\n    if (!geom) {\n      geom = new THREE.SphereGeometry(radius, 24, 16);\n      sphereCache[key] = geom;\n    }\n    const mat = new THREE.MeshStandardMaterial({\n      color, metalness: 0.1, roughness: 0.35, envMapIntensity: 0.6,\n      transparent: false\n    });\n    return new THREE.Mesh(geom, mat);\n  }\n\n  function makeBondCylinders(p1, p2, e1, e2) {\n    const objs = [];\n    const dir = new THREE.Vector3().subVectors(p2, p1);\n    const len = dir.length();\n    if (len < 1e-6) return objs;\n    const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);\n    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());\n    const bondRadius = 0.08;\n    const key = bondRadius.toFixed(3);\n    let geom = cylinderCache[key + ':' + len.toFixed(3)];\n    // We don't cache by length to allow reuse; but geometry length differs, so build fresh\n    geom = new THREE.CylinderGeometry(bondRadius, bondRadius, len, 14, 1, false);\n    // Two half-cylinders colored by atom colors\n    // First half\n    const half1 = new THREE.Mesh(\n      geom.clone(),\n      new THREE.MeshStandardMaterial({ color: COLORS[e1] ?? 0x999999, metalness:0.1, roughness:0.4 })\n    );\n    half1.position.copy(mid);\n    half1.quaternion.copy(quat);\n    // Shift geometry to half to color split: we can scale geometry and clip with another plane, but simpler is two shorter cylinders\n    const lenHalf = len / 2;\n    const geomHalf = new THREE.CylinderGeometry(bondRadius, bondRadius, lenHalf, 14, 1, false);\n    const m1 = new THREE.Mesh(geomHalf, half1.material.clone());\n    const m2 = new THREE.Mesh(geomHalf, new THREE.MeshStandardMaterial({ color: COLORS[e2] ?? 0x999999, metalness:0.1, roughness:0.4 }));\n    m1.position.copy(new THREE.Vector3().addVectors(p1, mid).multiplyScalar(0.5));\n    m2.position.copy(new THREE.Vector3().addVectors(p2, mid).multiplyScalar(0.5));\n    m1.quaternion.copy(quat);\n    m2.quaternion.copy(quat);\n\n    objs.push(m1, m2);\n    return objs;\n  }\n\n  // Explode helpers\n  function computeExplodedPositions() {\n    if (!atoms.length) return [];\n    const center = new THREE.Vector3();\n    for (const a of basePositions) center.add(a);\n    center.multiplyScalar(1 / basePositions.length);\n    const radius = currentBSphere.radius || 1;\n    const maxDist = Math.max(radius * 1.8, 4);\n    const factor = (explodePercent / 100) * maxDist;\n    const out = [];\n    for (let i = 0; i < basePositions.length; i++) {\n      const base = basePositions[i];\n      const dir = new THREE.Vector3().subVectors(base, center);\n      const len = dir.length();\n      if (len < 1e-5) {\n        out.push(base.clone());\n      } else {\n        dir.multiplyScalar(1 / len);\n        out.push(base.clone().add(dir.multiplyScalar(factor)));\n      }\n    }\n    return out;\n  }\n\n  // Bond inference\n  function inferBonds(atomList, tol=0.42) {\n    const pairs = [];\n    const maxNeighbors = new Array(atomList.length).fill(0);\n    const currentNeighbors = new Array(atomList.length).fill(0);\n\n    // Precompute potentials\n    for (let i = 0; i < atomList.length; i++) {\n      maxNeighbors[i] = VALENCE[atomList[i].element] ?? 4;\n    }\n\n    for (let i = 0; i < atomList.length; i++) {\n      for (let j = i + 1; j < atomList.length; j++) {\n        const ei = atomList[i].element, ej = atomList[j].element;\n        // Skip metals and noble gases (not in table) bonding loosely\n        const ri = COVALENT[ei] ?? 0.8;\n        const rj = COVALENT[ej] ?? 0.8;\n        const maxDist = ri + rj + tol;\n        const minDist = 0.4; // avoid super short\n        const dij = atomList[i].pos.distanceTo(atomList[j].pos);\n        if (dij >= minDist && dij <= maxDist) {\n          pairs.push({ i, j, d: dij });\n        }\n      }\n    }\n    // Sort by distance (shortest first)\n    pairs.sort((a, b) => a.d - b.d);\n\n    const bonded = [];\n    const hasBond = Array.from({length: atomList.length}, () => new Set());\n    for (const p of pairs) {\n      if (currentNeighbors[p.i] >= maxNeighbors[p.i]) continue;\n      if (currentNeighbors[p.j] >= maxNeighbors[p.j]) continue;\n      if (hasBond[p.i].has(p.j) || hasBond[p.j].has(p.i)) continue;\n      // Optional: don't let H-H bonds form (except if needed)\n      if (atomList[p.i].element === 'H' && atomList[p.j].element === 'H') continue;\n\n      bonded.push([p.i, p.j]);\n      hasBond[p.i].add(p.j);\n      hasBond[p.j].add(p.i);\n      currentNeighbors[p.i]++;\n      currentNeighbors[p.j]++;\n    }\n    return bonded;\n  }\n\n  // Parsers\n  function parseInput(text) {\n    if (!text) return null;\n    // Try JSON\n    try {\n      const j = JSON.parse(text);\n      if (Array.isArray(j)) {\n        const atoms = j.map(a => ({ element: a.element ?? a.e ?? a.atom ?? 'C', x: +a.x, y: +a.y, z: +a.z }));\n        return { atoms };\n      }\n    } catch(e) {}\n    // Try XYZ\n    const lines = text.split(/\\r?\\n/).map(l => l.trim()).filter(l => l.length);\n    if (!lines.length) return null;\n    let idx = 0;\n    let count = parseInt(lines[0], 10);\n    if (Number.isFinite(count) && count > 0) {\n      idx = 2; // skip comment\n    } else {\n      idx = 0; count = lines.length;\n    }\n    const atoms = [];\n    for (; idx < lines.length; idx++) {\n      const parts = lines[idx].split(/[\\s,;]+/).filter(Boolean);\n      if (parts.length < 4) continue;\n      const element = normalizeElement(parts[0]);\n      const x = parseFloat(parts[1]), y = parseFloat(parts[2]), z = parseFloat(parts[3]);\n      if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) continue;\n      atoms.push({ element, x, y, z });\n    }\n    return { atoms };\n  }\n\n  function normalizeElement(token) {\n    // Accept \"CL\" or \"cl\" etc.\n    if (!token) return 'C';\n    token = token.trim();\n    if (token.length === 1) return token.toUpperCase();\n    const t = token[0].toUpperCase() + token.slice(1).toLowerCase();\n    // Handle common halogens\n    if (['Cl','Br','Si','Na','Li','Al','Ca','Mg'].includes(t)) return t;\n    return t.slice(0,1); // default to first letter if unknown\n  }\n\n  // Samples\n  function loadSample(id) {\n    if (id === 'water') {\n      const atoms = [\n        { element: 'O', x: 0, y: 0, z: 0 },\n        { element: 'H', x: 0.9572, y: 0.0, z: 0 },\n        { element: 'H', x: -0.2399872, y: 0.927297, z: 0 }\n      ];\n      setMolecule(atoms, null, 'Water');\n    } else if (id === 'caffeine') {\n      const mol = createPseudoCaffeine();\n      setMolecule(mol.atoms, mol.bonds, 'Caffeine (approx.)');\n    } else if (id === 'dna') {\n      const mol = createDNASegment(10);\n      setMolecule(mol.atoms, mol.bonds, 'DNA Segment');\n    }\n  }\n\n  // Random molecule\n  function generateRandomMolecule(n = 30) {\n    const elems = ['C','C','C','C','C','H','H','H','H','H','H','N','N','O','O','S','P','F','Cl'];\n    const atoms = [];\n    for (let i = 0; i < n; i++) {\n      const element = elems[Math.floor(Math.random() * elems.length)];\n      const x = (Math.random() - 0.5) * 12;\n      const y = (Math.random() - 0.5) * 12;\n      const z = (Math.random() - 0.5) * 12;\n      atoms.push({ element, x, y, z });\n    }\n    // Slightly push apart too-close atoms\n    for (let it = 0; it < 2; it++) {\n      for (let i = 0; i < atoms.length; i++) {\n        for (let j = i+1; j < atoms.length; j++) {\n          const pi = new THREE.Vector3(atoms[i].x, atoms[i].y, atoms[i].z);\n          const pj = new THREE.Vector3(atoms[j].x, atoms[j].y, atoms[j].z);\n          const d = pi.distanceTo(pj);\n          if (d < 0.7) {\n            const dir = pj.clone().sub(pi).normalize().multiplyScalar((0.7 - d) * 0.5);\n            atoms[i].x += -dir.x; atoms[i].y += -dir.y; atoms[i].z += -dir.z;\n            atoms[j].x += dir.x; atoms[j].y += dir.y; atoms[j].z += dir.z;\n          }\n        }\n      }\n    }\n    return { atoms };\n  }\n\n  // Pseudo caffeine generator (topologically plausible; not chemically exact)\n  function createPseudoCaffeine() {\n    const atoms = [];\n    const bonds = [];\n\n    // Create a 10-membered ring (decagon) base as backbone\n    const R = 1.65;\n    const center = new THREE.Vector3(0, 0, 0);\n    const ringIdx = [];\n    for (let i = 0; i < 10; i++) {\n      const angle = (i / 10) * Math.PI * 2;\n      const x = Math.cos(angle) * R;\n      const y = Math.sin(angle) * R;\n      const z = (i % 2 === 0) ? 0.06 : -0.06; // slight puckering\n      ringIdx.push(atoms.length);\n      atoms.push({ element: (i===0||i===3||i===6||i===8) ? 'N' : 'C', x, y, z });\n    }\n    // Ring bonds\n    for (let i = 0; i < 10; i++) {\n      const a = ringIdx[i], b = ringIdx[(i+1)%10];\n      bonds.push([a,b]);\n    }\n    // Two carbonyl oxygens off two ring carbons\n    const attachCarbonyl = (ringAtomIdx, outward=1.1) => {\n      const i = ringAtomIdx;\n      const a = atoms[i];\n      const angle = (i / 10) * Math.PI * 2;\n      const ox = a.x + Math.cos(angle) * outward;\n      const oy = a.y + Math.sin(angle) * outward;\n      const oz = a.z + 0.0;\n      const oi = atoms.length;\n      atoms.push({ element: 'O', x: ox, y: oy, z: oz });\n      bonds.push([i, oi]);\n    };\n    attachCarbonyl(ringIdx[1], 1.25);\n    attachCarbonyl(ringIdx[5], 1.25);\n\n    // Three methyl groups on three nitrogens (indices 0,3,6)\n    const addMethyl = (ringAtom, outward=1.45) => {\n      const i = ringAtom;\n      const a = atoms[i];\n      const angle = (i / 10) * Math.PI * 2;\n      const cx = a.x + Math.cos(angle) * outward;\n      const cy = a.y + Math.sin(angle) * outward;\n      const cz = a.z + 0.0;\n      const ci = atoms.length;\n      atoms.push({ element: 'C', x: cx, y: cy, z: cz });\n      bonds.push([i, ci]);\n      // Three hydrogens around methyl carbon (tetrahedral-ish)\n      const dirs = [\n        new THREE.Vector3(1, 1, 1).normalize(),\n        new THREE.Vector3(-1, -0.5, 1).normalize(),\n        new THREE.Vector3(0, -1, -1).normalize()\n      ];\n      for (const d of dirs) {\n        const hi = atoms.length;\n        atoms.push({ element: 'H', x: cx + d.x*0.95, y: cy + d.y*0.95, z: cz + d.z*0.95 });\n        bonds.push([ci, hi]);\n      }\n    };\n    addMethyl(ringIdx[0]);\n    addMethyl(ringIdx[3]);\n    addMethyl(ringIdx[6]);\n\n    return { atoms, bonds };\n  }\n\n  // Simple stylized DNA segment generator (two short helical backbones connected by base pairs)\n  function createDNASegment(pairs = 8) {\n    const atoms = [];\n    const bonds = [];\n    const r = 7.0;\n    const pitch = 3.4; // z rise per pair\n    const twist = Math.PI * 2 / 10.5; // per base\n    let prevASugar = null, prevBSugar = null;\n\n    for (let i = 0; i < pairs; i++) {\n      const angle = i * twist;\n      const zA = i * pitch;\n      const zB = i * pitch + pitch*0.5;\n\n      const hxA = Math.cos(angle) * r;\n      const hyA = Math.sin(angle) * r;\n      const hxB = -hxA, hyB = -hyA;\n\n      // Backbone phosphates (P) and oxygens (O)\n      const pA = addAtom(atoms, 'P', hxA, hyA, zA);\n      const oA1 = addAtom(atoms, 'O', hxA + 0.8*Math.cos(angle + 0.7), hyA + 0.8*Math.sin(angle + 0.7), zA + 0.5);\n      const oA2 = addAtom(atoms, 'O', hxA + 0.9*Math.cos(angle - 0.6), hyA + 0.9*Math.sin(angle - 0.6), zA - 0.4);\n      bonds.push([pA, oA1], [pA, oA2]);\n\n      const pB = addAtom(atoms, 'P', hxB, hyB, zB);\n      const oB1 = addAtom(atoms, 'O', hxB + 0.8*Math.cos(angle + Math.PI + 0.7), hyB + 0.8*Math.sin(angle + Math.PI + 0.7), zB + 0.5);\n      const oB2 = addAtom(atoms, 'O', hxB + 0.9*Math.cos(angle + Math.PI - 0.6), hyB + 0.9*Math.sin(angle + Math.PI - 0.6), zB - 0.4);\n      bonds.push([pB, oB1], [pB, oB2]);\n\n      // Sugar carbons (C) near backbone toward center\n      const sugarA = addAtom(atoms, 'C', hxA * 0.8, hyA * 0.8, zA + 0.1);\n      const sugarB = addAtom(atoms, 'C', hxB * 0.8, hyB * 0.8, zB - 0.1);\n      bonds.push([oA1, sugarA], [oB1, sugarB]);\n      if (prevASugar !== null) bonds.push([prevASugar, sugarA]);\n      if (prevBSugar !== null) bonds.push([prevBSugar, sugarB]);\n\n      // Base nitrogens (N) toward center\n      const baseA = addAtom(atoms, 'N', hxA * 0.45, hyA * 0.45, zA + 0.05);\n      const baseB = addAtom(atoms, 'N', hxB * 0.45, hyB * 0.45, zB - 0.05);\n      bonds.push([sugarA, baseA], [sugarB, baseB]);\n\n      // Base pair connection\n      bonds.push([baseA, baseB]);\n\n      // A few base carbons for shape\n      const baseAC1 = addAtom(atoms, 'C', hxA * 0.33, hyA * 0.33, zA + 0.1);\n      const baseBC1 = addAtom(atoms, 'C', hxB * 0.33, hyB * 0.33, zB - 0.1);\n      bonds.push([baseA, baseAC1], [baseB, baseBC1]);\n\n      prevASugar = sugarA;\n      prevBSugar = sugarB;\n    }\n\n    return { atoms, bonds };\n  }\n\n  function addAtom(arr, element, x, y, z) {\n    const idx = arr.length;\n    arr.push({ element, x, y, z });\n    return idx;\n  }\n\n  // Snapshot export\n  function snapshot() {\n    try {\n      const dataURL = renderer.domElement.toDataURL('image/png');\n      const a = document.createElement('a');\n      const ts = new Date().toISOString().replace(/[:.]/g, '-');\n      a.download = `molecule_${(lastLoadedName||'snapshot').toLowerCase().replace(/\\s+/g, '_')}_${ts}.png`;\n      a.href = dataURL;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n    } catch (e) {\n      alert('Snapshot failed: ' + e.message);\n    }\n  }\n})();\n</script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 302.5709819793701,
    "status": "success",
    "timestamp": "2025-08-29 18:01:05"
  },
  {
    "test_name": "space_shooter_prototype",
    "prompt": "Create a complete HTML file with Three.js that builds a simple on-rails space shooter with starfield background, enemy waves (instanced meshes), laser projectiles, hit effects (GPU particles), health/score UI, and post-processing bloom. Provide difficulty scaling and mobile touch controls. The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'space_shooter.html'.",
    "response": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>On-Rails Space Shooter</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">\n  <style>\n    html, body { margin: 0; padding: 0; background: #000; height: 100%; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }\n    #ui {\n      position: fixed; inset: 0; pointer-events: none;\n      color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.8);\n    }\n    #score { position: absolute; left: 12px; top: 10px; font-size: 18px; }\n    #healthBar {\n      position: absolute; right: 12px; top: 12px; width: 180px; height: 16px; border: 1px solid rgba(255,255,255,0.5); border-radius: 10px; overflow: hidden;\n      background: rgba(255,255,255,0.08);\n    }\n    #healthFill {\n      height: 100%; width: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60);\n    }\n    #wave { position: absolute; left: 12px; top: 36px; font-size: 14px; opacity: 0.8; }\n    #instructions {\n      position: absolute; left: 50%; bottom: 10px; transform: translateX(-50%); text-align: center; font-size: 14px; opacity: 0.7;\n      padding: 6px 10px; border-radius: 8px; background: rgba(0,0,0,0.35);\n    }\n    #touchControls {\n      position: absolute; inset: 0; pointer-events: auto;\n    }\n    .zone {\n      position: absolute; top: 0; bottom: 0; width: 50%;\n    }\n    #moveZone { left: 0; }\n    #fireZone { right: 0; }\n    /* Visual hints for touch controls (faint) */\n    #moveHint, #fireHint {\n      position: absolute; bottom: 20px; width: 140px; height: 140px; border-radius: 50%;\n      border: 2px dashed rgba(255,255,255,0.15);\n    }\n    #moveHint { left: 20px; }\n    #fireHint { right: 20px; }\n    #fireHint::after {\n      content: 'FIRE'; position: absolute; inset: 0; display: grid; place-items: center;\n      color: rgba(255,255,255,0.4); font-weight: 700; letter-spacing: 1px;\n    }\n    #gameOver {\n      position: absolute; inset: 0; display: none; align-items: center; justify-content: center; flex-direction: column;\n      background: radial-gradient(ellipse at center, rgba(0,0,0,0.65), rgba(0,0,0,0.95));\n      pointer-events: auto;\n    }\n    #gameOver h1 { margin: 0 0 10px; font-size: 38px; color: #fff; }\n    #gameOver p { margin: 6px 0; color: #ddd; }\n    #restartBtn {\n      margin-top: 12px; padding: 10px 16px; background: #1abc9c; border: none; border-radius: 6px; color: #012; font-weight: 700;\n      cursor: pointer;\n    }\n    canvas { display: block; }\n  </style>\n</head>\n<body>\n  <div id=\"ui\">\n    <div id=\"score\">Score: 0</div>\n    <div id=\"wave\">Wave 1 \u2022 Difficulty 1.0x</div>\n    <div id=\"healthBar\"><div id=\"healthFill\"></div></div>\n    <div id=\"instructions\">Move: WASD / Arrow keys / Drag left \u2022 Fire: Space / Tap right</div>\n    <div id=\"touchControls\">\n      <div class=\"zone\" id=\"moveZone\"></div>\n      <div class=\"zone\" id=\"fireZone\"></div>\n      <div id=\"moveHint\"></div>\n      <div id=\"fireHint\"></div>\n    </div>\n    <div id=\"gameOver\">\n      <h1>Game Over</h1>\n      <p id=\"finalScore\">Score: 0</p>\n      <button id=\"restartBtn\">Restart</button>\n    </div>\n  </div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';\n    import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';\n    import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';\n    import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';\n\n    // Renderer, Scene, Camera, Composer\n    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.0;\n    document.body.appendChild(renderer.domElement);\n\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x000006);\n    scene.fog = new THREE.FogExp2(0x000006, 0.025);\n\n    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.5, 500);\n    camera.position.set(0, 0, 10);\n    camera.lookAt(0, 0, -1);\n\n    const composer = new EffectComposer(renderer);\n    const renderPass = new RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.85, 0.8, 0.85);\n    composer.addPass(bloomPass);\n\n    // Lighting\n    const hemi = new THREE.HemisphereLight(0x3355ff, 0x080810, 0.6);\n    scene.add(hemi);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.7);\n    dir.position.set(3, 5, 2);\n    scene.add(dir);\n\n    // Globals\n    const clock = new THREE.Clock();\n    let elapsed = 0;\n    let running = true;\n    let score = 0;\n    let wave = 1;\n    let difficulty = 1.0;\n    let worldSpeed = 10.0; // forward motion speed reference\n\n    // UI\n    const scoreEl = document.getElementById('score');\n    const waveEl = document.getElementById('wave');\n    const healthFillEl = document.getElementById('healthFill');\n    const gameOverEl = document.getElementById('gameOver');\n    const finalScoreEl = document.getElementById('finalScore');\n    const restartBtn = document.getElementById('restartBtn');\n\n    // Player (ship)\n    const ship = new THREE.Group();\n    scene.add(ship);\n    function buildShip() {\n      const coreGeo = new THREE.ConeGeometry(0.35, 1.2, 12);\n      coreGeo.rotateX(Math.PI / 2);\n      const coreMat = new THREE.MeshStandardMaterial({ color: 0x99e6ff, metalness: 0.2, roughness: 0.3, emissive: 0x112244, emissiveIntensity: 0.4 });\n      const core = new THREE.Mesh(coreGeo, coreMat);\n      core.position.z = 0.0;\n      ship.add(core);\n\n      const bodyGeo = new THREE.CapsuleGeometry(0.22, 0.7, 2, 8);\n      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2266ff, metalness: 0.3, roughness: 0.4, emissive: 0x0a1a3a, emissiveIntensity: 0.6 });\n      const body = new THREE.Mesh(bodyGeo, bodyMat);\n      body.rotation.x = Math.PI / 2;\n      body.position.set(0, 0, 0.1);\n      ship.add(body);\n\n      const wingGeo = new THREE.BoxGeometry(0.05, 1.0, 0.35);\n      const wingMat = new THREE.MeshStandardMaterial({ color: 0xff3344, metalness: 0.0, roughness: 0.7, emissive: 0x330006, emissiveIntensity: 0.8 });\n      const lw = new THREE.Mesh(wingGeo, wingMat);\n      const rw = new THREE.Mesh(wingGeo, wingMat);\n      lw.position.set(-0.45, 0, 0.05);\n      rw.position.set( 0.45, 0, 0.05);\n      ship.add(lw, rw);\n\n      const thrusterGeo = new THREE.CylinderGeometry(0.16, 0.10, 0.25, 12);\n      const thrusterMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x66ccff, emissiveIntensity: 2.0, roughness: 0.8 });\n      const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);\n      thruster.rotation.x = Math.PI / 2;\n      thruster.position.set(0, 0, 0.65);\n      ship.add(thruster);\n\n      ship.position.set(0, 0, 5.5);\n    }\n    buildShip();\n\n    let playerHealth = 100;\n    function updateUI() {\n      scoreEl.textContent = `Score: ${score}`;\n      waveEl.textContent = `Wave ${wave} \u2022 Difficulty ${difficulty.toFixed(1)}x`;\n      const pct = Math.max(0, Math.min(100, playerHealth));\n      healthFillEl.style.width = pct + '%';\n      healthFillEl.style.background = pct > 50\n        ? 'linear-gradient(90deg, #2ecc71, #27ae60)'\n        : pct > 25\n        ? 'linear-gradient(90deg, #f1c40f, #f39c12)'\n        : 'linear-gradient(90deg, #e74c3c, #c0392b)';\n    }\n    updateUI();\n\n    // Input\n    const keys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false, KeyA: false, KeyD: false, KeyW: false, KeyS: false, Space: false };\n    window.addEventListener('keydown', (e) => { if (e.code in keys) { keys[e.code] = true; if (e.code === 'Space') firing = true; } });\n    window.addEventListener('keyup', (e) => { if (e.code in keys) { keys[e.code] = false; if (e.code === 'Space') firing = false; } });\n\n    const touch = {\n      moving: false,\n      fireHeld: false,\n      moveOrigin: new THREE.Vector2(),\n      moveDelta: new THREE.Vector2(),\n    };\n    const moveZone = document.getElementById('moveZone');\n    const fireZone = document.getElementById('fireZone');\n\n    function normPos(clientX, clientY) {\n      return new THREE.Vector2(\n        (clientX / window.innerWidth) * 2 - 1,\n        -(clientY / window.innerHeight) * 2 + 1\n      );\n    }\n    function handleMoveTouch(clientX, clientY) {\n      const v = new THREE.Vector2(clientX, clientY);\n      touch.moveDelta.copy(v).sub(touch.moveOrigin);\n      const max = Math.min(window.innerWidth, window.innerHeight) * 0.35;\n      touch.moveDelta.clampLength(-max, max);\n    }\n    moveZone.addEventListener('pointerdown', (e) => { touch.moving = true; touch.moveOrigin.set(e.clientX, e.clientY); handleMoveTouch(e.clientX, e.clientY); });\n    moveZone.addEventListener('pointermove', (e) => { if (touch.moving) handleMoveTouch(e.clientX, e.clientY); });\n    moveZone.addEventListener('pointerup', () => { touch.moving = false; touch.moveDelta.set(0,0); });\n    moveZone.addEventListener('pointercancel', () => { touch.moving = false; touch.moveDelta.set(0,0); });\n\n    let firing = false;\n    fireZone.addEventListener('pointerdown', () => { firing = true; touch.fireHeld = true; });\n    fireZone.addEventListener('pointerup', () => { firing = false; touch.fireHeld = false; });\n    fireZone.addEventListener('pointercancel', () => { firing = false; touch.fireHeld = false; });\n\n    // Starfield\n    function createStarfield(count = 2000, depth = 180, spreadX = 18, spreadY = 12, size = 1.5, color = 0xffffff) {\n      const g = new THREE.BufferGeometry();\n      const positions = new Float32Array(count * 3);\n      const speeds = new Float32Array(count);\n      for (let i = 0; i < count; i++) {\n        const i3 = i * 3;\n        positions[i3]   = (Math.random() * 2 - 1) * spreadX;\n        positions[i3+1] = (Math.random() * 2 - 1) * spreadY;\n        positions[i3+2] = -Math.random() * depth - 10;\n        speeds[i] = 0.6 + Math.random() * 1.4; // parallax per-star\n      }\n      g.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n      g.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));\n      const m = new THREE.PointsMaterial({ color, size, sizeAttenuation: true, transparent: true, opacity: 0.9, depthWrite: false });\n      const pts = new THREE.Points(g, m);\n      return pts;\n    }\n    const starsNear = createStarfield(1400, 120, 14, 9, 1.6, 0xbbddff);\n    const starsFar  = createStarfield(2200, 220, 20, 14, 1.0, 0x88aaff);\n    scene.add(starsFar, starsNear);\n    function updateStars(dt) {\n      for (const pts of [starsFar, starsNear]) {\n        const arr = pts.geometry.attributes.position.array;\n        const spd = pts.geometry.attributes.aSpeed.array;\n        for (let i = 0; i < spd.length; i++) {\n          const i3 = i*3 + 2;\n          arr[i3] += (worldSpeed * 0.6 * dt * spd[i]);\n          if (arr[i3] > camera.position.z + 2) {\n            arr[i3] = -200 - Math.random() * 200;\n            // slight reposition for variety\n            const j3 = i*3;\n            arr[j3]   = (Math.random() * 2 - 1) * 20;\n            arr[j3+1] = (Math.random() * 2 - 1) * 14;\n          }\n        }\n        pts.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n\n    // GPU Particle system (hit sparks)\n    function createParticleSystem(maxParticles = 2500) {\n      const geom = new THREE.BufferGeometry();\n      const positions = new Float32Array(maxParticles * 3);\n      const velocities = new Float32Array(maxParticles * 3);\n      const startTimes = new Float32Array(maxParticles);\n      const lifetimes = new Float32Array(maxParticles);\n      const seeds = new Float32Array(maxParticles);\n      for (let i = 0; i < maxParticles; i++) {\n        positions[i*3+0] = positions[i*3+1] = positions[i*3+2] = 9999; // offscreen initial\n        velocities[i*3+0] = velocities[i*3+1] = velocities[i*3+2] = 0;\n        startTimes[i] = -1e6;\n        lifetimes[i] = 0.0;\n        seeds[i] = Math.random();\n      }\n      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n      geom.setAttribute('aVelocity', new THREE.BufferAttribute(velocities, 3));\n      geom.setAttribute('aStartTime', new THREE.BufferAttribute(startTimes, 1));\n      geom.setAttribute('aLife', new THREE.BufferAttribute(lifetimes, 1));\n      geom.setAttribute('aSeed', new THREE.BufferAttribute(seeds, 1));\n\n      const material = new THREE.ShaderMaterial({\n        transparent: true,\n        depthWrite: false,\n        blending: THREE.AdditiveBlending,\n        uniforms: {\n          uTime: { value: 0 },\n        },\n        vertexShader: `\n          uniform float uTime;\n          attribute vec3 aVelocity;\n          attribute float aStartTime;\n          attribute float aLife;\n          attribute float aSeed;\n          varying float vAlpha;\n          varying vec3 vColor;\n          void main() {\n            float age = uTime - aStartTime;\n            float alive = step(0.0, age) * step(age, aLife);\n            vec3 pos = position + aVelocity * max(age, 0.0);\n            vAlpha = alive * (1.0 - smoothstep(0.0, aLife, age));\n            // orange to yellowish sparks with slight variation\n            vColor = mix(vec3(1.0, 0.35, 0.05), vec3(1.0, 0.8, 0.2), fract(aSeed * 7.318));\n            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n            gl_PointSize = 55.0 / -mvPosition.z; // size attenuated with depth\n            gl_Position = projectionMatrix * mvPosition;\n          }\n        `,\n        fragmentShader: `\n          precision mediump float;\n          varying float vAlpha;\n          varying vec3 vColor;\n          void main() {\n            vec2 uv = gl_PointCoord - 0.5;\n            float d = length(uv);\n            float soft = smoothstep(0.5, 0.0, d);\n            gl_FragColor = vec4(vColor, vAlpha * soft);\n          }\n        `\n      });\n\n      const points = new THREE.Points(geom, material);\n      points.frustumCulled = false;\n\n      const pool = { head: 0, max: maxParticles };\n      function spawnBurst(pos, count = 40, spread = 3.5, life = 0.6) {\n        const p = geom.attributes.position.array;\n        const v = geom.attributes.aVelocity.array;\n        const s = geom.attributes.aStartTime.array;\n        const l = geom.attributes.aLife.array;\n        const now = elapsed;\n        for (let i = 0; i < count; i++) {\n          const idx = pool.head;\n          pool.head = (pool.head + 1) % pool.max;\n          p[idx*3+0] = pos.x;\n          p[idx*3+1] = pos.y;\n          p[idx*3+2] = pos.z;\n          // random hemi-sphere blast toward camera\n          const theta = Math.random() * Math.PI * 2;\n          const phi = Math.random() * 0.8 + 0.1;\n          const speed = spread * (0.5 + Math.random());\n          const vx = Math.cos(theta) * Math.sin(phi) * speed;\n          const vy = Math.sin(theta) * Math.sin(phi) * speed;\n          const vz = Math.cos(phi) * speed * (Math.random() > 0.3 ? 1 : -0.5);\n          v[idx*3+0] = vx;\n          v[idx*3+1] = vy;\n          v[idx*3+2] = vz;\n          s[idx] = now;\n          l[idx] = life * (0.7 + Math.random() * 0.6);\n        }\n        geom.attributes.position.needsUpdate = true;\n        geom.attributes.aVelocity.needsUpdate = true;\n        geom.attributes.aStartTime.needsUpdate = true;\n        geom.attributes.aLife.needsUpdate = true;\n      }\n\n      return { points, material, spawnBurst };\n    }\n    const particles = createParticleSystem(2600);\n    scene.add(particles.points);\n\n    // Lasers (Instanced)\n    const laserMax = 220;\n    const laserGeo = new THREE.BoxGeometry(0.08, 0.08, 1.6);\n    const laserMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, emissive: 0x66ccff, toneMapped: false });\n    const laserMesh = new THREE.InstancedMesh(laserGeo, laserMat, laserMax);\n    laserMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n    scene.add(laserMesh);\n    const laserActive = new Uint8Array(laserMax);\n    const laserPos = new Float32Array(laserMax * 3);\n    const laserVel = new Float32Array(laserMax * 3);\n    let laserHead = 0;\n    const tmpMat = new THREE.Matrix4();\n    function spawnLaser() {\n      const idx = laserHead;\n      laserHead = (laserHead + 1) % laserMax;\n      const i3 = idx * 3;\n      laserActive[idx] = 1;\n      laserPos[i3+0] = ship.position.x;\n      laserPos[i3+1] = ship.position.y;\n      laserPos[i3+2] = ship.position.z - 0.6;\n      laserVel[i3+0] = 0;\n      laserVel[i3+1] = 0;\n      laserVel[i3+2] = -50.0; // towards -Z\n      // initial matrix\n      tmpMat.makeTranslation(laserPos[i3+0], laserPos[i3+1], laserPos[i3+2]);\n      laserMesh.setMatrixAt(idx, tmpMat);\n      laserMesh.instanceMatrix.needsUpdate = true;\n    }\n    // Enemy ships (Instanced)\n    const enemyMax = 160;\n    const enemyGeo = new THREE.IcosahedronGeometry(0.6, 0);\n    const enemyMat = new THREE.MeshStandardMaterial({\n      color: 0xff6666, metalness: 0.1, roughness: 0.5,\n      emissive: 0x330000, emissiveIntensity: 0.6\n    });\n    const enemyMesh = new THREE.InstancedMesh(enemyGeo, enemyMat, enemyMax);\n    enemyMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n    scene.add(enemyMesh);\n    const enemyActive = new Uint8Array(enemyMax);\n    const enemyPos = new Float32Array(enemyMax * 3);\n    const enemyVel = new Float32Array(enemyMax * 3);\n    const enemyHP  = new Float32Array(enemyMax);\n    const enemyRot = new Float32Array(enemyMax * 3); // rotational speed per axis\n    const enemyScale = new Float32Array(enemyMax);\n    let enemiesAlive = 0;\n\n    function deactivateEnemy(i) {\n      enemyActive[i] = 0;\n      enemiesAlive = Math.max(0, enemiesAlive - 1);\n      const mat = new THREE.Matrix4();\n      mat.makeScale(0,0,0);\n      enemyMesh.setMatrixAt(i, mat);\n      enemyMesh.instanceMatrix.needsUpdate = true;\n    }\n\n    function spawnWave() {\n      const freeSlots = enemyMax - enemiesAlive;\n      const baseCount = Math.min(5 + Math.floor((wave - 1) * 0.8), 14);\n      const count = Math.min(baseCount + Math.floor(Math.random() * 4), freeSlots);\n      const spreadX = 6 + Math.min(8, wave);\n      const spreadY = 3 + Math.min(5, wave * 0.6);\n      const zStart = -60 - Math.random() * 20;\n      for (let n = 0; n < count; n++) {\n        // find slot\n        let idx = -1;\n        for (let i = 0; i < enemyMax; i++) { if (!enemyActive[i]) { idx = i; break; } }\n        if (idx < 0) break;\n        enemyActive[idx] = 1;\n        enemiesAlive++;\n        const i3 = idx * 3;\n        // formation: grid-ish within spread box\n        const fx = (Math.random() * 2 - 1) * spreadX;\n        const fy = (Math.random() * 2 - 1) * spreadY;\n        enemyPos[i3+0] = fx;\n        enemyPos[i3+1] = fy;\n        enemyPos[i3+2] = zStart - Math.random() * 20;\n        const speedZ = (6.0 + Math.random() * 1.5) * difficulty;\n        enemyVel[i3+0] = Math.sin((fx + fy) * 0.2) * 0.2 * difficulty;\n        enemyVel[i3+1] = Math.cos((fx - fy) * 0.2) * 0.2 * difficulty;\n        enemyVel[i3+2] = speedZ;\n        enemyHP[idx] = 2 + Math.floor((wave - 1) * 0.3);\n        enemyRot[i3+0] = (Math.random() * 2 - 1) * 1.5;\n        enemyRot[i3+1] = (Math.random() * 2 - 1) * 1.5;\n        enemyRot[i3+2] = (Math.random() * 2 - 1) * 1.5;\n        enemyScale[idx] = 1.0 + Math.random() * 0.2 + Math.min(0.6, (difficulty - 1) * 0.2);\n        // write matrix initially\n        const mat = new THREE.Matrix4();\n        const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,0,0));\n        mat.compose(new THREE.Vector3(enemyPos[i3+0], enemyPos[i3+1], enemyPos[i3+2]), q, new THREE.Vector3(enemyScale[idx], enemyScale[idx], enemyScale[idx]));\n        enemyMesh.setMatrixAt(idx, mat);\n      }\n      enemyMesh.instanceMatrix.needsUpdate = true;\n    }\n\n    // Game state and logic\n    let fireTimer = 0;\n    let fireRate = 0.16; // seconds between shots\n    const shipBounds = { x: 7.5, y: 4.6 };\n    const moveSpeed = 14.0;\n    const shipTarget = new THREE.Vector2(0, 0);\n\n    function handleInput(dt) {\n      // Keyboard\n      const dx = (keys.ArrowRight || keys.KeyD) - (keys.ArrowLeft || keys.KeyA);\n      const dy = (keys.ArrowUp || keys.KeyW) - (keys.ArrowDown || keys.KeyS);\n\n      // Touch drag on left half\n      let tx = 0, ty = 0;\n      if (touch.moving) {\n        const max = Math.min(window.innerWidth, window.innerHeight) * 0.35;\n        tx = (touch.moveDelta.x / max) * 1.2;\n        ty = (-touch.moveDelta.y / max) * 1.2;\n      }\n\n      // Combine inputs\n      const targetX = THREE.MathUtils.clamp(shipTarget.x + (dx + tx) * dt * moveSpeed, -1.0, 1.0);\n      const targetY = THREE.MathUtils.clamp(shipTarget.y + (dy + ty) * dt * moveSpeed, -1.0, 1.0);\n      shipTarget.set(targetX, targetY);\n\n      // Convert target to world bounds\n      const desiredX = THREE.MathUtils.clamp(shipTarget.x * shipBounds.x, -shipBounds.x, shipBounds.x);\n      const desiredY = THREE.MathUtils.clamp(shipTarget.y * shipBounds.y, -shipBounds.y, shipBounds.y);\n\n      // Smoothly move the ship\n      ship.position.x = THREE.MathUtils.lerp(ship.position.x, desiredX, 1.0 - Math.pow(0.001, dt));\n      ship.position.y = THREE.MathUtils.lerp(ship.position.y, desiredY, 1.0 - Math.pow(0.001, dt));\n\n      // Tilt ship based on motion\n      const tiltX = THREE.MathUtils.clamp((desiredY - ship.position.y) * 0.5, -0.35, 0.35);\n      const tiltZ = THREE.MathUtils.clamp((ship.position.x - desiredX) * 0.4, -0.35, 0.35);\n      ship.rotation.set(tiltX, 0, tiltZ);\n    }\n\n    function updateLasers(dt) {\n      for (let i = 0; i < laserMax; i++) {\n        if (!laserActive[i]) continue;\n        const i3 = i * 3;\n        laserPos[i3+0] += laserVel[i3+0] * dt;\n        laserPos[i3+1] += laserVel[i3+1] * dt;\n        laserPos[i3+2] += laserVel[i3+2] * dt;\n        // deactivate if far\n        if (laserPos[i3+2] < -140) {\n          laserActive[i] = 0;\n          tmpMat.makeScale(0,0,0);\n          laserMesh.setMatrixAt(i, tmpMat);\n          continue;\n        }\n        tmpMat.makeTranslation(laserPos[i3+0], laserPos[i3+1], laserPos[i3+2]);\n        laserMesh.setMatrixAt(i, tmpMat);\n      }\n      laserMesh.instanceMatrix.needsUpdate = true;\n    }\n\n    function updateEnemies(dt) {\n      const mat = new THREE.Matrix4();\n      const quat = new THREE.Quaternion();\n      for (let i = 0; i < enemyMax; i++) {\n        if (!enemyActive[i]) continue;\n        const i3 = i * 3;\n        enemyPos[i3+0] += enemyVel[i3+0] * dt;\n        enemyPos[i3+1] += enemyVel[i3+1] * dt;\n        enemyPos[i3+2] += enemyVel[i3+2] * dt;\n\n        // oscillate slightly\n        enemyPos[i3+0] += Math.sin(elapsed * 2.0 + i) * 0.2 * dt * difficulty;\n        enemyPos[i3+1] += Math.cos(elapsed * 1.8 + i * 0.5) * 0.2 * dt * difficulty;\n\n        // rotate\n        const eul = new THREE.Euler(enemyRot[i3+0]*elapsed*0.15, enemyRot[i3+1]*elapsed*0.2, enemyRot[i3+2]*elapsed*0.12);\n        quat.setFromEuler(eul);\n        mat.compose(\n          new THREE.Vector3(enemyPos[i3+0], enemyPos[i3+1], enemyPos[i3+2]),\n          quat,\n          new THREE.Vector3(enemyScale[i], enemyScale[i], enemyScale[i])\n        );\n        enemyMesh.setMatrixAt(i, mat);\n\n        // if passes player (hit or slip-by), damage player and remove\n        if (enemyPos[i3+2] > camera.position.z + 1.0) {\n          playerHealth -= 8;\n          particles.spawnBurst(new THREE.Vector3(enemyPos[i3+0], enemyPos[i3+1], enemyPos[i3+2]), 60, 5.0, 0.7);\n          deactivateEnemy(i);\n          if (playerHealth <= 0) endGame();\n        }\n      }\n      enemyMesh.instanceMatrix.needsUpdate = true;\n    }\n\n    function checkCollisions() {\n      const enemyRadius = 0.7;\n      const laserRadius = 0.1;\n      // Enemy vs Player\n      const shipPos = ship.position;\n      for (let i = 0; i < enemyMax; i++) {\n        if (!enemyActive[i]) continue;\n        const i3 = i * 3;\n        const dx = enemyPos[i3+0] - shipPos.x;\n        const dy = enemyPos[i3+1] - shipPos.y;\n        const dz = enemyPos[i3+2] - shipPos.z;\n        const d2 = dx*dx + dy*dy + dz*dz;\n        if (d2 < (enemyRadius + 0.7) * (enemyRadius + 0.7)) {\n          // collision with player\n          playerHealth -= 15;\n          particles.spawnBurst(new THREE.Vector3(enemyPos[i3+0], enemyPos[i3+1], enemyPos[i3+2]), 90, 6.0, 0.8);\n          deactivateEnemy(i);\n          if (playerHealth <= 0) endGame();\n        }\n      }\n      // Lasers vs Enemies (brute force)\n      for (let l = 0; l < laserMax; l++) {\n        if (!laserActive[l]) continue;\n        const l3 = l * 3;\n        for (let e = 0; e < enemyMax; e++) {\n          if (!enemyActive[e]) continue;\n          const e3 = e * 3;\n          const dx = enemyPos[e3+0] - laserPos[l3+0];\n          const dy = enemyPos[e3+1] - laserPos[l3+1];\n          const dz = enemyPos[e3+2] - laserPos[l3+2];\n          const r = enemyRadius + laserRadius;\n          if (dx*dx + dy*dy + dz*dz < r*r) {\n            // Hit!\n            laserActive[l] = 0;\n            tmpMat.makeScale(0,0,0);\n            laserMesh.setMatrixAt(l, tmpMat);\n            enemyHP[e] -= 1;\n            particles.spawnBurst(new THREE.Vector3(laserPos[l3+0], laserPos[l3+1], laserPos[l3+2]), 50, 4.0, 0.55);\n            if (enemyHP[e] <= 0) {\n              score += 10 + Math.floor(2 * (difficulty - 1));\n              deactivateEnemy(e);\n            }\n            break;\n          }\n        }\n      }\n      laserMesh.instanceMatrix.needsUpdate = true;\n      updateUI();\n    }\n\n    // Wave and Difficulty\n    let waveTimer = 0;\n    let waveInterval = 3.6;\n    function updateDifficulty(dt) {\n      // Scale difficulty slowly over time\n      difficulty = 1.0 + Math.min(3.0, elapsed * 0.05) + (wave - 1) * 0.08;\n      worldSpeed = 9.5 + (difficulty - 1) * 1.4;\n      fireRate = 0.16 - Math.min(0.08, (difficulty - 1) * 0.015); // faster fire rate a bit\n      waveTimer -= dt;\n      if (waveTimer <= 0) {\n        spawnWave();\n        wave++;\n        waveInterval = Math.max(1.6, 3.6 - (difficulty - 1) * 0.25);\n        waveTimer = waveInterval;\n      }\n    }\n\n    // Game lifecycle\n    function endGame() {\n      if (!running) return;\n      running = false;\n      finalScoreEl.textContent = `Score: ${score}`;\n      gameOverEl.style.display = 'flex';\n    }\n    function resetGame() {\n      // reset enemies\n      for (let i = 0; i < enemyMax; i++) deactivateEnemy(i);\n      enemiesAlive = 0;\n      // reset lasers\n      for (let i = 0; i < laserMax; i++) {\n        laserActive[i] = 0;\n        tmpMat.makeScale(0,0,0);\n        laserMesh.setMatrixAt(i, tmpMat);\n      }\n      laserMesh.instanceMatrix.needsUpdate = true;\n      // reset player\n      ship.position.set(0, 0, 5.5);\n      shipTarget.set(0, 0);\n      playerHealth = 100;\n      score = 0;\n      wave = 1;\n      difficulty = 1.0;\n      waveTimer = 1.0;\n      elapsed = 0;\n      fireTimer = 0;\n      updateUI();\n      gameOverEl.style.display = 'none';\n      running = true;\n    }\n    restartBtn.addEventListener('click', resetGame);\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) running = false;\n      else running = true;\n    });\n\n    // Initial wave\n    waveTimer = 1.0;\n\n    // Main loop\n    function animate() {\n      requestAnimationFrame(animate);\n      const dt = Math.min(0.033, clock.getDelta());\n      elapsed += dt;\n\n      // Update particle time uniform\n      particles.material.uniforms.uTime.value = elapsed;\n\n      if (running) {\n        handleInput(dt);\n\n        // Firing control\n        fireTimer -= dt;\n        const wantFire = firing || keys.Space;\n        if (wantFire && fireTimer <= 0) {\n          fireTimer = fireRate;\n          spawnLaser();\n        }\n\n        updateLasers(dt);\n        updateEnemies(dt);\n        checkCollisions();\n        updateDifficulty(dt);\n      }\n\n      updateStars(dt);\n\n      // Render\n      composer.render();\n    }\n\n    // Resize handling\n    function onResize() {\n      const w = window.innerWidth;\n      const h = window.innerHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n      composer.setSize(w, h);\n      bloomPass.setSize(w, h);\n    }\n    window.addEventListener('resize', onResize);\n\n    // Kick off\n    onResize();\n    animate();\n\n    // Small entrance burst\n    setTimeout(() => {\n      particles.spawnBurst(new THREE.Vector3(0, -1.5, ship.position.z + 1.2), 80, 3.0, 0.8);\n    }, 800);\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 136.85926508903503,
    "status": "success",
    "timestamp": "2025-08-29 18:03:22"
  },
  {
    "test_name": "architectural_walkthrough",
    "prompt": "Create a complete HTML file with Three.js that creates an interactive walkthrough for a procedurally generated house with first-person controls with collision detection, baked/IBL lighting, light probes, room-based culling, interactive hotspots that toggle materials/furniture, and a minimap. Include multiple rooms and furniture. The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'architectural_walkthrough.html'.",
    "response": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Procedural Architectural Walkthrough - Three.js</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    html, body {\n      margin: 0;\n      height: 100%;\n      overflow: hidden;\n      background: #0b0e11;\n      color: #eaeaea;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;\n    }\n    #overlay {\n      position: absolute;\n      inset: 0;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      background: radial-gradient(ellipse at center, rgba(0,0,0,0.75), rgba(0,0,0,0.95));\n      text-align: center;\n      cursor: pointer;\n      user-select: none;\n      z-index: 10;\n    }\n    #overlay .panel {\n      max-width: 800px;\n      line-height: 1.4;\n      background: rgba(20,22,28,0.8);\n      border: 1px solid rgba(255,255,255,0.1);\n      border-radius: 10px;\n      padding: 22px 28px;\n      box-shadow: 0 30px 60px rgba(0,0,0,0.6);\n      backdrop-filter: blur(6px);\n    }\n    #overlay h1 {\n      font-weight: 700;\n      margin: 0 0 8px;\n      font-size: 22px;\n      color: #fff;\n    }\n    #overlay p {\n      margin: 6px 0;\n      color: #cfd6df;\n      font-size: 14px;\n    }\n    #overlay kbd {\n      background: #11151a;\n      color: #dfe7f0;\n      border: 1px solid rgba(255,255,255,0.15);\n      border-bottom-color: rgba(0,0,0,0.7);\n      border-radius: 6px;\n      padding: 2px 6px;\n      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.3);\n      font-weight: 700;\n      font-size: 12px;\n    }\n    #hud {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      padding: 6px 8px;\n      border-radius: 8px;\n      background: rgba(10,12,16,0.6);\n      border: 1px solid rgba(255,255,255,0.1);\n      font-size: 12px;\n      color: #cfd6df;\n      user-select: none;\n      pointer-events: none;\n      z-index: 1;\n      white-space: pre;\n    }\n    #crosshair {\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      width: 14px; height: 14px;\n      transform: translate(-50%, -50%);\n      border-radius: 50%;\n      box-shadow:\n        0 0 0 2px rgba(255,255,255,0.1) inset,\n        0 0 10px rgba(0,0,0,0.7);\n      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.15) 35%, rgba(255,255,255,0.0) 60%);\n      opacity: 0.65;\n      pointer-events: none;\n      z-index: 2;\n    }\n    #label {\n      position: absolute;\n      bottom: 12px;\n      left: 50%;\n      transform: translateX(-50%);\n      background: rgba(20,22,28,0.7);\n      border: 1px solid rgba(255,255,255,0.1);\n      border-radius: 6px;\n      padding: 6px 10px;\n      font-size: 12px;\n      color: #dfe7f0;\n      pointer-events: none;\n      opacity: 0;\n      transition: opacity 0.15s ease;\n      white-space: nowrap;\n      z-index: 2;\n    }\n    #minimapFrame {\n      position: absolute;\n      right: 12px;\n      bottom: 12px;\n      width: 240px;\n      height: 240px;\n      border-radius: 10px;\n      background: rgba(12,16,22,0.7);\n      border: 1px solid rgba(255,255,255,0.08);\n      box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(0,0,0,0.3);\n      pointer-events: none;\n      z-index: 1;\n    }\n    #minimapTitle {\n      position: absolute;\n      right: 18px; bottom: 18px;\n      color: #a6b2bf;\n      font-size: 11px;\n      z-index: 2;\n      pointer-events: none;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"overlay\">\n    <div class=\"panel\">\n      <h1>Procedural House Walkthrough</h1>\n      <p>Click to start and lock pointer. Explore a procedurally generated multi-room house with lighting, light probes, culling, collisions, hotspots, and a minimap.</p>\n      <p>\n        Movement: <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> &nbsp; | &nbsp;\n        Sprint: <kbd>Shift</kbd> &nbsp; | &nbsp;\n        Jump: <kbd>Space</kbd> &nbsp; | &nbsp;\n        Interact: <kbd>E</kbd> (aim at hotspot)\n      </p>\n      <p>\n        Toggle minimap: <kbd>V</kbd> &nbsp; | &nbsp;\n        Toggle probe helpers: <kbd>H</kbd> &nbsp; | &nbsp;\n        Toggle hotspot labels: <kbd>L</kbd>\n      </p>\n      <p style=\"opacity:0.7\">Tip: Rooms render with room-based culling. Move through doorways to load adjacent rooms.</p>\n      <p style=\"margin-top: 10px; opacity:0.8\"><small>Environment IBL + Light Probes + fake baked lightmaps</small></p>\n      <p style=\"margin:10px 0 0; opacity:0.8\"><small>Seeded by URL param ?seed=123</small></p>\n    </div>\n  </div>\n  <div id=\"hud\"></div>\n  <div id=\"crosshair\"></div>\n  <div id=\"label\">Hotspot: Press E</div>\n  <div id=\"minimapFrame\"></div>\n  <div id=\"minimapTitle\">Minimap</div>\n\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';\n    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';\n    import { RGBELoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/RGBELoader.js';\n    import { LightProbeGenerator } from 'https://unpkg.com/three@0.160.0/examples/jsm/lights/LightProbeGenerator.js';\n    import { LightProbeHelper } from 'https://unpkg.com/three@0.160.0/examples/jsm/helpers/LightProbeHelper.js';\n\n    // Globals\n    let renderer, scene, camera, minimapCamera, controls;\n    const clock = new THREE.Clock();\n    const hud = document.getElementById('hud');\n    const overlay = document.getElementById('overlay');\n    const label = document.getElementById('label');\n    const minimapFrame = document.getElementById('minimapFrame');\n    const minimapTitle = document.getElementById('minimapTitle');\n\n    // State\n    const world = {\n      rooms: [],\n      roomLayerStart: 1,\n      colliders: [],\n      hotspots: [],\n      furniture: [],\n      doorLayerLinks: new Map(), // roomIndex -> Set(layer indexes)\n      probeHelpers: [],\n      currentRoomIndex: -1,\n      extents: new THREE.Box2(new THREE.Vector2(0,0), new THREE.Vector2(0,0))\n    };\n\n    const params = {\n      seed: getSeedFromURL() ?? Math.floor(Math.random() * 1e9),\n      playerHeight: 1.65,\n      speed: 2.6,\n      sprint: 4.5,\n      gravity: 18,\n      jump: 5.2,\n      radius: 0.28,\n      wallHeight: 2.7,\n      wallThickness: 0.2,\n      doorWidth: 1.0,\n      doorHeight: 2.1,\n      showMinimap: true,\n      showLabel: true,\n      showProbeHelpers: false,\n    };\n\n    // Movement state\n    const move = { forward: false, backward: false, left: false, right: false, running: false, canJump: true, velocityY: 0 };\n\n    // Layers:\n    //  - 0: unused here (we'll not rely on default layer)\n    //  - 1..N: rooms geometry and hotspots\n    //  - 31: minimap arrow only\n    const LAYER_MINIMAP_ONLY = 31;\n\n    // RNG\n    const rng = mulberry32(params.seed);\n\n    // Set up renderer\n    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });\n    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.shadowMap.enabled = false;\n    renderer.setScissorTest(true);\n    document.body.appendChild(renderer.domElement);\n\n    // Scene and cameras\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x0b0e11);\n\n    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 200);\n    camera.position.set(0, params.playerHeight, 0);\n\n    minimapCamera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 200);\n    minimapCamera.rotation.order = 'YXZ';\n    minimapCamera.rotation.x = -Math.PI / 2;\n    minimapCamera.layers.enableAll(); // see everything\n    camera.layers.disableAll(); // we'll enable current/adjacent room layers dynamically\n\n    // Player arrow for minimap\n    const arrow = new THREE.Mesh(\n      new THREE.ConeGeometry(0.25, 0.8, 16),\n      new THREE.MeshBasicMaterial({ color: 0xff5555, depthTest: true })\n    );\n    arrow.rotation.x = Math.PI / 2;\n    arrow.position.y = params.wallHeight + 0.02;\n    arrow.layers.disableAll();\n    arrow.layers.enable(LAYER_MINIMAP_ONLY);\n    scene.add(arrow);\n\n    // Controls\n    controls = new PointerLockControls(camera, renderer.domElement);\n    controls.getObject().position.y = params.playerHeight;\n    scene.add(controls.getObject());\n\n    overlay.addEventListener('click', () => {\n      controls.lock();\n    });\n\n    controls.addEventListener('lock', () => {\n      overlay.style.display = 'none';\n    });\n    controls.addEventListener('unlock', () => {\n      overlay.style.display = '';\n    });\n\n    // Lighting: IBL + light probes + gentle fill\n    const hemi = new THREE.HemisphereLight(0xddeeff, 0x111118, 0.08);\n    scene.add(hemi);\n\n    const pmrem = new THREE.PMREMGenerator(renderer);\n    pmrem.compileEquirectangularShader();\n\n    // Load an HDR environment for IBL\n    new RGBELoader()\n      .setDataType(THREE.HalfFloatType)\n      .load('https://unpkg.com/three@0.160.0/examples/textures/equirectangular/royal_esplanade_1k.hdr', (hdr) => {\n        const rt = pmrem.fromEquirectangular(hdr);\n        hdr.dispose();\n        scene.environment = rt.texture;\n\n        // Global light probe\n        const lightProbe = LightProbeGenerator.fromCubeRenderTarget(renderer, rt);\n        lightProbe.intensity = 1.0;\n        scene.add(lightProbe);\n\n        // Build the world after environment is ready (so materials can reflect)\n        buildWorld();\n        animate();\n      });\n\n    // Baked lightmap texture (fake radial AO)\n    const bakedLightMap = generateRadialLightMap(256);\n\n    // Materials factory\n    const Mats = materialFactory();\n\n    // Build procedural house\n    function buildWorld() {\n      const house = generateHouseLayout();\n      buildRooms(house);\n      addFurnitureAndHotspots();\n      finalizeMinimap(house);\n\n      // Set initial camera position in the first room\n      const r0 = world.rooms[0];\n      controls.getObject().position.set(r0.cx, params.playerHeight, r0.cz);\n      updateCurrentRoom();\n\n      // HUD\n      hud.textContent = `Seed: ${params.seed}\nRooms: ${world.rooms.length}\nControls: WASD move, Shift sprint, E interact, H probes, V minimap, L labels\n`;\n    }\n\n    // Layout generation\n    function generateHouseLayout() {\n      // Start with a base room at origin\n      const baseW = randRange(5.0, 7.0);\n      const baseH = randRange(4.0, 6.0);\n      const rooms = [];\n      const rects = []; // For overlap tests\n\n      function addRoom(cx, cz, w, h, name) {\n        const idx = rooms.length;\n        const room = {\n          index: idx,\n          name,\n          cx, cz, w, h,\n          x0: cx - w / 2,\n          x1: cx + w / 2,\n          z0: cz - h / 2,\n          z1: cz + h / 2,\n          neighbors: [],\n          doors: [], // { side, x, z }\n          layer: world.roomLayerStart + idx,\n          group: new THREE.Group()\n        };\n        rooms.push(room);\n        rects.push(room);\n        return room;\n      }\n\n      addRoom(0, 0, baseW, baseH, 'Living');\n\n      // Add up to 3 more rooms adjacent to existing ones\n      const names = ['Kitchen', 'Bedroom', 'Office', 'Hall', 'Bath', 'Dining'];\n      for (let i = 0; i < 3; i++) {\n        const target = rooms[Math.floor(rng() * rooms.length)];\n        const side = ['N', 'E', 'S', 'W'][Math.floor(rng() * 4)];\n        const w = randRange(3.6, 5.5);\n        const h = randRange(3.4, 5.0);\n        let cx = target.cx, cz = target.cz;\n        const gap = params.wallThickness; // adjacency wall thickness\n\n        if (side === 'N') { cx = target.cx; cz = target.z1 + h / 2 + gap; }\n        if (side === 'S') { cx = target.cx; cz = target.z0 - h / 2 - gap; }\n        if (side === 'E') { cz = target.cz; cx = target.x1 + w / 2 + gap; }\n        if (side === 'W') { cz = target.cz; cx = target.x0 - w / 2 - gap; }\n\n        const candidate = { x0: cx - w / 2, x1: cx + w / 2, z0: cz - h / 2, z1: cz + h / 2 };\n        let overlaps = false;\n        for (const r of rects) {\n          const sep = candidate.x1 <= r.x0 || candidate.x0 >= r.x1 || candidate.z1 <= r.z0 || candidate.z0 >= r.z1;\n          if (!sep) { overlaps = true; break; }\n        }\n        if (overlaps) { i--; continue; } // retry\n\n        const name = names.length ? names.splice(Math.floor(rng() * names.length), 1)[0] : `Room ${rooms.length}`;\n        const newRoom = addRoom(cx, cz, w, h, name);\n\n        // Connect them with a door on the shared wall\n        connectRoomsWithDoor(target, newRoom);\n      }\n\n      // compute extents\n      const min = new THREE.Vector2(Infinity, Infinity);\n      const max = new THREE.Vector2(-Infinity, -Infinity);\n      for (const r of rooms) {\n        min.x = Math.min(min.x, r.x0);\n        min.y = Math.min(min.y, r.z0);\n        max.x = Math.max(max.x, r.x1);\n        max.y = Math.max(max.y, r.z1);\n      }\n      world.extents.set(min, max);\n\n      return rooms;\n    }\n\n    function connectRoomsWithDoor(a, b) {\n      // Determine which side they touch (axis-aligned)\n      // They are placed exactly adjacent.\n      const overlapX = Math.max(0, Math.min(a.x1, b.x1) - Math.max(a.x0, b.x0));\n      const overlapZ = Math.max(0, Math.min(a.z1, b.z1) - Math.max(a.z0, b.z0));\n      let sideA = null, sideB = null;\n      let x = 0, z = 0;\n\n      if (overlapX > 0) {\n        // stacked in Z\n        if (a.z1 <= b.z0) { sideA = 'N'; sideB = 'S'; z = a.z1; x = clamp((Math.max(a.x0, b.x0) + Math.min(a.x1, b.x1)) / 2, Math.max(a.x0, b.x0) + 0.8, Math.min(a.x1, b.x1) - 0.8); }\n        else if (b.z1 <= a.z0) { sideA = 'S'; sideB = 'N'; z = a.z0; x = clamp((Math.max(a.x0, b.x0) + Math.min(a.x1, b.x1)) / 2, Math.max(a.x0, b.x0) + 0.8, Math.min(a.x1, b.x1) - 0.8); }\n      } else if (overlapZ > 0) {\n        // stacked in X\n        if (a.x1 <= b.x0) { sideA = 'E'; sideB = 'W'; x = a.x1; z = clamp((Math.max(a.z0, b.z0) + Math.min(a.z1, b.z1)) / 2, Math.max(a.z0, b.z0) + 0.8, Math.min(a.z1, b.z1) - 0.8); }\n        else if (b.x1 <= a.x0) { sideA = 'W'; sideB = 'E'; x = a.x0; z = clamp((Math.max(a.z0, b.z0) + Math.min(a.z1, b.z1)) / 2, Math.max(a.z0, b.z0) + 0.8, Math.min(a.z1, b.z1) - 0.8); }\n      }\n\n      if (sideA && sideB) {\n        a.neighbors.push(b.index);\n        b.neighbors.push(a.index);\n        a.doors.push({ side: sideA, x, z });\n        b.doors.push({ side: sideB, x, z });\n      }\n    }\n\n    function buildRooms(rooms) {\n      for (const r of rooms) {\n        const group = r.group;\n        scene.add(group);\n\n        // Layers\n        group.traverse(o => { o.layers.enable(r.layer); });\n        group.layers.enable(r.layer);\n\n        // Floor\n        const floorGeo = new THREE.PlaneGeometry(r.w, r.h);\n        ensureUv2(floorGeo);\n        const floorMat = Mats.floor();\n        floorMat.lightMap = bakedLightMap;\n        floorMat.lightMapIntensity = 0.9;\n        const floor = new THREE.Mesh(floorGeo, floorMat);\n        floor.rotation.x = -Math.PI / 2;\n        floor.position.set(r.cx, 0, r.cz);\n        floor.receiveShadow = false;\n        group.add(floor);\n\n        // Ceiling\n        const ceilGeo = new THREE.PlaneGeometry(r.w, r.h);\n        ensureUv2(ceilGeo);\n        const ceilMat = Mats.ceiling();\n        ceilMat.lightMap = bakedLightMap;\n        ceilMat.lightMapIntensity = 0.6;\n        const ceiling = new THREE.Mesh(ceilGeo, ceilMat);\n        ceiling.rotation.x = Math.PI / 2;\n        ceiling.position.set(r.cx, params.wallHeight, r.cz);\n        group.add(ceiling);\n\n        // Walls with door gaps\n        const T = params.wallThickness;\n        const H = params.wallHeight;\n        const DW = params.doorWidth;\n        const DH = params.doorHeight;\n\n        // Helper: make wall segments for one side\n        const doorsBySide = new Map();\n        for (const d of r.doors) {\n          const key = d.side;\n          if (!doorsBySide.has(key)) doorsBySide.set(key, []);\n          doorsBySide.get(key).push(d);\n        }\n\n        function addWallSide(side) {\n          let length = (side === 'N' || side === 'S') ? r.w : r.h;\n          let along = length;\n          let segments = [];\n\n          const doorList = (doorsBySide.get(side) || []);\n          if (doorList.length === 0) {\n            // full wall\n            segments.push({ offset: 0, len: length, hasDoor: false });\n          } else {\n            // Only support one door per side for simplicity\n            const d = doorList[0];\n            const centerAlong = (side === 'N' || side === 'S') ? (d.x - (r.cx - r.w/2)) : (d.z - (r.cz - r.h/2));\n            const leftLen = Math.max(0, centerAlong - DW/2);\n            const rightLen = Math.max(0, length - (centerAlong + DW/2));\n            if (leftLen > 0) segments.push({ offset: 0, len: leftLen, hasDoor: false });\n            if (rightLen > 0) segments.push({ offset: centerAlong + DW/2, len: rightLen, hasDoor: false });\n            // header above door\n            segments.push({ offset: centerAlong - DW/2, len: DW, hasDoor: true });\n          }\n\n          for (const seg of segments) {\n            if (!seg.hasDoor) {\n              const wallGeo = new THREE.BoxGeometry(seg.len, H, T);\n              ensureUv2(wallGeo);\n              const wallMat = Mats.wall();\n              wallMat.lightMap = bakedLightMap;\n              wallMat.lightMapIntensity = 0.7;\n\n              const wall = new THREE.Mesh(wallGeo, wallMat);\n              wall.castShadow = false;\n              wall.receiveShadow = false;\n\n              // position\n              let x = r.cx, y = H / 2, z = r.cz;\n              if (side === 'N') {\n                x = (r.cx - r.w/2) + (seg.offset + seg.len/2);\n                z = r.z1 + T/2;\n              } else if (side === 'S') {\n                x = (r.cx - r.w/2) + (seg.offset + seg.len/2);\n                z = r.z0 - T/2;\n              } else if (side === 'E') {\n                const wallRot = new THREE.Matrix4().makeRotationY(Math.PI / 2);\n                wall.geometry.applyMatrix4(wallRot);\n                x = r.x1 + T/2;\n                z = (r.cz - r.h/2) + (seg.offset + seg.len/2);\n              } else if (side === 'W') {\n                const wallRot = new THREE.Matrix4().makeRotationY(Math.PI / 2);\n                wall.geometry.applyMatrix4(wallRot);\n                x = r.x0 - T/2;\n                z = (r.cz - r.h/2) + (seg.offset + seg.len/2);\n              }\n              wall.position.set(x, y, z);\n              group.add(wall);\n\n              // Collider\n              const col = wall.clone();\n              col.material = null;\n              col.visible = false;\n              scene.add(col);\n              world.colliders.push(col);\n            } else {\n              // header above door\n              const headerGeo = new THREE.BoxGeometry(seg.len, H - DH, T);\n              ensureUv2(headerGeo);\n              const headerMat = Mats.wall();\n              headerMat.lightMap = bakedLightMap;\n              headerMat.lightMapIntensity = 0.7;\n\n              const header = new THREE.Mesh(headerGeo, headerMat);\n              let x = r.cx, y = DH + (H - DH)/2, z = r.cz;\n              if (side === 'N') {\n                x = (r.cx - r.w/2) + (seg.offset + seg.len/2);\n                z = r.z1 + T/2;\n              } else if (side === 'S') {\n                x = (r.cx - r.w/2) + (seg.offset + seg.len/2);\n                z = r.z0 - T/2;\n              } else if (side === 'E') {\n                const rot = new THREE.Matrix4().makeRotationY(Math.PI / 2);\n                header.geometry.applyMatrix4(rot);\n                x = r.x1 + T/2;\n                z = (r.cz - r.h/2) + (seg.offset + seg.len/2);\n              } else if (side === 'W') {\n                const rot = new THREE.Matrix4().makeRotationY(Math.PI / 2);\n                header.geometry.applyMatrix4(rot);\n                x = r.x0 - T/2;\n                z = (r.cz - r.h/2) + (seg.offset + seg.len/2);\n              }\n              header.position.set(x, y, z);\n              group.add(header);\n\n              // Collider for header\n              const col = header.clone();\n              col.material = null;\n              col.visible = false;\n              scene.add(col);\n              world.colliders.push(col);\n\n              // Door frame visuals (thin)\n              const frameMat = Mats.woodDark();\n              const frameThickness = 0.06;\n              const frameDepth = T + 0.02;\n              const stilesGeo = new THREE.BoxGeometry(frameThickness, DH, frameDepth);\n              const headerGeo2 = new THREE.BoxGeometry(seg.len, frameThickness, frameDepth);\n\n              const frames = [];\n\n              if (side === 'N' || side === 'S') {\n                const sign = side === 'N' ? 1 : -1;\n                const zf = (side === 'N') ? (r.z1 + frameDepth/2) : (r.z0 - frameDepth/2);\n\n                const sx = (r.cx - r.w/2) + (seg.offset);\n                const ex = (r.cx - r.w/2) + (seg.offset + seg.len);\n\n                const left = new THREE.Mesh(stilesGeo, frameMat);\n                left.position.set(sx + frameThickness/2, DH/2, zf);\n                const right = new THREE.Mesh(stilesGeo, frameMat);\n                right.position.set(ex - frameThickness/2, DH/2, zf);\n\n                const head = new THREE.Mesh(headerGeo2, frameMat);\n                head.position.set((sx + ex)/2, DH + frameThickness/2, zf);\n\n                frames.push(left, right, head);\n              } else {\n                const xf = (side === 'E') ? (r.x1 + frameDepth/2) : (r.x0 - frameDepth/2);\n\n                const sz = (r.cz - r.h/2) + (seg.offset);\n                const ez = (r.cz - r.h/2) + (seg.offset + seg.len);\n\n                const stilesGeoRot = stilesGeo.clone();\n                stilesGeoRot.rotateY(Math.PI/2);\n                const headerGeoRot = headerGeo2.clone();\n                headerGeoRot.rotateY(Math.PI/2);\n\n                const left = new THREE.Mesh(stilesGeoRot, frameMat);\n                left.position.set(xf, DH/2, sz + frameThickness/2);\n                const right = new THREE.Mesh(stilesGeoRot, frameMat);\n                right.position.set(xf, DH/2, ez - frameThickness/2);\n\n                const head = new THREE.Mesh(headerGeoRot, frameMat);\n                head.position.set(xf, DH + frameThickness/2, (sz + ez)/2);\n\n                frames.push(left, right, head);\n              }\n\n              for (const f of frames) {\n                group.add(f);\n              }\n            }\n          }\n        }\n\n        addWallSide('N');\n        addWallSide('S');\n        addWallSide('E');\n        addWallSide('W');\n\n        // Light probe per room (for demo, reuse same SH from env by cloning)\n        // Create a dummy probe, copy coefficients\n        const roomProbe = new THREE.LightProbe();\n        // copy coefficients from global light probe if exists\n        for (const obj of scene.children) {\n          if (obj.isLightProbe) {\n            roomProbe.sh.copy(obj.sh);\n            break;\n          }\n        }\n        roomProbe.intensity = 1.0;\n        roomProbe.position.set(r.cx, H * 0.7, r.cz);\n        scene.add(roomProbe);\n\n        const helper = new LightProbeHelper(roomProbe, 0.3);\n        helper.visible = params.showProbeHelpers;\n        helper.layers.enable(r.layer);\n        scene.add(helper);\n        world.probeHelpers.push(helper);\n\n        // Layer tagging for all room contents\n        group.traverse(obj => {\n          obj.layers.disableAll();\n          obj.layers.enable(r.layer);\n        });\n      }\n\n      world.rooms = rooms;\n\n      // Build adjacency layer links map\n      for (const r of rooms) {\n        const set = new Set([r.layer]);\n        for (const n of r.neighbors) set.add(world.rooms[n].layer);\n        world.doorLayerLinks.set(r.index, set);\n      }\n    }\n\n    function addFurnitureAndHotspots() {\n      // Each room gets a furniture set and a hotspot to toggle something\n      for (const r of world.rooms) {\n        const items = [];\n\n        // Choose type by name\n        if (/living/i.test(r.name)) {\n          items.push(createSofa(r.cx - r.w*0.2, r.cz, r.layer));\n          items.push(createCoffeeTable(r.cx + r.w*0.05, r.cz, r.layer));\n          const spot = createHotspot(r.cx, 0.0, r.cz - r.h*0.25, r.layer, 'Toggle Sofa', () => {\n            items[0].visible = !items[0].visible;\n          });\n          world.hotspots.push(spot);\n        } else if (/kitchen/i.test(r.name)) {\n          items.push(createKitchenBlock(r.cx - r.w*0.25, r.cz + r.h*0.2, r.layer));\n          items.push(createDiningTable(r.cx + r.w*0.15, r.cz, r.layer));\n          const spot = createHotspot(r.cx, 0.0, r.cz - r.h*0.2, r.layer, 'Countertop: wood/marble', () => {\n            toggleKitchenCountertop(items[0]);\n          });\n          world.hotspots.push(spot);\n        } else if (/bed/i.test(r.name)) {\n          items.push(createBed(r.cx, r.cz, r.layer));\n          const spot = createHotspot(r.cx, 0.0, r.cz + r.h*0.2, r.layer, 'Swap Bedspread', () => {\n            swapBedspread(items[0]);\n          });\n          world.hotspots.push(spot);\n        } else {\n          // Office/Hall/Other\n          items.push(createCabinet(r.cx - r.w*0.25, r.cz - r.h*0.2, r.layer));\n          items.push(createChair(r.cx + r.w*0.1, r.cz, r.layer));\n          const spot = createHotspot(r.cx, 0.0, r.cz + r.h*0.25, r.layer, 'Toggle Chair', () => {\n            items[1].visible = !items[1].visible;\n          });\n          world.hotspots.push(spot);\n        }\n\n        // Make floors togglable: add a hotspot to cycle floor materials\n        const floorSpot = createHotspot(r.cx + r.w*0.3 - 0.2, 0, r.cz + r.h*0.3 - 0.2, r.layer, 'Cycle Floor Material', () => {\n          const floors = [];\n          r.group.traverse(o => { if (o.isMesh && o.geometry.type === 'PlaneGeometry' && Math.abs(o.rotation.x + Math.PI/2) < 1e-3) floors.push(o); });\n          for (const f of floors) {\n            cycleFloorMaterial(f);\n          }\n        });\n        world.hotspots.push(floorSpot);\n      }\n    }\n\n    // Furniture\n    function createSofa(x, z, layer) {\n      const g = new THREE.Group();\n      const base = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.35, 0.7), Mats.fabric(0x51647a, 0.8));\n      base.position.set(0, 0.18, 0);\n      const back = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.6, 0.2), Mats.fabric(0x51647a, 0.85));\n      back.position.set(0, 0.55, -0.25);\n      const armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.45, 0.7), Mats.fabric(0x445363, 0.85));\n      armL.position.set(-0.8, 0.36, 0);\n      const armR = armL.clone();\n      armR.position.x = 0.8;\n      g.add(base, back, armL, armR);\n      g.position.set(x, 0, z);\n      g.traverse(o => { if (o.isMesh) { o.castShadow = false; } });\n      g.layers.disableAll(); g.layers.enable(layer);\n      scene.add(g);\n      return g;\n    }\n\n    function createCoffeeTable(x,z,layer) {\n      const g = new THREE.Group();\n      const top = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.06, 0.5), Mats.woodMid());\n      top.position.y = 0.35;\n      const legGeo = new THREE.BoxGeometry(0.06, 0.35, 0.06);\n      const legMat = Mats.woodDark();\n      const l1 = new THREE.Mesh(legGeo, legMat); l1.position.set(0.4, 0.175, 0.22);\n      const l2 = l1.clone(); l2.position.x = -0.4;\n      const l3 = l1.clone(); l3.position.z = -0.22;\n      const l4 = l2.clone(); l4.position.z = -0.22;\n      g.add(top,l1,l2,l3,l4);\n      g.position.set(x,0,z);\n      g.layers.disableAll(); g.layers.enable(layer);\n      scene.add(g);\n      return g;\n    }\n\n    function createDiningTable(x, z, layer) {\n      const g = new THREE.Group();\n      const top = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.05, 24), Mats.woodMid());\n      top.position.y = 0.78;\n      const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 0.75, 16), Mats.metalDark());\n      leg.position.y = 0.38;\n      g.add(top, leg);\n      // add some chairs\n      for (let i = 0; i < 3; i++) {\n        const c = createChair(0,0,layer,true);\n        const ang = i * (Math.PI*2/3);\n        c.position.set(Math.cos(ang)*0.9, 0, Math.sin(ang)*0.9);\n        c.rotation.y = -ang + Math.PI;\n        g.add(c);\n      }\n      g.position.set(x, 0, z);\n      g.layers.disableAll(); g.layers.enable(layer);\n      scene.add(g);\n      return g;\n    }\n\n    function createChair(x, z, layer, standalone=false) {\n      const g = new THREE.Group();\n      const seat = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.06, 0.45), Mats.fabric(0x6a5f56, 0.7));\n      seat.position.y = 0.45;\n      const back = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.45, 0.05), Mats.woodDark());\n      back.position.set(0, 0.675, -0.2);\n      const legGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.45, 10);\n      const legMat = Mats.metalDark();\n      const l1 = new THREE.Mesh(legGeo, legMat); l1.position.set( 0.18, 0.225,  0.18);\n      const l2 = new THREE.Mesh(legGeo, legMat); l2.position.set(-0.18, 0.225,  0.18);\n      const l3 = new THREE.Mesh(legGeo, legMat); l3.position.set( 0.18, 0.225, -0.18);\n      const l4 = new THREE.Mesh(legGeo, legMat); l4.position.set(-0.18, 0.225, -0.18);\n      g.add(seat, back, l1, l2, l3, l4);\n      if (standalone) return g;\n      g.position.set(x, 0, z);\n      g.layers.disableAll(); g.layers.enable(layer);\n      scene.add(g);\n      return g;\n    }\n\n    function createBed(x, z, layer) {\n      const g = new THREE.Group();\n      const frame = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.25, 1.4), Mats.woodDark());\n      frame.position.y = 0.125;\n      const mattress = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.16, 1.3), Mats.fabric(0xe5e3df, 0.3));\n      mattress.position.set(0, 0.33, 0);\n      mattress.name = 'mattress';\n      const blanket = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.04, 1.3), Mats.fabric(0x6a86ad, 0.85));\n      blanket.position.set(0, 0.41, 0);\n      blanket.name = 'blanket';\n      const headboard = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.7, 0.07), Mats.woodMid());\n      headboard.position.set(0, 0.6, -0.7/2);\n      g.add(frame, mattress, blanket, headboard);\n      g.position.set(x, 0, z);\n      g.layers.disableAll(); g.layers.enable(layer);\n      scene.add(g);\n      return g;\n    }\n\n    function swapBedspread(bedGroup) {\n      const blanket = bedGroup.getObjectByName('blanket');\n      if (blanket) {\n        const current = blanket.material.color.getHex();\n        const colors = [0x6a86ad, 0xb86c5c, 0x5ea67a, 0xbbb3a8];\n        const idx = (colors.indexOf(current) + 1) % colors.length;\n        blanket.material = Mats.fabric(colors[idx], 0.85);\n      }\n    }\n\n    function createKitchenBlock(x, z, layer) {\n      const g = new THREE.Group();\n      // cabinets\n      const base = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.8, 0.6), Mats.woodMid());\n      base.position.set(0, 0.4, 0);\n      base.name = 'cabinet';\n      // countertop\n      const top = new THREE.Mesh(new THREE.BoxGeometry(1.62, 0.05, 0.62), Mats.marble());\n      top.position.set(0, 0.825, 0);\n      top.name = 'countertop';\n      g.add(base, top);\n      g.position.set(x, 0, z);\n      g.layers.disableAll(); g.layers.enable(layer);\n      scene.add(g);\n      return g;\n    }\n\n    function toggleKitchenCountertop(kitchenGroup) {\n      const top = kitchenGroup.getObjectByName('countertop');\n      if (!top) return;\n      const marbleish = (top.material.userData.kind !== 'wood');\n      top.material = marbleish ? Mats.woodDark() : Mats.marble();\n      top.material.userData.kind = marbleish ? 'wood' : 'marble';\n    }\n\n    function createCabinet(x, z, layer) {\n      const g = new THREE.Group();\n      const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.1, 0.35), Mats.woodMid());\n      body.position.y = 0.55;\n      const doors = new THREE.Mesh(new THREE.BoxGeometry(0.88, 1.08, 0.02), Mats.paint(0xeae6de, 0.2));\n      doors.position.set(0, 0.55, 0.185);\n      g.add(body, doors);\n      g.position.set(x, 0, z);\n      g.layers.disableAll(); g.layers.enable(layer);\n      scene.add(g);\n      return g;\n    }\n\n    function createHotspot(x, y, z, layer, text, action) {\n      const s = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), new THREE.MeshStandardMaterial({\n        color: 0x2ba8ff, emissive: 0x0b3e66, emissiveIntensity: 1.2, metalness: 0.0, roughness: 0.2\n      }));\n      s.position.set(x, Math.max(0.08, y) + 0.08, z);\n      s.userData = { isHotspot: true, action, text, layer };\n      s.layers.disableAll(); s.layers.enable(layer);\n      scene.add(s);\n      return s;\n    }\n\n    function cycleFloorMaterial(floorMesh) {\n      const key = floorMesh.userData.floorIndex = (floorMesh.userData.floorIndex || 0) + 1;\n      const i = key % 3;\n      if (i === 0) floorMesh.material = Mats.floor();\n      else if (i === 1) floorMesh.material = Mats.floorWood();\n      else floorMesh.material = Mats.floorCarpet();\n      floorMesh.material.lightMap = bakedLightMap;\n      floorMesh.material.lightMapIntensity = 0.9;\n    }\n\n    // Minimap\n    function finalizeMinimap(rooms) {\n      // Compute orthographic extents with padding\n      const ext = world.extents.clone();\n      const pad = 2.0;\n      const w = (ext.max.x - ext.min.x) + pad * 2;\n      const h = (ext.max.y - ext.min.y) + pad * 2;\n      minimapCamera.left = -w/2; minimapCamera.right = w/2;\n      minimapCamera.bottom = -h/2; minimapCamera.top = h/2;\n      minimapCamera.updateProjectionMatrix();\n      const cx = (ext.min.x + ext.max.x)/2;\n      const cz = (ext.min.y + ext.max.y)/2;\n      minimapCamera.position.set(cx, 50, cz);\n      minimapCamera.lookAt(cx, 0, cz);\n      minimapCamera.layers.enableAll(); // render all rooms\n      minimapCamera.layers.enable(LAYER_MINIMAP_ONLY);\n      camera.layers.disable(LAYER_MINIMAP_ONLY);\n    }\n\n    // Interactions\n    function tryInteract() {\n      // Raycast from camera forward to hotspot within 3m\n      const dir = new THREE.Vector3();\n      camera.getWorldDirection(dir);\n      const ray = new THREE.Raycaster(camera.position, dir, 0.01, 3.0);\n      // enable layers of current room and neighbors already active on camera\n      const intersects = ray.intersectObjects(world.hotspots, false);\n      if (intersects.length) {\n        const obj = intersects[0].object;\n        if (obj.userData && obj.userData.isHotspot) {\n          obj.userData.action?.();\n        }\n      }\n    }\n\n    // Update current room layers\n    function updateCurrentRoom() {\n      const pos = controls.getObject().position;\n      let idx = -1;\n      for (const r of world.rooms) {\n        if (pos.x >= r.x0 && pos.x <= r.x1 && pos.z >= r.z0 && pos.z <= r.z1) {\n          idx = r.index; break;\n        }\n      }\n      if (idx === -1) return;\n\n      if (idx !== world.currentRoomIndex) {\n        world.currentRoomIndex = idx;\n        // Enable layers for current and adjacent rooms on main camera\n        camera.layers.disableAll();\n        const set = world.doorLayerLinks.get(idx);\n        set.forEach(layer => camera.layers.enable(layer));\n        // Do not show minimap-only arrow in main camera\n        camera.layers.disable(LAYER_MINIMAP_ONLY);\n      }\n    }\n\n    // Collision detection\n    function applyCollisions(from, to) {\n      // Simple axis separation: try X then Z\n      const radius = params.radius;\n      const tryPos = from.clone();\n\n      // Move X\n      tryPos.x = to.x;\n      if (collides(tryPos, radius)) {\n        to.x = from.x;\n      }\n\n      // Move Z\n      tryPos.x = to.x;\n      tryPos.z = to.z;\n      if (collides(tryPos, radius)) {\n        to.z = from.z;\n      }\n\n      // Y not used for navigation (optional jump)\n      return to;\n    }\n\n    function collides(p, radius) {\n      // Test against each collider's AABB\n      const tmpBox = new THREE.Box3();\n      for (const c of world.colliders) {\n        tmpBox.setFromObject(c);\n        // expand by radius (in XZ)\n        tmpBox.min.x -= radius; tmpBox.max.x += radius;\n        tmpBox.min.z -= radius; tmpBox.max.z += radius;\n        tmpBox.min.y = -Infinity; tmpBox.max.y = Infinity;\n        if (tmpBox.containsPoint(p)) return true;\n      }\n      return false;\n    }\n\n    // Movement handling\n    document.addEventListener('keydown', (e) => {\n      switch (e.code) {\n        case 'KeyW': move.forward = true; break;\n        case 'KeyS': move.backward = true; break;\n        case 'KeyA': move.left = true; break;\n        case 'KeyD': move.right = true; break;\n        case 'ShiftLeft':\n        case 'ShiftRight': move.running = true; break;\n        case 'Space':\n          if (move.canJump) { move.velocityY = params.jump; move.canJump = false; }\n          break;\n        case 'KeyE': tryInteract(); break;\n        case 'KeyH':\n          params.showProbeHelpers = !params.showProbeHelpers;\n          for (const h of world.probeHelpers) h.visible = params.showProbeHelpers;\n          break;\n        case 'KeyV':\n          params.showMinimap = !params.showMinimap;\n          minimapFrame.style.display = params.showMinimap ? '' : 'none';\n          minimapTitle.style.display = params.showMinimap ? '' : 'none';\n          break;\n        case 'KeyL':\n          params.showLabel = !params.showLabel;\n          label.style.display = params.showLabel ? '' : 'none';\n          break;\n      }\n    });\n    document.addEventListener('keyup', (e) => {\n      switch (e.code) {\n        case 'KeyW': move.forward = false; break;\n        case 'KeyS': move.backward = false; break;\n        case 'KeyA': move.left = false; break;\n        case 'KeyD': move.right = false; break;\n        case 'ShiftLeft':\n        case 'ShiftRight': move.running = false; break;\n      }\n    });\n\n    // Hover label update\n    function updateHotspotLabel() {\n      if (!params.showLabel) { label.style.opacity = 0; return; }\n      const dir = new THREE.Vector3();\n      camera.getWorldDirection(dir);\n      const ray = new THREE.Raycaster(camera.position, dir, 0.01, 3.0);\n      const intersects = ray.intersectObjects(world.hotspots, false);\n      if (intersects.length) {\n        const hs = intersects[0].object;\n        label.textContent = `Hotspot: ${hs.userData.text} (E)`;\n        label.style.opacity = 1;\n      } else {\n        label.style.opacity = 0;\n      }\n    }\n\n    // Animate loop\n    function animate() {\n      requestAnimationFrame(animate);\n      const dt = Math.min(0.045, clock.getDelta());\n\n      // Movement\n      if (controls.isLocked) {\n        const speed = move.running ? params.sprint : params.speed;\n        const vel = new THREE.Vector3();\n        const forward = new THREE.Vector3();\n        camera.getWorldDirection(forward);\n        forward.y = 0; forward.normalize();\n        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();\n\n        if (move.forward) vel.add(forward);\n        if (move.backward) vel.sub(forward);\n        if (move.left) vel.sub(right);\n        if (move.right) vel.add(right);\n\n        if (vel.lengthSq() > 0) vel.normalize().multiplyScalar(speed * dt);\n\n        // Gravity and jump (optional)\n        move.velocityY -= params.gravity * dt;\n        const pos = controls.getObject().position.clone();\n        let next = pos.clone().add(vel);\n        next.y += move.velocityY * dt;\n\n        // floor\n        if (next.y <= params.playerHeight) {\n          next.y = params.playerHeight;\n          move.velocityY = 0;\n          move.canJump = true;\n        }\n\n        // Collisions\n        next = applyCollisions(pos, next);\n\n        controls.getObject().position.copy(next);\n        updateCurrentRoom();\n      }\n\n      updateHotspotLabel();\n\n      // Update player arrow for minimap\n      arrow.position.set(camera.position.x, params.wallHeight + 0.02, camera.position.z);\n      // yaw from camera quaternion\n      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');\n      arrow.rotation.z = -euler.y; // rotate in minimap plane\n\n      render();\n    }\n\n    // Render both main view and minimap\n    function render() {\n      const w = renderer.domElement.clientWidth;\n      const h = renderer.domElement.clientHeight;\n\n      // Main view\n      renderer.setViewport(0, 0, w, h);\n      renderer.setScissor(0, 0, w, h);\n      renderer.setClearColor(0x0b0e11, 1);\n      renderer.render(scene, camera);\n\n      // Minimap view\n      if (params.showMinimap) {\n        const frame = minimapFrame.getBoundingClientRect();\n        const x = Math.floor(frame.left);\n        const y = Math.floor(window.innerHeight - frame.bottom);\n        const mw = Math.floor(frame.width);\n        const mh = Math.floor(frame.height);\n\n        renderer.setViewport(x, y, mw, mh);\n        renderer.setScissor(x, y, mw, mh);\n        renderer.setClearColor(0x0a0c10, 1);\n        renderer.render(scene, minimapCamera);\n      }\n    }\n\n    // Utils\n    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n    function randRange(a, b) { return a + (b - a) * rng(); }\n    function mulberry32(a) {\n      return function() {\n        let t = a += 0x6D2B79F5;\n        t = Math.imul(t ^ t >>> 15, t | 1);\n        t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n        return ((t ^ t >>> 14) >>> 0) / 4294967296;\n      }\n    }\n    function getSeedFromURL() {\n      const m = /[?&]seed=([0-9]+)/.exec(location.search);\n      return m ? parseInt(m[1]) : null;\n    }\n\n    function ensureUv2(geo) {\n      if (!geo.attributes.uv) return;\n      geo.setAttribute('uv2', new THREE.BufferAttribute(geo.attributes.uv.array, 2));\n    }\n\n    function generateRadialLightMap(size=256) {\n      const c = document.createElement('canvas');\n      c.width = c.height = size;\n      const ctx = c.getContext('2d');\n      const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);\n      g.addColorStop(0.0, '#ffffff');\n      g.addColorStop(0.5, '#dddddd');\n      g.addColorStop(1.0, '#9aa0a8');\n      ctx.fillStyle = g;\n      ctx.fillRect(0,0,size,size);\n      const tex = new THREE.CanvasTexture(c);\n      tex.colorSpace = THREE.SRGBColorSpace;\n      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n      tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 8;\n      return tex;\n    }\n\n    function materialFactory() {\n      return {\n        wall: () => new THREE.MeshStandardMaterial({ color: 0xdeddd9, roughness: 0.9, metalness: 0.0 }),\n        ceiling: () => new THREE.MeshStandardMaterial({ color: 0xf3f3f0, roughness: 0.95, metalness: 0.0 }),\n        floor: () => new THREE.MeshStandardMaterial({ color: 0xcfc7bb, roughness: 0.8, metalness: 0.0 }),\n        floorWood: () => {\n          const mat = new THREE.MeshStandardMaterial({ color: 0x7d5a36, roughness: 0.6, metalness: 0.02 });\n          return mat;\n        },\n        floorCarpet: () => new THREE.MeshStandardMaterial({ color: 0x57606a, roughness: 1.0, metalness: 0.0 }),\n        woodMid: () => new THREE.MeshStandardMaterial({ color: 0x9a7b58, roughness: 0.65, metalness: 0.05 }),\n        woodDark: () => new THREE.MeshStandardMaterial({ color: 0x5c4a34, roughness: 0.7, metalness: 0.03 }),\n        fabric: (hex, rough=0.9) => new THREE.MeshStandardMaterial({ color: hex, roughness: rough, metalness: 0.0 }),\n        metalDark: () => new THREE.MeshStandardMaterial({ color: 0x3a3a40, roughness: 0.4, metalness: 0.8 }),\n        paint: (hex, rough=0.9) => new THREE.MeshStandardMaterial({ color: hex, roughness: rough, metalness: 0 }),\n        marble: () => {\n          // simple procedural marble-like material using color only\n          const m = new THREE.MeshStandardMaterial({ color: 0xe7e4de, roughness: 0.4, metalness: 0.0 });\n          m.userData.kind = 'marble';\n          return m;\n        }\n      };\n    }\n\n    // Responsive\n    window.addEventListener('resize', () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n  </script>\n</body>\n</html>",
    "model": "openai/gpt-5-2025-08-07",
    "agent_name": "BenchAgent",
    "execution_time": 225.03079509735107,
    "status": "success",
    "timestamp": "2025-08-29 18:07:07"
  }
]