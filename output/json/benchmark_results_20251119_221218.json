[
  {
    "test_name": "rotating_cube_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays a rotating 3D cube. The cube should have different colored faces, rotate continuously, and include proper lighting. The HTML file should be self-contained with Three.js loaded from CDN. Include camera controls for user interaction. Save the output as 'rotating_cube.html'.",
    "response": "```html\n<!-- Save this file as: rotating_cube.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Rotating 3D Cube - Three.js</title>\n  <style>\n    body {\n      margin: 0;\n      overflow: hidden;\n      background-color: #000000;\n      font-family: Arial, sans-serif;\n    }\n    #info {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      color: #ffffff;\n      z-index: 1;\n      font-size: 14px;\n      background: rgba(0, 0, 0, 0.5);\n      padding: 8px 12px;\n      border-radius: 4px;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"info\">\n    Rotating 3D Cube (Three.js)<br />\n    - Drag to orbit<br />\n    - Scroll to zoom<br />\n    - Right-click / middle-drag to pan\n  </div>\n\n  <!-- Three.js and OrbitControls from CDN (module version) -->\n  <script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';\n    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';\n\n    // Scene\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x000000);\n\n    // Camera\n    const camera = new THREE.PerspectiveCamera(\n      60, window.innerWidth / window.innerHeight, 0.1, 1000\n    );\n    camera.position.set(3, 3, 5);\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    document.body.appendChild(renderer.domElement);\n\n    // Lights\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\n    scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(5, 10, 7.5);\n    scene.add(directionalLight);\n\n    // Cube with different colored faces\n    const geometry = new THREE.BoxGeometry(2, 2, 2);\n\n    const materials = [\n      new THREE.MeshStandardMaterial({ color: 0xff0000 }), // right\n      new THREE.MeshStandardMaterial({ color: 0x00ff00 }), // left\n      new THREE.MeshStandardMaterial({ color: 0x0000ff }), // top\n      new THREE.MeshStandardMaterial({ color: 0xffff00 }), // bottom\n      new THREE.MeshStandardMaterial({ color: 0xff00ff }), // front\n      new THREE.MeshStandardMaterial({ color: 0x00ffff })  // back\n    ];\n\n    const cube = new THREE.Mesh(geometry, materials);\n    scene.add(cube);\n\n    // OrbitControls\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.06;\n    controls.enablePan = true;\n    controls.minDistance = 3;\n    controls.maxDistance = 20;\n\n    // Handle resizing\n    window.addEventListener('resize', onWindowResize, false);\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    // Animation loop\n    function animate() {\n      requestAnimationFrame(animate);\n\n      // Continuous rotation\n      cube.rotation.x += 0.01;\n      cube.rotation.y += 0.015;\n\n      controls.update();\n      renderer.render(scene, camera);\n    }\n\n    animate();\n  </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 5.182125091552734,
    "status": "success",
    "timestamp": "2025-11-19 22:03:52",
    "evaluation": {
      "test_name": "rotating_cube_simulation",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
        ],
        "warnings": [],
        "screenshot": "output/screenshots/rotating_cube_simulation.png",
        "render_time_ms": 738.84,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 738.84ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
            ]
          }
        ]
      },
      "quality": {
        "quality_score": 80,
        "raw_score": 2,
        "reasoning": "1. The code includes an HTML document with a Three.js setup, addressing the request. 2. It imports Three.js and OrbitControls from a CDN, which is modern and appropriate. 3. A 3D scene is created with a rotating cube and lighting, fulfilling core requirements. 4. The code provides camera controls for user interaction, addressing that requirement. 5. A limitation is the incomplete implementation of the cube materials, cutting off abruptly partway through specifying colors for different faces. 6. The resize event listener and continuous rotation features appear to be missing or incomplete.",
        "strengths": "Fulfills most request requirements. Uses modern ES6 features, and imports Three.js and controls from a CDN. Includes lighting and camera controls setup effectively.",
        "weaknesses": "Incomplete cube material definition, affecting the visual specification of the cube. Missing resize handling and continuous rotation implementation in the provided portion.",
        "confidence": "high"
      },
      "overall_score": 83,
      "passed": true
    }
  },
  {
    "test_name": "particle_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays an animated particle system. The particles should move in interesting patterns (like a fountain, explosion, or flowing stream), change colors over time, and respond to mouse movement. Include at least 1000 particles with realistic physics. The HTML should be self-contained with Three.js from CDN. Save the output as 'particle_system.html'.",
    "response": "```html\n<!-- Save this file as: particle_system.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Three.js Particle Fountain</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      background: radial-gradient(circle at center, #050505 0%, #000000 50%, #02020a 100%);\n      height: 100%;\n      width: 100%;\n      font-family: sans-serif;\n      color: #ddd;\n    }\n    #info {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      z-index: 10;\n      background: rgba(0, 0, 0, 0.5);\n      padding: 8px 12px;\n      border-radius: 4px;\n      font-size: 12px;\n    }\n    #info a {\n      color: #7ad7ff;\n      text-decoration: none;\n    }\n  </style>\n</head>\n<body>\n<div id=\"info\">\n  Particle Fountain \u2022 Move your mouse to steer the flow \u2022 Scroll to zoom\n</div>\n\n<!-- Three.js from CDN -->\n<script src=\"https://unpkg.com/three@0.157.0/build/three.min.js\"></script>\n<script src=\"https://unpkg.com/three@0.157.0/examples/js/controls/OrbitControls.js\"></script>\n\n<script>\n(function () {\n  // Basic setup\n  const scene = new THREE.Scene();\n  scene.fog = new THREE.FogExp2(0x000000, 0.035);\n\n  const camera = new THREE.PerspectiveCamera(\n    60,\n    window.innerWidth / window.innerHeight,\n    0.1,\n    1000\n  );\n  camera.position.set(0, 12, 35);\n\n  const renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setPixelRatio(window.devicePixelRatio || 1);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setClearColor(0x000000, 1);\n  document.body.appendChild(renderer.domElement);\n\n  // Optional controls (orbit to inspect)\n  const controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.08;\n  controls.enablePan = false;\n  controls.minDistance = 10;\n  controls.maxDistance = 90;\n  controls.maxPolarAngle = Math.PI * 0.49;\n\n  // Lighting (subtle)\n  const ambient = new THREE.AmbientLight(0xffffff, 0.2);\n  scene.add(ambient);\n  const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);\n  dirLight.position.set(10, 20, 10);\n  scene.add(dirLight);\n\n  // Ground plane for context\n  const groundGeo = new THREE.PlaneGeometry(200, 200, 1, 1);\n  const groundMat = new THREE.MeshPhongMaterial({\n    color: 0x050509,\n    shininess: 10,\n    side: THREE.DoubleSide\n  });\n  const ground = new THREE.Mesh(groundGeo, groundMat);\n  ground.rotation.x = -Math.PI / 2;\n  ground.position.y = 0;\n  scene.add(ground);\n\n  // Particle system parameters\n  const PARTICLE_COUNT = 2000;          // >= 1000 as requested\n  const EMITTER_RADIUS = 1.0;\n  const EMITTER_HEIGHT = 0.2;\n  const MAX_LIFETIME = 8.0;            // seconds\n  const GRAVITY = new THREE.Vector3(0, -9.81 * 0.6, 0);\n  const DRAG = 0.12;                   // air resistance\n  const NOISE_STRENGTH = 0.9;          // per-frame curl-like noise\n  const MOUSE_FORCE = 14.0;            // how strongly mouse affects direction\n  const BASE_UP_VELOCITY = 12.0;       // fountain speed\n  const SPREAD = 4.0;                  // horizontal velocity spread\n  const RESET_Y = -1.0;                // y threshold for respawn\n\n  // Mouse tracking (normalized device coordinates)\n  const mouse = new THREE.Vector2(0, 0);\n  const targetMouse3D = new THREE.Vector3();\n  const mouse3D = new THREE.Vector3();\n\n  window.addEventListener('mousemove', (event) => {\n    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n  });\n\n  // Raycasting plane for mouse interaction\n  const mousePlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // y = 0 plane\n  const raycaster = new THREE.Raycaster();\n\n  function updateMouse3D() {\n    raycaster.setFromCamera(mouse, camera);\n    const intersectionPoint = new THREE.Vector3();\n    raycaster.ray.intersectPlane(mousePlane, intersectionPoint);\n    targetMouse3D.copy(intersectionPoint);\n  }\n\n  // GPU-side geometry buffers\n  const geometry = new THREE.BufferGeometry();\n  const positions = new Float32Array(PARTICLE_COUNT * 3);\n  const velocities = new Float32Array(PARTICLE_COUNT * 3); // stored on CPU conceptually; we just reuse buffer\n  const lifetimes = new Float32Array(PARTICLE_COUNT);\n  const startTimes = new Float32Array(PARTICLE_COUNT);\n  const sizes = new Float32Array(PARTICLE_COUNT);\n\n  // Utility: random in range\n  function randRange(min, max) {\n    return min + Math.random() * (max - min);\n  }\n\n  // Initialize particle i\n  function resetParticle(i, t) {\n    const r = EMITTER_RADIUS * Math.sqrt(Math.random());\n    const theta = Math.random() * Math.PI * 2;\n    const x = r * Math.cos(theta);\n    const z = r * Math.sin(theta);\n    const y = randRange(0, EMITTER_HEIGHT);\n\n    positions[3 * i + 0] = x;\n    positions[3 * i + 1] = y;\n    positions[3 * i + 2] = z;\n\n    // Velocity: upward fountain with radial randomness\n    const vx = randRange(-SPREAD, SPREAD);\n    const vy = randRange(BASE_UP_VELOCITY * 0.6, BASE_UP_VELOCITY * 1.2);\n    const vz = randRange(-SPREAD, SPREAD);\n\n    velocities[3 * i + 0] = vx;\n    velocities[3 * i + 1] = vy;\n    velocities[3 * i + 2] = vz;\n\n    const life = randRange(MAX_LIFETIME * 0.4, MAX_LIFETIME);\n    lifetimes[i] = life;\n    startTimes[i] = t - Math.random() * life; // staggered\n    sizes[i] = randRange(8.0, 18.0);\n  }\n\n  // Initialize all particles\n  let initialTime = performance.now() / 1000;\n  for (let i = 0; i < PARTICLE_COUNT; i++) {\n    resetParticle(i, initialTime);\n  }\n\n  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n  geometry.setAttribute('aLifetime', new THREE.BufferAttribute(lifetimes, 1));\n  geometry.setAttribute('aStartTime', new THREE.BufferAttribute(startTimes, 1));\n  geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));\n\n  // Material using ShaderMaterial for color-over-lifetime + soft edges\n  const uniforms = {\n    uTime: { value: 0 },\n    uPointSize: { value: 1.0 },\n    uColor1: { value: new THREE.Color(0x00ffff) },\n    uColor2: { value: new THREE.Color(0xff00ff) },\n    uColor3: { value: new THREE.Color(0xffff00) },\n    uColor4: { value: new THREE.Color(0x00ff80) },\n    uFogColor: { value: scene.fog.color },\n    uFogDensity: { value: scene.fog.density }\n  };\n\n  const vertexShader = `\n    attribute float aLifetime;\n    attribute float aStartTime;\n    attribute float aSize;\n\n    uniform float uTime;\n    uniform float uPointSize;\n\n    varying float vLifeRatio;\n\n    void main() {\n      float age = uTime - aStartTime;\n      float lifeRatio = clamp(age / aLifetime, 0.0, 1.0);\n      vLifeRatio = lifeRatio;\n\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n      // Size attenuates with perspective\n      float size = aSize * uPointSize * (1.0 + (1.0 - lifeRatio) * 0.8);\n      gl_PointSize = size * (300.0 / -mvPosition.z);\n\n      gl_Position = projectionMatrix * mvPosition;\n    }\n  `;\n\n  const fragmentShader = `\n    precision mediump float;\n\n    uniform vec3 uColor1;\n    uniform vec3 uColor2;\n    uniform vec3 uColor3;\n    uniform vec3 uColor4;\n    uniform vec3 uFogColor;\n    uniform float uFogDensity;\n\n    varying float vLifeRatio;\n\n    void main() {\n      // soft circular particle (discard corners)\n      vec2 uv = gl_PointCoord * 2.0 - 1.0;\n      float d = dot(uv, uv);\n      if (d > 1.0) discard;\n\n      float alphaCircle = 1.0 - smoothstep(0.6, 1.0, sqrt(d));\n\n      // Life-based gradient: 4-color blend\n      vec3 col;\n      if (vLifeRatio < 0.33) {\n        float t = vLifeRatio / 0.33;\n        col = mix(uColor1, uColor2, t);\n      } else if (vLifeRatio < 0.66) {\n        float t = (vLifeRatio - 0.33) / 0.33;\n        col = mix(uColor2, uColor3, t);\n      } else {\n        float t = (vLifeRatio - 0.66) / 0.34;\n        col = mix(uColor3, uColor4, t);\n      }\n\n      // Bright core, fading edges\n      float core = 1.0 - d;\n      float intensity = 0.4 + core * 0.8;\n      vec3 color = col * intensity;\n\n      float alpha = alphaCircle * (0.25 + (1.0 - vLifeRatio) * 0.4);\n\n      // simple exponential fog in shader\n      float depth = gl_FragCoord.z / gl_FragCoord.w;\n      float fogFactor = 1.0 - exp(-uFogDensity * uFogDensity * depth * depth);\n      color = mix(color, uFogColor, fogFactor);\n      alpha *= (1.0 - fogFactor * 0.7);\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  `;\n\n  const material = new THREE.ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    transparent: true,\n    depthWrite: false,\n    blending: THREE.AdditiveBlending\n  });\n\n  const particlePoints = new THREE.Points(geometry, material);\n  scene.add(particlePoints);\n\n  // Simple curl-like noise using sin/cos (CPU side)\n  function pseudoCurlNoise(x, y, z, t) {\n    const scale = 0.15;\n    const speed = 0.6;\n    x *= scale; y *= scale; z *= scale;\n    t *= speed;\n\n    const nx = Math.sin(y + t) + Math.cos(z - t * 0.7);\n    const ny = Math.sin(z + t * 0.9) + Math.cos(x - t * 0.5);\n    const nz = Math.sin(x + t * 0.7) + Math.cos(y - t * 0.8);\n\n    const v = new THREE.Vector3(nx, ny, nz);\n    v.normalize();\n    return v;\n  }\n\n  // Animation loop\n  let lastTime = performance.now() / 1000;\n\n  function animate() {\n    requestAnimationFrame(animate);\n\n    const now = performance.now() / 1000;\n    const dt = Math.min(0.033, now - lastTime); // prevent large jumps\n    lastTime = now;\n    const elapsed = now - initialTime;\n\n    uniforms.uTime.value = elapsed;\n\n    updateMouse3D();\n    // Smooth mouse3D\n    mouse3D.lerp(targetMouse3D, 0.12);\n\n    // Integrate particles (Euler integration)\n    const gravity = GRAVITY.clone().multiplyScalar(dt);\n    const dragFactor = Math.max(0, 1.0 - DRAG * dt);\n\n    for (let i = 0; i < PARTICLE_COUNT; i++) {\n      const idx = 3 * i;\n\n      // Age / lifetime check; respawn if necessary\n      const age = elapsed - startTimes[i];\n      if (age >= lifetimes[i] || positions[idx + 1] < RESET_Y) {\n        resetParticle(i, elapsed);\n        continue;\n      }\n\n      // Current position & velocity\n      const px = positions[idx + 0];\n      const py = positions[idx + 1];\n      const pz = positions[idx + 2];\n\n      let vx = velocities[idx + 0];\n      let vy = velocities[idx + 1];\n      let vz = velocities[idx + 2];\n\n      // Curl noise flow field\n      const curl = pseudoCurlNoise(px, py, pz, elapsed);\n      vx += curl.x * NOISE_STRENGTH * dt;\n      vy += curl.y * NOISE_STRENGTH * dt;\n      vz += curl.z * NOISE_STRENGTH * dt;\n\n      // Mouse attraction/repulsion\n      const tempPos = new THREE.Vector3(px, py, pz);\n      const toMouse = new THREE.Vector3().subVectors(mouse3D, tempPos);\n      const distanceToMouse = toMouse.length() + 0.0001;\n      const influenceRadius = 15.0;\n      if (distanceToMouse < influenceRadius) {\n        toMouse.normalize();\n        const strength = (1.0 - distanceToMouse / influenceRadius);\n        // Alternate push/pull using time\n        const sign = Math.sin(elapsed * 1.2) > 0.0 ? 1.0 : -1.0;\n        vx += sign * toMouse.x * MOUSE_FORCE * strength * dt;\n        vy += sign * toMouse.y * MOUSE_FORCE * strength * dt;\n        vz += sign * toMouse.z * MOUSE_FORCE * strength * dt;\n      }\n\n      // Gravity\n      vx += gravity.x;\n      vy += gravity.y;\n      vz += gravity.z;\n\n      // Drag\n      vx *= dragFactor;\n      vy *= dragFactor;\n      vz *= dragFactor;\n\n      // Integrate position\n      positions[idx + 0] = px + vx * dt;\n      positions[idx + 1] = py + vy * dt;\n      positions[idx + 2] = pz + vz * dt;\n\n      velocities[idx + 0] = vx;\n      velocities[idx + 1] = vy;\n      velocities[idx + 2] = vz;\n    }\n\n    geometry.attributes.position.needsUpdate = true;\n\n    controls.update();\n    renderer.render(scene, camera);\n  }\n\n  animate();\n\n  // Resize handling\n  window.addEventListener('resize', () => {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  });\n\n  // Optional: scroll to zoom (slightly modify camera distance)\n  window.addEventListener('wheel', (event) => {\n    const zoomSpeed = 0.002;\n    const delta = event.deltaY * zoomSpeed;\n    const dir = new THREE.Vector3();\n    camera.getWorldDirection(dir);\n    camera.position.addScaledVector(dir, delta * 30);\n  }, { passive: true });\n\n})();\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 24.154309272766113,
    "status": "success",
    "timestamp": "2025-11-19 22:04:25",
    "evaluation": {
      "test_name": "particle_system_simulation",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "THREE.OrbitControls is not a constructor"
        ],
        "warnings": [
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.157.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.157.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.157.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.157.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation",
          "[.WebGL-0x10c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x10c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x10c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x10c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat)"
        ],
        "screenshot": "output/screenshots/particle_system_simulation.png",
        "render_time_ms": 684.88,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 684.88ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "THREE.OrbitControls is not a constructor"
            ]
          },
          {
            "level": "warning",
            "message": "\u26a0\ufe0f  9 warning(s)"
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "The code provided for evaluation is incomplete; it is cut off mid-line and contains no logic for creating, animating, or rendering a particle system. The requirements were to have an animated particle system with at least 1000 particles, interesting movement patterns, color changes, and mouse interaction. However, the existing code does not fulfill these core requirements as it is not fully implemented. While there is a basic setup with a scene, camera, and renderer, the main functionality described in the original request of creating and animating particles with realistic physics is not present in the provided snippet. The technical setup (including Three.js and OrbitControls) suggests good intentions, but the partial code results in missing key aspects.",
        "strengths": "The code contains a standard setup for a Three.js scene, including the inclusion of Three.js and OrbitControls from a CDN, a defined scene with fog, a perspective camera, a WebGL renderer, and basic camera controls.",
        "weaknesses": "The code is incomplete and lacks any implementation of a particle system, animation, color changes, or interactivity required by the original request. It does not currently fulfill the primary task and lacks logic for particle creation or realistic physics. Without these elements, the code fails significantly in achieving its goals.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "terrain_simulation",
    "prompt": "Create a complete HTML file with Three.js that generates and displays a 3D terrain landscape. The terrain should have hills and valleys using noise or height maps, include realistic texturing (grass, rock, etc.), and allow the user to fly through the scene with keyboard controls (WASD). Add fog effects for depth. The HTML should be self-contained with Three.js from CDN. Save the output as 'terrain_landscape.html'.",
    "response": "```html\n<!-- Save this file as: terrain_landscape.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>Three.js Terrain Landscape</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background: #000;\n            font-family: sans-serif;\n            color: #fff;\n        }\n        #info {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            padding: 6px 10px;\n            background: rgba(0, 0, 0, 0.45);\n            font-size: 13px;\n            z-index: 10;\n        }\n        a {\n            color: #8cf;\n        }\n    </style>\n</head>\n<body>\n<div id=\"info\">\n    <div><b>3D Terrain Landscape</b></div>\n    <div>W / S: move forward / backward</div>\n    <div>A / D: strafe left / right</div>\n    <div>Q / E: move down / up</div>\n    <div>Mouse drag: look around</div>\n</div>\n\n<!-- Three.js and OrbitControls from CDN -->\n<script src=\"https://unpkg.com/three@0.160.0/build/three.min.js\"></script>\n<script src=\"https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js\"></script>\n\n<script>\n(function () {\n    // ----- Basic setup -----\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x87ceeb); // sky color\n    scene.fog = new THREE.Fog(0x87ceeb, 150, 900); // fog for depth\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\n    document.body.appendChild(renderer.domElement);\n\n    const camera = new THREE.PerspectiveCamera(\n        60,\n        window.innerWidth / window.innerHeight,\n        0.1,\n        5000\n    );\n    camera.position.set(0, 50, 150);\n\n    // OrbitControls for looking around (mouse)\n    const controls = new THREE.OrbitControls(camera, renderer.domElement);\n    controls.enablePan = false;\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.rotateSpeed = 0.25;\n    controls.maxPolarAngle = Math.PI / 2 - 0.05;\n    controls.target.set(0, 20, 0);\n\n    // ----- Lighting -----\n    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x334433, 0.7);\n    scene.add(hemiLight);\n\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    dirLight.position.set(-100, 200, 100);\n    dirLight.castShadow = true;\n    dirLight.shadow.mapSize.set(2048, 2048);\n    scene.add(dirLight);\n\n    // ----- Simple pseudo random (for noise) -----\n    function mulberry32(seed) {\n        return function () {\n            let t = (seed += 0x6d2b79f5);\n            t = Math.imul(t ^ (t >>> 15), t | 1);\n            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n        };\n    }\n\n    const rand = mulberry32(123456);\n\n    // ----- 2D value noise -----\n    const NOISE_SIZE = 256;\n    const noiseGrid = [];\n    for (let y = 0; y < NOISE_SIZE; y++) {\n        noiseGrid[y] = [];\n        for (let x = 0; x < NOISE_SIZE; x++) {\n            noiseGrid[y][x] = rand();\n        }\n    }\n\n    function smoothstep(t) {\n        return t * t * (3 - 2 * t);\n    }\n\n    function lerp(a, b, t) {\n        return a + (b - a) * t;\n    }\n\n    function valueNoise2D(x, y) {\n        const xi = Math.floor(x);\n        const yi = Math.floor(y);\n        const xf = x - xi;\n        const yf = y - yi;\n\n        const x0 = (xi % NOISE_SIZE + NOISE_SIZE) % NOISE_SIZE;\n        const y0 = (yi % NOISE_SIZE + NOISE_SIZE) % NOISE_SIZE;\n        const x1 = (x0 + 1) % NOISE_SIZE;\n        const y1 = (y0 + 1) % NOISE_SIZE;\n\n        const v00 = noiseGrid[y0][x0];\n        const v10 = noiseGrid[y0][x1];\n        const v01 = noiseGrid[y1][x0];\n        const v11 = noiseGrid[y1][x1];\n\n        const u = smoothstep(xf);\n        const v = smoothstep(yf);\n\n        const a = lerp(v00, v10, u);\n        const b = lerp(v01, v11, u);\n        return lerp(a, b, v);\n    }\n\n    // Fractal Brownian Motion (fbm) using valueNoise2D\n    function fbm(x, y, octaves, lacunarity, gain) {\n        let amp = 1;\n        let freq = 1;\n        let sum = 0;\n        let norm = 0;\n        for (let i = 0; i < octaves; i++) {\n            sum += valueNoise2D(x * freq, y * freq) * amp;\n            norm += amp;\n            amp *= gain;\n            freq *= lacunarity;\n        }\n        return sum / norm;\n    }\n\n    // ----- Terrain Geometry -----\n    const terrainWidth = 800;\n    const terrainDepth = 800;\n    const segments = 256;\n\n    const geometry = new THREE.PlaneGeometry(\n        terrainWidth,\n        terrainDepth,\n        segments,\n        segments\n    );\n    geometry.rotateX(-Math.PI / 2); // make it horizontal\n\n    // Height map using fbm noise\n    const vertices = geometry.attributes.position;\n    const heights = [];\n\n    for (let i = 0; i < vertices.count; i++) {\n        const x = vertices.getX(i);\n        const z = vertices.getZ(i);\n\n        const nx = (x / terrainWidth) * 4;\n        const nz = (z / terrainDepth) * 4;\n\n        let h =\n            fbm(nx, nz, 5, 2.0, 0.5) * 60 - 10; // base landscape\n        // Add a larger scale variation for big hills\n        h += fbm(nx * 0.3, nz * 0.3, 3, 2.0, 0.5) * 50;\n\n        heights[i] = h;\n        vertices.setY(i, h);\n    }\n\n    geometry.computeVertexNormals();\n\n    // ----- Terrain Texture (procedural) -----\n    // Create a gradient texture that blends from grass (low),\n    // to rock/dirt (mid), to snow (high).\n    function createTerrainTexture() {\n        const size = 512;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext(\"2d\");\n\n        const grd = ctx.createLinearGradient(0, 0, 0, size);\n        // Bottom (valleys) - dark green\n        grd.addColorStop(0.0, \"#1a3b1a\");\n        grd.addColorStop(0.25, \"#2e5b2e\");\n        // Mid slopes - lighter / dry grass, some dirt\n        grd.addColorStop(0.5, \"#7b6a3d\");\n        grd.addColorStop(0.7, \"#91856c\");\n        // High (peaks) - rock to snow\n        grd.addColorStop(0.85, \"#c7c7c7\");\n        grd.addColorStop(1.0, \"#ffffff\");\n\n        ctx.fillStyle = grd;\n        ctx.fillRect(0, 0, size, size);\n\n        // add some subtle noise\n        const imgData = ctx.getImageData(0, 0, size, size);\n        const data = imgData.data;\n        for (let i = 0; i < data.length; i += 4) {\n            const n = (rand() - 0.5) * 18; // noise intensity\n            data[i] = Math.min(255, Math.max(0, data[i] + n));\n            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + n));\n            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + n));\n        }\n        ctx.putImageData(imgData, 0, 0);\n\n        const texture = new THREE.CanvasTexture(canvas);\n        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n        texture.repeat.set(16, 16);\n        texture.anisotropy = 8;\n\n        return texture;\n    }\n\n    const terrainTexture = createTerrainTexture();\n\n    const terrainMaterial = new THREE.MeshLambertMaterial({\n        map: terrainTexture,\n    });\n\n    const terrain = new THREE.Mesh(geometry, terrainMaterial);\n    terrain.receiveShadow = true;\n    terrain.castShadow = false;\n    scene.add(terrain);\n\n    // ----- Simple sky dome (gradient) -----\n    (function createSkyDome() {\n        const skyGeo = new THREE.SphereGeometry(3000, 32, 15);\n        const skyMat = new THREE.ShaderMaterial({\n            side: THREE.BackSide,\n            uniforms: {\n                topColor: { value: new THREE.Color(0x87ceeb) },\n                bottomColor: { value: new THREE.Color(0xffffff) },\n                offset: { value: 400 },\n                exponent: { value: 0.7 },\n            },\n            vertexShader: `\n                varying vec3 vWorldPosition;\n                void main() {\n                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n                    vWorldPosition = worldPosition.xyz;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }\n            `,\n            fragmentShader: `\n                uniform vec3 topColor;\n                uniform vec3 bottomColor;\n                uniform float offset;\n                uniform float exponent;\n                varying vec3 vWorldPosition;\n                void main() {\n                    float h = normalize( vWorldPosition + offset ).y;\n                    float f = max( pow( max(h, 0.0), exponent ), 0.0 );\n                    gl_FragColor = vec4( mix( bottomColor, topColor, f ), 1.0 );\n                }\n            `,\n        });\n        const sky = new THREE.Mesh(skyGeo, skyMat);\n        scene.add(sky);\n    })();\n\n    // ----- WASDQE Fly Controls (custom) -----\n    const keys = {\n        KeyW: false,\n        KeyS: false,\n        KeyA: false,\n        KeyD: false,\n        KeyQ: false,\n        KeyE: false,\n    };\n\n    window.addEventListener(\"keydown\", (e) => {\n        if (e.code in keys) {\n            keys[e.code] = true;\n        }\n    });\n\n    window.addEventListener(\"keyup\", (e) => {\n        if (e.code in keys) {\n            keys[e.code] = false;\n        }\n    });\n\n    let lastTime = performance.now();\n\n    function updateMovement(delta) {\n        const speed = 80; // base movement speed units/sec\n        // Forward/backward - along camera's local Z\n        const forward = new THREE.Vector3();\n        camera.getWorldDirection(forward);\n        forward.y = 0;\n        forward.normalize();\n\n        const right = new THREE.Vector3();\n        right.crossVectors(forward, camera.up).normalize();\n\n        let move = new THREE.Vector3();\n\n        if (keys.KeyW) move.add(forward);\n        if (keys.KeyS) move.sub(forward);\n        if (keys.KeyA) move.sub(right);\n        if (keys.KeyD) move.add(right);\n\n        // Q/E for vertical\n        if (keys.KeyE) move.y += 1;\n        if (keys.KeyQ) move.y -= 1;\n\n        if (move.lengthSq() > 0) {\n            move.normalize();\n            move.multiplyScalar(speed * delta);\n            camera.position.add(move);\n            controls.target.add(move); // so orbit center follows\n        }\n\n        // keep camera above terrain\n        const terrainY = sampleHeightAt(camera.position.x, camera.position.z);\n        const minHeightAbove = 8;\n        if (camera.position.y < terrainY + minHeightAbove) {\n            const diff = terrainY + minHeightAbove - camera.position.y;\n            camera.position.y += diff;\n            controls.target.y += diff;\n        }\n    }\n\n    // ----- Sampling terrain height at (x,z) -----\n    function sampleHeightAt(x, z) {\n        // Transform world (x,z) into plane local coordinates\n        // Plane centered at (0,0), width=terrainWidth, depth=terrainDepth\n        const halfW = terrainWidth / 2;\n        const halfD = terrainDepth / 2;\n\n        const u = (x + halfW) / terrainWidth;\n        const v = (z + halfD) / terrainDepth;\n\n        if (u < 0 || u > 1 || v < 0 || v > 1) {\n            // outside terrain; just use noise directly to approximate\n            const nx = (x / terrainWidth) * 4;\n            const nz = (z / terrainDepth) * 4;\n            let h = fbm(nx, nz, 5, 2.0, 0.5) * 60 - 10;\n            h += fbm(nx * 0.3, nz * 0.3, 3, 2.0, 0.5) * 50;\n            return h;\n        }\n\n        const gridX = segments;\n        const gridZ = segments;\n\n        const gx = u * gridX;\n        const gz = v * gridZ;\n\n        const ix = Math.floor(gx);\n        const iz = Math.floor(gz);\n\n        const tx = gx - ix;\n        const tz = gz - iz;\n\n        function idx(i, j) {\n            return j * (gridX + 1) + i;\n        }\n\n        const i0 = Math.min(gridX, Math.max(0, ix));\n        const j0 = Math.min(gridZ, Math.max(0, iz));\n        const i1 = Math.min(gridX, i0 + 1);\n        const j1 = Math.min(gridZ, j0 + 1);\n\n        const h00 = heights[idx(i0, j0)];\n        const h10 = heights[idx(i1, j0)];\n        const h01 = heights[idx(i0, j1)];\n        const h11 = heights[idx(i1, j1)];\n\n        const hx0 = h00 * (1 - tx) + h10 * tx;\n        const hx1 = h01 * (1 - tx) + h11 * tx;\n        const hFinal = hx0 * (1 - tz) + hx1 * tz;\n\n        return hFinal;\n    }\n\n    // ----- Resize handling -----\n    window.addEventListener(\"resize\", onWindowResize);\n    function onWindowResize() {\n        const w = window.innerWidth;\n        const h = window.innerHeight;\n        camera.aspect = w / h;\n        camera.updateProjectionMatrix();\n        renderer.setSize(w, h);\n    }\n\n    // ----- Animation loop -----\n    function animate() {\n        requestAnimationFrame(animate);\n\n        const now = performance.now();\n        const delta = (now - lastTime) / 1000;\n        lastTime = now;\n\n        updateMovement(delta);\n        controls.update();\n\n        renderer.render(scene, camera);\n    }\n\n    animate();\n})();\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 28.644328117370605,
    "status": "success",
    "timestamp": "2025-11-19 22:05:00",
    "evaluation": {
      "test_name": "terrain_simulation",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "THREE.OrbitControls is not a constructor"
        ],
        "warnings": [
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation",
          "[.WebGL-0x11c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x11c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x11c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x11c001ccb00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat)"
        ],
        "screenshot": "output/screenshots/terrain_simulation.png",
        "render_time_ms": 684.22,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 684.22ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "THREE.OrbitControls is not a constructor"
            ]
          },
          {
            "level": "warning",
            "message": "\u26a0\ufe0f  9 warning(s)"
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "1. The code snippet provided does not constitute a complete HTML file for generating a 3D terrain landscape. 2. Key functionalities like terrain generation with noise/height maps, realistic texturing, and keyboard-based (WASD) navigation are missing. 3. The HTML and JavaScript setup is partially present with basic Three.js scene setup including the scene, camera, renderer, and fog. 4. The skeleton for controls initialization is partly present but incomplete. 5. The request explicitly asked for self-contained HTML, which is not satisfied due to missing significant portions of the implementation.",
        "strengths": "1. The code employs some modern techniques using ES6+ standards, such as const for variable declarations. 2. Basic Three.js setup (scene, camera, renderer) is initiated correctly. 3. It includes fog for depth effect as requested.",
        "weaknesses": "1. Code does not fulfill the main requirements of generating a 3D terrain landscape with hills and valleys. 2. Lacks terrain generation logic using noise or height maps. 3. Realistic texturing (grass, rock) is not implemented. 4. The functionality for keyboard controls (WASD) for flying through the scene is absent. 5. OrbitControls script is imported but not fully utilized for necessary camera control.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "interactive_solar_system",
    "prompt": "Create a complete HTML file with Three.js that builds an interactive 3D solar system with textured planets, axial rotation, elliptical orbits, adjustable time speed, and click-to-reveal planet facts. Include orbit lines, lighting from a sun mesh, and responsive camera controls. The HTML file should be self-contained with Three.js loaded from CDN and include all textures as data URLs or procedural materials. Save the output as 'interactive_solar_system.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Interactive 3D Solar System - Three.js</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      width: 100%;\n      height: 100%;\n      background: radial-gradient(circle at top, #000015 0%, #000000 60%, #020010 100%);\n      font-family: system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif;\n      color: #eee;\n    }\n    #container {\n      width: 100%;\n      height: 100%;\n      position: relative;\n    }\n    #infoPanel {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      padding: 10px 14px;\n      background: rgba(0,0,0,0.65);\n      border-radius: 8px;\n      max-width: 280px;\n      font-size: 13px;\n      line-height: 1.4;\n      pointer-events: auto;\n      backdrop-filter: blur(4px);\n    }\n    #infoPanel h1 {\n      font-size: 16px;\n      margin: 0 0 6px 0;\n    }\n    #infoPanel p {\n      margin: 4px 0;\n    }\n    #infoPanel small {\n      color: #aaa;\n    }\n    #controlsPanel {\n      position: absolute;\n      bottom: 10px;\n      left: 10px;\n      padding: 10px 14px;\n      background: rgba(0,0,0,0.65);\n      border-radius: 8px;\n      font-size: 12px;\n      pointer-events: auto;\n      backdrop-filter: blur(4px);\n    }\n    #controlsPanel label {\n      display: inline-block;\n      margin-right: 8px;\n    }\n    #timeSpeed {\n      width: 150px;\n      vertical-align: middle;\n    }\n    #speedValue {\n      display: inline-block;\n      min-width: 40px;\n      text-align: right;\n      margin-left: 4px;\n    }\n    #hint {\n      position: absolute;\n      top: 10px;\n      right: 10px;\n      padding: 6px 10px;\n      background: rgba(0,0,0,0.4);\n      border-radius: 6px;\n      font-size: 11px;\n      color: #ccc;\n    }\n    a {\n      color: #82b1ff;\n      text-decoration: none;\n    }\n    a:hover {\n      text-decoration: underline;\n    }\n    canvas {\n      display: block;\n    }\n  </style>\n</head>\n<body>\n<div id=\"container\"></div>\n\n<div id=\"infoPanel\">\n  <h1>3D Solar System</h1>\n  <p><strong>Click a planet</strong> to see facts here.</p>\n  <p><small>Use mouse to orbit, pan, and zoom around the system.</small></p>\n  <hr style=\"border-color:#333;\">\n  <p id=\"planetName\"><strong>Sun</strong></p>\n  <p id=\"planetFacts\">\n    The Sun is the star at the center of our solar system. Its gravity holds the planets in orbit and its light and heat make life possible on Earth.\n  </p>\n</div>\n\n<div id=\"controlsPanel\">\n  <label for=\"timeSpeed\">Time speed:</label>\n  <input id=\"timeSpeed\" type=\"range\" min=\"0\" max=\"5\" step=\"0.1\" value=\"1\">\n  <span id=\"speedValue\">1.0\u00d7</span><br>\n  <small>Drag to speed up or slow down orbits and rotations.</small>\n</div>\n\n<div id=\"hint\">\n  Left-drag: orbit &middot; Right-drag / Ctrl-drag: pan &middot; Wheel: zoom\n</div>\n\n<!-- Three.js & OrbitControls from CDN -->\n<script src=\"https://unpkg.com/three@0.156.1/build/three.min.js\"></script>\n<script src=\"https://unpkg.com/three@0.156.1/examples/js/controls/OrbitControls.js\"></script>\n\n<script>\n(function () {\n  const container = document.getElementById('container');\n\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x000000);\n\n  const camera = new THREE.PerspectiveCamera(\n    55,\n    window.innerWidth / window.innerHeight,\n    0.1,\n    5000\n  );\n  camera.position.set(0, 120, 280);\n\n  const renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setPixelRatio(window.devicePixelRatio || 1);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.outputEncoding = THREE.sRGBEncoding;\n  container.appendChild(renderer.domElement);\n\n  const controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.08;\n  controls.minDistance = 40;\n  controls.maxDistance = 1500;\n  controls.enablePan = true;\n  controls.panSpeed = 0.4;\n\n  // Lighting\n  const ambient = new THREE.AmbientLight(0x202020, 1.5);\n  scene.add(ambient);\n\n  const sunLight = new THREE.PointLight(0xffffff, 2.4, 0, 2);\n  sunLight.position.set(0, 0, 0);\n  scene.add(sunLight);\n\n  // Starfield background\n  (function createStars() {\n    const starGeom = new THREE.BufferGeometry();\n    const starCount = 2000;\n    const positions = new Float32Array(starCount * 3);\n    for (let i = 0; i < starCount; i++) {\n      const r = 1000 * (0.6 + Math.random() * 0.4);\n      const theta = Math.random() * 2 * Math.PI;\n      const phi = Math.acos(2 * Math.random() - 1);\n      positions[3 * i]     = r * Math.sin(phi) * Math.cos(theta);\n      positions[3 * i + 1] = r * Math.sin(phi) * Math.sin(theta);\n      positions[3 * i + 2] = r * Math.cos(phi);\n    }\n    starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    const starMat = new THREE.PointsMaterial({\n      color: 0xffffff,\n      size: 1.2,\n      sizeAttenuation: true\n    });\n    scene.add(new THREE.Points(starGeom, starMat));\n  })();\n\n  // Procedural textures using small canvas -> dataURL\n  function createPlanetTexture(baseColor, noiseColor, size) {\n    const s = size || 256;\n    const c = document.createElement('canvas');\n    c.width = c.height = s;\n    const ctx = c.getContext('2d');\n\n    const grad = ctx.createRadialGradient(\n      s * 0.3, s * 0.3, 0,\n      s * 0.5, s * 0.5, s * 0.7\n    );\n    grad.addColorStop(0, lighten(baseColor, 0.25));\n    grad.addColorStop(1, darken(baseColor, 0.4));\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, s, s);\n\n    const noiseDensity = 800;\n    for (let i = 0; i < noiseDensity; i++) {\n      const x = Math.random() * s;\n      const y = Math.random() * s;\n      const r = Math.random() * 2 + 0.5;\n      const alpha = 0.12 + Math.random() * 0.15;\n      ctx.fillStyle = withAlpha(noiseColor, alpha);\n      ctx.beginPath();\n      ctx.arc(x, y, r, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    return c.toDataURL();\n  }\n\n  function createRingTexture(innerColor, outerColor, size) {\n    const s = size || 512;\n    const c = document.createElement('canvas');\n    c.width = c.height = s;\n    const ctx = c.getContext('2d');\n\n    ctx.clearRect(0, 0, s, s);\n    ctx.translate(s / 2, s / 2);\n\n    const maxR = s * 0.48;\n    const minR = s * 0.2;\n    const grad = ctx.createRadialGradient(0, 0, minR, 0, 0, maxR);\n    grad.addColorStop(0, withAlpha(innerColor, 0.0));\n    grad.addColorStop(0.4, withAlpha(innerColor, 0.5));\n    grad.addColorStop(0.9, withAlpha(outerColor, 0.0));\n    grad.addColorStop(1.0, withAlpha(outerColor, 0.0));\n\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(0, 0, maxR, 0, Math.PI * 2);\n    ctx.arc(0, 0, minR, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n\n    return c.toDataURL();\n  }\n\n  function lighten(hex, amount) {\n    const c = parseInt(hex.replace('#', ''), 16);\n    let r = (c >> 16) & 255;\n    let g = (c >> 8) & 255;\n    let b = c & 255;\n    r = Math.min(255, Math.floor(r + 255 * amount));\n    g = Math.min(255, Math.floor(g + 255 * amount));\n    b = Math.min(255, Math.floor(b + 255 * amount));\n    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n  }\n\n  function darken(hex, amount) {\n    const c = parseInt(hex.replace('#', ''), 16);\n    let r = (c >> 16) & 255;\n    let g = (c >> 8) & 255;\n    let b = c & 255;\n    r = Math.max(0, Math.floor(r - 255 * amount));\n    g = Math.max(0, Math.floor(g - 255 * amount));\n    b = Math.max(0, Math.floor(b - 255 * amount));\n    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n  }\n\n  function withAlpha(hex, alpha) {\n    const c = parseInt(hex.replace('#', ''), 16);\n    let r = (c >> 16) & 255;\n    let g = (c >> 8) & 255;\n    let b = c & 255;\n    return `rgba(${r},${g},${b},${alpha})`;\n  }\n\n  const textureLoader = new THREE.TextureLoader();\n\n  // Sun\n  (function createSun() {\n    const texCanvas = document.createElement('canvas');\n    texCanvas.width = texCanvas.height = 256;\n    const ctx = texCanvas.getContext('2d');\n    const grad = ctx.createRadialGradient(\n      128, 128, 0,\n      128, 128, 128\n    );\n    grad.addColorStop(0, '#ffffdd');\n    grad.addColorStop(0.4, '#ffdd55');\n    grad.addColorStop(0.8, '#ff8800');\n    grad.addColorStop(1, '#442200');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, 256, 256);\n    const texURL = texCanvas.toDataURL();\n\n    const sunTex = textureLoader.load(texURL);\n    sunTex.encoding = THREE.sRGBEncoding;\n    const sunMat = new THREE.MeshBasicMaterial({\n      map: sunTex,\n      emissive: new THREE.Color(0xffff88),\n      emissiveIntensity: 1.0\n    });\n\n    const sunGeo = new THREE.SphereGeometry(20, 48, 48);\n    const sun = new THREE.Mesh(sunGeo, sunMat);\n    sun.name = 'Sun';\n    scene.add(sun);\n\n    const glowGeo = new THREE.SphereGeometry(32, 32, 32);\n    const glowMat = new THREE.MeshBasicMaterial({\n      color: 0xffcc66,\n      transparent: true,\n      opacity: 0.18,\n      blending: THREE.AdditiveBlending\n    });\n    const glow = new THREE.Mesh(glowGeo, glowMat);\n    sun.add(glow);\n  })();\n\n  // Planet definitions (scaled & approximate)\n  const planetData = [\n    {\n      name: 'Mercury',\n      radius: 2,\n      distanceMajor: 32,\n      distanceMinor: 30,\n      orbitPeriod: 0.24,\n      rotationPeriod: 58.6,\n      color: '#b3b3b3',\n      noiseColor: '#888888',\n      tilt: 0.01,\n      facts: 'Mercury is the closest planet to the Sun and the smallest in the solar system. Its surface experiences extreme temperature swings.'\n    },\n    {\n      name: 'Venus',\n      radius: 3.5,\n      distanceMajor: 45,\n      distanceMinor: 42,\n      orbitPeriod: 0.62,\n      rotationPeriod: -243,\n      color: '#f5deb3',\n      noiseColor: '#c2a878',\n      tilt: 177.4 * Math.PI / 180,\n      facts: 'Venus has a thick, toxic atmosphere and runaway greenhouse effect, making it the hottest planet, even hotter than Mercury.'\n    },\n    {\n      name: 'Earth',\n      radius: 3.7,\n      distanceMajor: 60,\n      distanceMinor: 58,\n      orbitPeriod: 1.0,\n      rotationPeriod: 1.0,\n      color: '#2b6cff',\n      noiseColor: '#3dbf5a',\n      tilt: 23.5 * Math.PI / 180,\n      facts: 'Earth is the only known planet to support life. About 71% of its surface is covered by liquid water.'\n    },\n    {\n      name: 'Mars',\n      radius: 2.5,\n      distanceMajor: 76,\n      distanceMinor: 72,\n      orbitPeriod: 1.88,\n      rotationPeriod: 1.03,\n      color: '#b55328',\n      noiseColor: '#804020',\n      tilt: 25 * Math.PI / 180,\n      facts: 'Mars is a cold desert world with a thin atmosphere. It hosts the largest volcano and canyon in the solar system.'\n    },\n    {\n      name: 'Jupiter',\n      radius: 10,\n      distanceMajor: 110,\n      distanceMinor: 105,\n      orbitPeriod: 11.86,\n      rotationPeriod: 0.41,\n      color: '#d2b48c',\n      noiseColor: '#aa6f39',\n      tilt: 3.1 * Math.PI / 180,\n      facts: 'Jupiter is the largest planet, a gas giant with a famous Great Red Spot\u2014a gigantic storm larger than Earth.'\n    },\n    {\n      name: 'Saturn',\n      radius: 8.5,\n      distanceMajor: 150,\n      distanceMinor: 143,\n      orbitPeriod: 29.46,\n      rotationPeriod: 0.45,\n      color: '#f0e0b4',\n      noiseColor: '#c9a86a',\n      tilt: 26.7 * Math.PI / 180,\n      hasRings: true,\n      facts: 'Saturn is known for its spectacular ring system made mostly of ice and rock particles. It is the second-largest planet.'\n    },\n    {\n      name: 'Uranus',\n      radius: 7,\n      distanceMajor: 185,\n      distanceMinor: 180,\n      orbitPeriod: 84.01,\n      rotationPeriod: -0.72,\n      color: '#88cddb',\n      noiseColor: '#4e8fb2',\n      tilt: 97.8 * Math.PI / 180,\n      facts: 'Uranus rotates on its side with an axial tilt of about 98\u00b0, making its seasons extremely unusual.'\n    },\n    {\n      name: 'Neptune',\n      radius: 7,\n      distanceMajor: 220,\n      distanceMinor: 215,\n      orbitPeriod: 164.8,\n      rotationPeriod: 0.67,\n      color: '#4169e1',\n      noiseColor: '#27408b',\n      tilt: 28.3 * Math.PI / 180,\n      facts: 'Neptune is a cold, blue ice giant with supersonic winds. It is the most distant known major planet from the Sun.'\n    }\n  ];\n\n  const planets = [];\n  const clickableObjects = [];\n\n  function createOrbitEllipse(a, b, segments, color) {\n    const curvePoints = [];\n    for (let i = 0; i <= segments; i++) {\n      const t = (i / segments) * Math.PI * 2;\n      const x = a * Math.cos(t);\n      const z = b * Math.sin(t);\n      curvePoints.push(new THREE.Vector3(x, 0, z));\n    }\n    const geom = new THREE.BufferGeometry().setFromPoints(curvePoints);\n    const mat = new THREE.LineBasicMaterial({\n      color: color || 0x555555,\n      transparent: true,\n      opacity: 0.6\n    });\n    return new THREE.LineLoop(geom, mat);\n  }\n\n  planetData.forEach(data => {\n    const texURL = createPlanetTexture(data.color, data.noiseColor, 256);\n    const tex = textureLoader.load(texURL);\n    tex.encoding = THREE.sRGBEncoding;\n\n    const mat = new THREE.MeshStandardMaterial({\n      map: tex,\n      roughness: 0.9,\n      metalness: 0.0\n    });\n\n    const geo = new THREE.SphereGeometry(data.radius, 32, 32);\n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.castShadow = false;\n    mesh.receiveShadow = false;\n    mesh.name = data.name;\n\n    const pivot = new THREE.Object3D();\n    scene.add(pivot);\n    pivot.add(mesh);\n\n    mesh.rotation.z = data.tilt || 0;\n\n    const orbitLine = createOrbitEllipse(\n      data.distanceMajor,\n      data.distanceMinor,\n      180,\n      0x333333\n    );\n    scene.add(orbitLine);\n\n    const planetInfo = {\n      name: data.name,\n      facts: data.facts,\n      pivot: pivot,\n      mesh: mesh,\n      orbitLine: orbitLine,\n      radius: data.radius,\n      semiMajorAxis: data.distanceMajor,\n      semiMinorAxis: data.distanceMinor,\n      orbitPeriod: data.orbitPeriod,\n      rotationPeriod: data.rotationPeriod,\n      axialTilt: data.tilt || 0,\n      angle: Math.random() * Math.PI * 2\n    };\n\n    if (data.hasRings) {\n      const ringTexURL = createRingTexture('#f8f3d2', '#c7a96c', 512);\n      const ringTex = textureLoader.load(ringTexURL);\n      ringTex.encoding = THREE.sRGBEncoding;\n      ringTex.wrapS = ringTex.wrapT = THREE.ClampToEdgeWrapping;\n      const ringGeo = new THREE.RingGeometry(\n        data.radius * 1.8,\n        data.radius * 3.2,\n        64\n      );\n      const pos = ringGeo.attributes.position;\n      const v3 = new THREE.Vector3();\n      for (let i = 0; i < pos.count; i++) {\n        v3.fromBufferAttribute(pos, i);\n        v3.normalize();\n        ringGeo.attributes.uv.setXY(i,\n          (v3.length() > 0 ? (v3.length()) : 1),\n          0.5\n        );\n      }\n      const ringMat = new THREE.MeshBasicMaterial({\n        map: ringTex,\n        side: THREE.DoubleSide,\n        transparent: true,\n        opacity: 0.9,\n        depthWrite: false\n      });\n      const ringMesh = new THREE.Mesh(ringGeo, ringMat);\n      ringMesh.rotation.x = Math.PI / 2;\n      ringMesh.name = data.name + ' Rings';\n      mesh.add(ringMesh);\n    }\n\n    planets.push(planetInfo);\n    clickableObjects.push(mesh);\n  });\n\n  // Planet facts UI\n  const nameEl = document.getElementById('planetName');\n  const factsEl = document.getElementById('planetFacts');\n\n  function showPlanetInfo(planetName) {\n    const p = planets.find(p => p.name === planetName);\n    if (!p) {\n      if (planetName === 'Sun') {\n        nameEl.textContent = 'Sun';\n        factsEl.textContent =\n          'The Sun is the star at the center of our solar system. Its gravity holds the planets in orbit and its light and heat make life possible on Earth.';\n      }\n      return;\n    }\n    nameEl.textContent = p.name;\n    factsEl.textContent = p.facts;\n  }\n\n  // Time speed control\n  const timeSpeedSlider = document.getElementById('timeSpeed');\n  const speedValueLabel = document.getElementById('speedValue');\n  let timeScale = parseFloat(timeSpeedSlider.value);\n\n  timeSpeedSlider.addEventListener('input', () => {\n    timeScale = parseFloat(timeSpeedSlider.value);\n    speedValueLabel.textContent = timeScale.toFixed(1) + '\u00d7';\n  });\n\n  // Raycaster for click interaction\n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n\n  function onClick(event) {\n    const rect = renderer.domElement.getBoundingClientRect();\n    const x = ( (event.clientX - rect.left) / rect.width ) * 2 - 1;\n    const y = - ( (event.clientY - rect.top) / rect.height ) * 2 + 1;\n    mouse.set(x, y);\n\n    raycaster.setFromCamera(mouse, camera);\n    const intersects = raycaster.intersectObjects(clickableObjects, true);\n    if (intersects.length > 0) {\n      const obj = intersects[0].object;\n      showPlanetInfo(obj.name || obj.parent?.name);\n    }\n  }\n  renderer.domElement.addEventListener('click', onClick);\n\n  // Animation loop\n  let lastTime = performance.now();\n\n  function animate(now) {\n    requestAnimationFrame(animate);\n    const deltaMs = now - lastTime;\n    lastTime = now;\n    const deltaSeconds = deltaMs / 1000;\n    const simDeltaYears = deltaSeconds * timeScale; // 1 sec ~ 1 year when timeScale=1\n\n    planets.forEach(p => {\n      const orbitSpeed = (2 * Math.PI) / p.orbitPeriod;\n      p.angle += orbitSpeed * simDeltaYears;\n\n      const x = p.semiMajorAxis * Math.cos(p.angle);\n      const z = p.semiMinorAxis * Math.sin(p.angle);\n      p.mesh.position.set(x, 0, z);\n\n      if (p.rotationPeriod !== 0) {\n        const rotSpeed = (2 * Math.PI) / Math.abs(p.rotationPeriod);\n        const direction = p.rotationPeriod > 0 ? 1 : -1;\n        p.mesh.rotation.y += direction * rotSpeed * simDeltaYears;\n      }\n    });\n\n    controls.update();\n    renderer.render(scene, camera);\n  }\n  requestAnimationFrame(animate);\n\n  // Handle resize\n  window.addEventListener('resize', () => {\n    const w = window.innerWidth;\n    const h = window.innerHeight;\n    camera.aspect = w / h;\n    camera.updateProjectionMatrix();\n    renderer.setSize(w, h);\n  });\n\n})();\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 33.534733057022095,
    "status": "success",
    "timestamp": "2025-11-19 22:05:41",
    "evaluation": {
      "test_name": "interactive_solar_system",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "THREE.OrbitControls is not a constructor"
        ],
        "warnings": [
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.156.1/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.156.1/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.156.1/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.156.1/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation",
          "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
          "[.WebGL-0x10c001db200]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x10c001db200]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x10c001db200]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x10c001db200]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat)"
        ],
        "screenshot": "output/screenshots/interactive_solar_system.png",
        "render_time_ms": 721.57,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 721.57ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "THREE.OrbitControls is not a constructor"
            ]
          },
          {
            "level": "warning",
            "message": "\u26a0\ufe0f  10 warning(s)"
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "The provided code snippet is incomplete and does not fully satisfy any of the core requirements outlined in the original request. The task was to create a complete HTML file with Three.js to display an interactive 3D solar system with features like textured planets, axial rotation, elliptical orbits, adjustable time speed, and click-to-reveal planet facts. The snippet contains styling and a basic HTML structure but lacks any JavaScript or Three.js components to create a 3D scene, animate the solar system, or manage interactions and controls. The CDN script for Three.js is absent, and no logic for any of the required functionalities is present, such as handling the rendering loop or configuring the camera and lighting.",
        "strengths": "The CSS styling is well-structured and provides a good visual layout intended for UI elements such as info panels and controls.",
        "weaknesses": "The code is critically lacking the implementation of the Three.js 3D scene, anything to do with the solar system rendering, planet textures or facts display, camera controls, or any interactivity features. There is no inclusion of Three.js library, and thus it fails to achieve the main task requirements.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "procedural_city_generator",
    "prompt": "Create a complete HTML file with Three.js that generates a procedural 3D city with random blocks, building heights, road grid, traffic light animations, day/night cycle with HDRI sky, and a free-fly camera. Add a mini-map overlay and a seed input to reproduce layouts. The HTML file should be self-contained with Three.js loaded from CDN and include all necessary shaders and textures inline. Save the output as 'procedural_city.html'.",
    "response": "```html\n<!-- Save this file as procedural_city.html and open in a modern browser -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Procedural City - Three.js</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      background: #000;\n      font-family: system-ui, sans-serif;\n      color: #eee;\n    }\n    #ui {\n      position: absolute;\n      top: 8px;\n      left: 8px;\n      z-index: 10;\n      background: rgba(0,0,0,0.6);\n      padding: 8px 10px;\n      border-radius: 4px;\n      font-size: 12px;\n      pointer-events: auto;\n    }\n    #ui input[type=\"number\"], #ui input[type=\"text\"] {\n      width: 80px;\n      font-size: 11px;\n    }\n    #ui button {\n      font-size: 11px;\n      padding: 2px 6px;\n      margin-left: 4px;\n      cursor: pointer;\n    }\n    #info {\n      margin-top: 4px;\n      font-size: 11px;\n      color: #ccc;\n    }\n    #miniMap {\n      position: absolute;\n      right: 8px;\n      bottom: 8px;\n      width: 200px;\n      height: 200px;\n      border: 1px solid #555;\n      box-sizing: border-box;\n      z-index: 9;\n      pointer-events: none; /* allow mouse through to main canvas */\n    }\n  </style>\n</head>\n<body>\n<div id=\"ui\">\n  <div>\n    Seed:\n    <input id=\"seedInput\" type=\"text\" value=\"12345\">\n    <button id=\"regenerateBtn\">Regenerate</button>\n  </div>\n  <div>\n    Day/Night:\n    <input id=\"timeSlider\" type=\"range\" min=\"0\" max=\"1\" step=\"0.001\" value=\"0\">\n    <span id=\"timeLabel\">Dawn</span>\n  </div>\n  <div id=\"info\">\n    Controls: WASD / RF to move, mouse to look, Shift = fast, Space = toggle free-fly lock<br>\n    Mini-map shows top-down view with camera marker.\n  </div>\n</div>\n<canvas id=\"miniMap\"></canvas>\n\n<!-- Three.js and controls from CDN -->\n<script src=\"https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/PointerLockControls.js\"></script>\n\n<script>\n(function () {\n  // Basic setup\n  const renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setPixelRatio(window.devicePixelRatio || 1);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.outputEncoding = THREE.sRGBEncoding;\n  document.body.appendChild(renderer.domElement);\n\n  const scene = new THREE.Scene();\n\n  const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000);\n  camera.position.set(0, 20, 60);\n\n  // Pointer lock free-fly controls\n  const controls = new THREE.PointerLockControls(camera, renderer.domElement);\n  let moveForward = false, moveBackward = false,\n      moveLeft = false, moveRight = false,\n      moveUp = false, moveDown = false;\n  let velocity = new THREE.Vector3();\n  let direction = new THREE.Vector3();\n  let isLocked = false;\n\n  function onKeyDown(event) {\n    switch (event.code) {\n      case 'KeyW': moveForward = true; break;\n      case 'KeyS': moveBackward = true; break;\n      case 'KeyA': moveLeft = true; break;\n      case 'KeyD': moveRight = true; break;\n      case 'KeyR': moveUp = true; break;\n      case 'KeyF': moveDown = true; break;\n      case 'ShiftLeft':\n      case 'ShiftRight': speedMultiplier = 4.0; break;\n      case 'Space':\n        // toggle lock\n        if (isLocked) controls.unlock();\n        else controls.lock();\n        break;\n    }\n  }\n  function onKeyUp(event) {\n    switch (event.code) {\n      case 'KeyW': moveForward = false; break;\n      case 'KeyS': moveBackward = false; break;\n      case 'KeyA': moveLeft = false; break;\n      case 'KeyD': moveRight = false; break;\n      case 'KeyR': moveUp = false; break;\n      case 'KeyF': moveDown = false; break;\n      case 'ShiftLeft':\n      case 'ShiftRight': speedMultiplier = 1.0; break;\n    }\n  }\n  document.addEventListener('keydown', onKeyDown);\n  document.addEventListener('keyup', onKeyUp);\n  controls.addEventListener('lock', () => { isLocked = true; });\n  controls.addEventListener('unlock', () => { isLocked = false; });\n\n  renderer.domElement.addEventListener('click', () => {\n    if (!isLocked) controls.lock();\n  });\n\n  let prevTime = performance.now();\n  let speedMultiplier = 1.0;\n\n  // Seedable PRNG\n  function LCG(seed) {\n    let a = 1664525, c = 1013904223, m = 4294967296;\n    let state = seed >>> 0;\n    return function() {\n      state = (a * state + c) % m;\n      return state / m;\n    };\n  }\n\n  function hashStringToInt(str) {\n    let h = 2166136261 >>> 0;\n    for (let i = 0; i < str.length; i++) {\n      h ^= str.charCodeAt(i);\n      h = Math.imul(h, 16777619);\n    }\n    return h >>> 0;\n  }\n\n  let rng = LCG(12345);\n\n  // City parameters\n  const citySize = 800;        // world size\n  const blocksX = 16;\n  const blocksZ = 16;\n  const roadWidth = 6;\n  const sidewalkWidth = 2;\n  const blockSpacingX = citySize / blocksX;\n  const blockSpacingZ = citySize / blocksZ;\n\n  const cityGroup = new THREE.Group();\n  scene.add(cityGroup);\n\n  // Materials\n  const buildingMaterial = new THREE.MeshStandardMaterial({\n    color: 0x808080,\n    roughness: 0.8,\n    metalness: 0.1\n  });\n\n  const glassMaterial = new THREE.MeshStandardMaterial({\n    color: 0x99ccff,\n    roughness: 0.1,\n    metalness: 0.8,\n    transparent: true,\n    opacity: 0.7,\n    envMapIntensity: 1.0\n  });\n\n  const roadMaterial = new THREE.MeshStandardMaterial({\n    color: 0x222222,\n    roughness: 1.0,\n    metalness: 0.0\n  });\n\n  const sidewalkMaterial = new THREE.MeshStandardMaterial({\n    color: 0x555555,\n    roughness: 0.9,\n    metalness: 0.0\n  });\n\n  const trafficLightMaterialRed = new THREE.MeshBasicMaterial({ color: 0x330000 });\n  const trafficLightMaterialYellow = new THREE.MeshBasicMaterial({ color: 0x332200 });\n  const trafficLightMaterialGreen = new THREE.MeshBasicMaterial({ color: 0x003300 });\n\n  const emissiveRed = new THREE.Color(0xff0000);\n  const emissiveYellow = new THREE.Color(0xffff00);\n  const emissiveGreen = new THREE.Color(0x00ff00);\n  const offColor = new THREE.Color(0x111111);\n\n  // Geometry reuse\n  const buildingGeom = new THREE.BoxGeometry(1, 1, 1);\n  const roadGeom = new THREE.PlaneGeometry(1, 1);\n  roadGeom.rotateX(-Math.PI / 2);\n\n  const sidewalkGeom = new THREE.PlaneGeometry(1, 1);\n  sidewalkGeom.rotateX(-Math.PI / 2);\n\n  const trafficPoleGeom = new THREE.BoxGeometry(0.2, 4, 0.2);\n  const trafficLightBoxGeom = new THREE.BoxGeometry(0.5, 0.5, 0.2);\n\n  let trafficLights = [];\n\n  // Ground plane\n  const groundGeo = new THREE.PlaneGeometry(citySize * 1.2, citySize * 1.2);\n  groundGeo.rotateX(-Math.PI / 2);\n  const groundMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 1.0 });\n  const ground = new THREE.Mesh(groundGeo, groundMat);\n  ground.receiveShadow = true;\n  scene.add(ground);\n\n  // Pseudo HDRI gradient sky using a big sphere with gradient shader\n  const skyGeo = new THREE.SphereGeometry(1000, 32, 32);\n  const skyMat = new THREE.ShaderMaterial({\n    side: THREE.BackSide,\n    uniforms: {\n      uTimeOfDay: { value: 0.0 } // 0 dawn, 0.25 day, 0.5 dusk, 0.75 night, 1=back to dawn\n    },\n    vertexShader: `\n      varying vec3 vWorldPosition;\n      void main() {\n        vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n        vWorldPosition = worldPosition.xyz;\n        gl_Position = projectionMatrix * viewMatrix * worldPosition;\n      }\n    `,\n    fragmentShader: `\n      varying vec3 vWorldPosition;\n      uniform float uTimeOfDay;\n\n      // simple smoothstep helper\n      float smooth01(float x) {\n        return smoothstep(0.0, 1.0, x);\n      }\n\n      void main() {\n        vec3 dir = normalize(vWorldPosition);\n        float h = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0); // horizon 0, zenith 1\n\n        // Key sky colors for different times\n        vec3 dawnHorizon = vec3(1.0, 0.45, 0.15);\n        vec3 dawnZenith  = vec3(0.25, 0.35, 0.6);\n\n        vec3 dayHorizon  = vec3(0.8, 0.9, 1.0);\n        vec3 dayZenith   = vec3(0.2, 0.5, 0.9);\n\n        vec3 duskHorizon = vec3(1.0, 0.3, 0.2);\n        vec3 duskZenith  = vec3(0.15, 0.2, 0.4);\n\n        vec3 nightHorizon= vec3(0.03, 0.03, 0.08);\n        vec3 nightZenith = vec3(0.0, 0.0, 0.02);\n\n        // Map uTimeOfDay (0..1) to phases: dawn(0), day(0.25), dusk(0.5), night(0.75..1)\n        float t = uTimeOfDay;\n        vec3 horizonColor;\n        vec3 zenithColor;\n\n        if (t < 0.25) {\n          // Dawn -> Day\n          float f = smooth01(t/0.25);\n          horizonColor = mix(dawnHorizon, dayHorizon, f);\n          zenithColor  = mix(dawnZenith,  dayZenith,  f);\n        } else if (t < 0.5) {\n          // Day -> Dusk\n          float f = smooth01((t-0.25)/0.25);\n          horizonColor = mix(dayHorizon, duskHorizon, f);\n          zenithColor  = mix(dayZenith,  duskZenith,  f);\n        } else if (t < 0.75) {\n          // Dusk -> Night\n          float f = smooth01((t-0.5)/0.25);\n          horizonColor = mix(duskHorizon, nightHorizon, f);\n          zenithColor  = mix(duskZenith,  nightZenith,  f);\n        } else {\n          // Night -> Dawn\n          float f = smooth01((t-0.75)/0.25);\n          horizonColor = mix(nightHorizon, dawnHorizon, f);\n          zenithColor  = mix(nightZenith,  dawnZenith,  f);\n        }\n\n        vec3 col = mix(horizonColor, zenithColor, h);\n        gl_FragColor = vec4(col, 1.0);\n      }\n    `\n  });\n  const sky = new THREE.Mesh(skyGeo, skyMat);\n  scene.add(sky);\n\n  // Lights for day/night\n  const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);\n  sunLight.position.set(100, 200, 100);\n  sunLight.castShadow = false;\n  scene.add(sunLight);\n\n  const ambientDay = new THREE.AmbientLight(0xffffff, 0.5);\n  scene.add(ambientDay);\n\n  const ambientNight = new THREE.AmbientLight(0x223366, 0.0);\n  scene.add(ambientNight);\n\n  // Some small \"window\" lights at night (simple emulation: emissive buildings)\n  let buildingMeshes = [];\n\n  function generateCity(seedStr) {\n    // Clear previous\n    while (cityGroup.children.length > 0) {\n      const obj = cityGroup.children.pop();\n      obj.traverse(o => {\n        if (o.geometry) o.geometry.dispose?.();\n        if (o.material) {\n          if (Array.isArray(o.material)) o.material.forEach(m => m.dispose?.());\n          else o.material.dispose?.();\n        }\n      });\n    }\n    trafficLights = [];\n    buildingMeshes = [];\n\n    const seedInt = hashStringToInt(seedStr || \"12345\");\n    rng = LCG(seedInt);\n\n    // Create grid of blocks\n    const halfCityX = citySize / 2;\n    const halfCityZ = citySize / 2;\n\n    for (let ix = 0; ix < blocksX; ix++) {\n      for (let iz = 0; iz < blocksZ; iz++) {\n        const centerX = -halfCityX + (ix + 0.5) * blockSpacingX;\n        const centerZ = -halfCityZ + (iz + 0.5) * blockSpacingZ;\n\n        // Roads along edges\n        // Make a big road tile for each X and Z row/column separately, overlapped\n\n        // Add north-south road (z direction) centered on block grid line.\n        if (iz === 0) {\n          // Build continuous road strip along X=grid line for this column\n          const roadStrip = new THREE.Mesh(\n            roadGeom.clone(),\n            roadMaterial\n          );\n          roadStrip.scale.set(roadWidth, 1, citySize);\n          roadStrip.position.set(centerX - blockSpacingX / 2, 0.01, 0);\n          roadStrip.receiveShadow = true;\n          cityGroup.add(roadStrip);\n        }\n        if (ix === 0) {\n          const roadStrip = new THREE.Mesh(\n            roadGeom.clone(),\n            roadMaterial\n          );\n          roadStrip.scale.set(citySize, 1, roadWidth);\n          roadStrip.position.set(0, 0.01, centerZ - blockSpacingZ / 2);\n          roadStrip.receiveShadow = true;\n          cityGroup.add(roadStrip);\n        }\n\n        // Add sidewalks around each block\n        const sidewalk = new THREE.Mesh(\n          sidewalkGeom.clone(),\n          sidewalkMaterial\n        );\n        sidewalk.scale.set(\n          blockSpacingX - roadWidth,\n          1,\n          blockSpacingZ - roadWidth\n        );\n        sidewalk.position.set(centerX, 0.02, centerZ);\n        sidewalk.receiveShadow = true;\n        cityGroup.add(sidewalk);\n\n        // Fill block with some buildings\n        const buildingCount = 3 + Math.floor(rng() * 5); // 3\u20137 buildings\n        for (let i = 0; i < buildingCount; i++) {\n          const relX = (rng() - 0.5) * (blockSpacingX - roadWidth - 4);\n          const relZ = (rng() - 0.5) * (blockSpacingZ - roadWidth - 4);\n\n          const baseWidth = 4 + rng() * 8;\n          const baseDepth = 4 + rng() * 8;\n          const height = 5 + rng() * 80;\n\n          const isGlass = rng() < 0.15;\n          const mat = isGlass ? glassMaterial.clone() : buildingMaterial.clone();\n\n          const building = new THREE.Mesh(buildingGeom.clone(), mat);\n          building.scale.set(baseWidth, height, baseDepth);\n          building.position.set(centerX + relX, height / 2, centerZ + relZ);\n          building.castShadow = true;\n          building.receiveShadow = true;\n          cityGroup.add(building);\n          buildingMeshes.push(building);\n        }\n\n        // Add traffic lights at intersection corners\n        const intersectionX = centerX - blockSpacingX / 2;\n        const intersectionZ = centerZ - blockSpacingZ / 2;\n\n        function addTrafficLight(x, z, rotY) {\n          const group = new THREE.Group();\n          group.position.set(x, 0, z);\n          group.rotation.y = rotY;\n\n          // pole\n          const pole = new THREE.Mesh(trafficPoleGeom.clone(),\n            new THREE.MeshStandardMaterial({ color: 0x333333 }));\n          pole.position.set(0, 2, 0);\n          group.add(pole);\n\n          // light box\n          const box = new THREE.Group();\n          box.position.set(0, 3.2, 0.4);\n\n          const redLight = new THREE.Mesh(trafficLightBoxGeom.clone(), trafficLightMaterialRed.clone());\n          redLight.position.set(0, 0.5, 0);\n          box.add(redLight);\n\n          const yellowLight = new THREE.Mesh(trafficLightBoxGeom.clone(), trafficLightMaterialYellow.clone());\n          yellowLight.position.set(0, 0.0, 0);\n          box.add(yellowLight);\n\n          const greenLight = new THREE.Mesh(trafficLightBoxGeom.clone(), trafficLightMaterialGreen.clone());\n          greenLight.position.set(0, -0.5, 0);\n          box.add(greenLight);\n\n          group.add(box);\n          cityGroup.add(group);\n\n          trafficLights.push({ red: redLight, yellow: yellowLight, green: greenLight });\n        }\n\n        // place 4 at each intersection (skip outer boundaries except once)\n        if (ix < blocksX && iz < blocksZ) {\n          const x = intersectionX;\n          const z = intersectionZ;\n          addTrafficLight(x + 2, z + 2, Math.PI);          // southeast\n          addTrafficLight(x - 2, z + 2, -Math.PI / 2);     // southwest\n          addTrafficLight(x + 2, z - 2, Math.PI / 2);      // northeast\n          addTrafficLight(x - 2, z - 2, 0);                // northwest\n        }\n      }\n    }\n  }\n\n  // Day/night cycle logic\n  const timeSlider = document.getElementById('timeSlider');\n  const timeLabel = document.getElementById('timeLabel');\n  let autoTime = true;\n  let timeOfDay = 0.0; // 0..1\n\n  timeSlider.addEventListener('input', () => {\n    autoTime = false;\n    timeOfDay = parseFloat(timeSlider.value);\n    updateTimeLabel();\n  });\n\n  function updateTimeLabel() {\n    const t = timeOfDay;\n    let label;\n    if (t < 0.125 || t > 0.875) label = \"Dawn\";\n    else if (t < 0.375) label = \"Day\";\n    else if (t < 0.625) label = \"Dusk\";\n    else label = \"Night\";\n    timeLabel.textContent = label;\n  }\n\n  function updateLighting() {\n    const t = timeOfDay;\n\n    // Map to sun elevation and intensity\n    const angle = (t) * Math.PI * 2; // full circle for simplicity\n    const radius = 200;\n    const sunY = Math.sin(angle) * radius;\n    const sunX = Math.cos(angle) * radius;\n    const sunZ = Math.cos(angle * 0.5) * radius;\n    sunLight.position.set(sunX, sunY, sunZ);\n    sunLight.target.position.set(0, 0, 0);\n    sunLight.target.updateMatrixWorld();\n\n    let sunIntensity, ambientDayIntensity, ambientNightIntensity;\n\n    if (t < 0.25) {\n      // dawn\n      const f = t / 0.25;\n      sunIntensity = 0.1 + 0.9 * f;\n      ambientDayIntensity = 0.1 + 0.4 * f;\n      ambientNightIntensity = 0.3 * (1.0 - f);\n    } else if (t < 0.5) {\n      // day\n      const f = (t - 0.25) / 0.25;\n      sunIntensity = 1.0;\n      ambientDayIntensity = 0.5;\n      ambientNightIntensity = 0.0;\n    } else if (t < 0.75) {\n      // dusk\n      const f = (t - 0.5) / 0.25;\n      sunIntensity = 1.0 - 0.9 * f;\n      ambientDayIntensity = 0.5 - 0.4 * f;\n      ambientNightIntensity = 0.3 * f;\n    } else {\n      // night\n      const f = (t - 0.75) / 0.25;\n      sunIntensity = 0.1 * (1.0 - f);\n      ambientDayIntensity = 0.1 * (1.0 - f);\n      ambientNightIntensity = 0.3 + 0.2 * f;\n    }\n\n    sunLight.intensity = sunIntensity;\n    ambientDay.intensity = ambientDayIntensity;\n    ambientNight.intensity = ambientNightIntensity;\n\n    sky.material.uniforms.uTimeOfDay.value = t;\n\n    // Buildings emissive windows at night\n    const nightFactor = THREE.MathUtils.clamp((t > 0.6 && t < 0.9) ? (t - 0.6) / 0.3 :\n                     (t >= 0.9 || t <= 0.1) ? 1.0 : 0.0, 0, 1);\n    buildingMeshes.forEach((b, idx) => {\n      if (!b.material || !('emissive' in b.material)) return;\n      if (nightFactor > 0.01) {\n        const r = (idx * 16807) % 97;\n        const on = (r % 3 !== 0); // some off\n        if (on) {\n          b.material.emissive = new THREE.Color(0xffeeaa).multiplyScalar(0.7 * nightFactor);\n        } else {\n          b.material.emissive = new THREE.Color(0x000000);\n        }\n      } else {\n        b.material.emissive = new THREE.Color(0x000000);\n      }\n    });\n  }\n\n  // Traffic light animation\n  function updateTrafficLights(elapsedMs) {\n    const cycle = 12000; // 12 sec full cycle\n    const t = (elapsedMs % cycle) / cycle; // 0..1\n    // simple model: 0-0.45 green, 0.45-0.6 yellow, 0.6-0.95 red, 0.95-1.0 yellow\n    let state;\n    if (t < 0.45) state = \"green\";\n    else if (t < 0.6) state = \"yellow\";\n    else if (t < 0.95) state = \"red\";\n    else state = \"yellow\";\n\n    trafficLights.forEach(l => {\n      l.red.material.color.copy(new THREE.Color(0x330000));\n      l.yellow.material.color.copy(new THREE.Color(0x332200));\n      l.green.material.color.copy(new THREE.Color(0x003300));\n      if (state === \"red\") {\n        l.red.material.color.copy(emissiveRed);\n      } else if (state === \"yellow\") {\n        l.yellow.material.color.copy(emissiveYellow);\n      } else if (state === \"green\") {\n        l.green.material.color.copy(emissiveGreen);\n      }\n    });\n  }\n\n  // Mini-map: secondary orthographic camera rendered to separate canvas\n  const miniMapCanvas = document.getElementById('miniMap');\n  const miniMapRenderer = new THREE.WebGLRenderer({\n    canvas: miniMapCanvas,\n    antialias: true,\n    alpha: true\n  });\n  miniMapRenderer.setPixelRatio(window.devicePixelRatio || 1);\n  miniMapRenderer.setSize(miniMapCanvas.clientWidth, miniMapCanvas.clientHeight);\n  miniMapRenderer.setClearColor(0x000000, 0.0);\n\n  const miniMapSize = citySize * 0.6;\n  const miniCam = new THREE.OrthographicCamera(\n    -miniMapSize / 2, miniMapSize / 2,\n    miniMapSize / 2, -miniMapSize / 2,\n    1, 2000\n  );\n  miniCam.position.set(0, 600, 0);\n  miniCam.lookAt(0, 0, 0);\n  scene.add(miniCam);\n\n  // Helper: camera marker in minimap\n  const camMarkerGeom = new THREE.ConeGeometry(4, 10, 8);\n  const camMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n  const camMarker = new THREE.Mesh(camMarkerGeom, camMarkerMat);\n  camMarker.rotation.x = Math.PI * 0.5;\n  scene.add(camMarker);\n\n  function updateMiniMap() {\n    // Position marker at camera XZ\n    camMarker.position.set(camera.position.x, 3, camera.position.z);\n    // orient to camera heading in XZ plane\n    const dir = new THREE.Vector3();\n    camera.getWorldDirection(dir);\n    const angle = Math.atan2(dir.x, dir.z);\n    camMarker.rotation.y = angle;\n\n    miniMapRenderer.render(scene, miniCam);\n  }\n\n  // UI: seed & regenerate\n  const seedInput = document.getElementById('seedInput');\n  const regenerateBtn = document.getElementById('regenerateBtn');\n  regenerateBtn.addEventListener('click', () => {\n    generateCity(seedInput.value.trim() || \"12345\");\n  });\n\n  // Initial city\n  generateCity(seedInput.value);\n\n  // Resize handling\n  window.addEventListener('resize', () => {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n\n    miniMapRenderer.setSize(miniMapCanvas.clientWidth, miniMapCanvas.clientHeight);\n  });\n\n  // Main render loop\n  function animate() {\n    requestAnimationFrame(animate);\n\n    const currentTime = performance.now();\n    const delta = (currentTime - prevTime) / 1000;\n    prevTime = currentTime;\n\n    if (autoTime) {\n      // auto cycle: full day = 2 real-time minutes\n      const dayLength = 120000; // ms\n      timeOfDay = ((currentTime % dayLength) / dayLength);\n      timeSlider.value = timeOfDay.toFixed(3);\n      updateTimeLabel();\n    }\n    updateLighting();\n    updateTrafficLights(currentTime);\n\n    // Free-fly movement\n    if (isLocked) {\n      velocity.x -= velocity.x * 10.0 * delta;\n      velocity.y -= velocity.y * 10.0 * delta;\n      velocity.z -= velocity.z * 10.0 * delta;\n\n      direction.z = Number(moveForward) - Number(moveBackward);\n      direction.x = Number(moveRight) - Number(moveLeft);\n      direction.y = Number(moveUp) - Number(moveDown);\n      direction.normalize();\n\n      const speed = 60.0 * speedMultiplier;\n      if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;\n      if (moveLeft || moveRight)       velocity.x -= direction.x * speed * delta;\n      if (moveUp || moveDown)         velocity.y -= direction.y * speed * delta;\n\n      controls.moveRight(-velocity.x * delta);\n      controls.moveForward(-velocity.z * delta);\n      camera.position.y += velocity.y * delta;\n    }\n\n    sky.position.copy(camera.position); // keep sky centered\n\n    renderer.render(scene, camera);\n    updateMiniMap();\n  }\n\n  animate();\n})();\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 41.8119900226593,
    "status": "success",
    "timestamp": "2025-11-19 22:06:30",
    "evaluation": {
      "test_name": "procedural_city_generator",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "THREE.PointerLockControls is not a constructor"
        ],
        "warnings": [
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/PointerLockControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/PointerLockControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation",
          "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
          "[.WebGL-0x134001cc400]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x134001cc400]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x134001cc400]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x134001cc400]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat)"
        ],
        "screenshot": "output/screenshots/procedural_city_generator.png",
        "render_time_ms": 727.35,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 727.35ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "THREE.PointerLockControls is not a constructor"
            ]
          },
          {
            "level": "warning",
            "message": "\u26a0\ufe0f  10 warning(s)"
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "The code provided is incomplete, stopping abruptly at 'const re' in the script section. It fails to fulfill several key requirements from the original request. There is no completed JavaScript logic for generating a procedural 3D city, handling a day/night cycle with HDRI sky, traffic light animations, and a free-fly camera. Additionally, the code does not inline necessary shaders and textures, and it lacks implementation for features such as a mini-map overlay and a seed input to reproduce layouts beyond a basic UI. Hence, it does not meet many of the fundamental aspects specified in the task.",
        "strengths": "The HTML and CSS structure is initializer set up for UI elements, and a CDN for Three.js and PointerLockControls is correctly added. The UI components have a planned layout for seed regeneration and day/night cycle control.",
        "weaknesses": "The JavaScript section is incomplete, hence failing to implement essential features such as procedural city generation, day/night cycle, HDRI sky, animations, and camera controls. Critical features of the request are unfulfilled, and the code quality is low due to incomplete logic and syntax.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "terrain_flight_mode",
    "prompt": "Create a complete HTML file with Three.js that generates procedural terrain using heightmaps or Perlin noise with rivers, trees (instanced meshes), and LOD. Add a simple 'drone/plane' controller to fly above terrain with pitch/roll/yaw, speed boost, and collision avoidance. The HTML file should be self-contained with Three.js loaded from CDN and include all terrain generation code inline. Save the output as 'terrain_flight.html'.",
    "response": "```html\n<!-- Save this file as: terrain_flight.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Three.js Procedural Terrain Flight Demo</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      width: 100%;\n      height: 100%;\n      background: #000;\n      font-family: sans-serif;\n      color: #fff;\n    }\n    #info {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      padding: 8px 12px;\n      background: rgba(0,0,0,0.5);\n      font-size: 13px;\n      z-index: 10;\n      max-width: 360px;\n      line-height: 1.4em;\n    }\n    a { color: #8cf; }\n  </style>\n</head>\n<body>\n<div id=\"info\">\n  <b>Procedural Terrain Flight</b><br>\n  Controls:<br>\n  W/S: Pitch down/up<br>\n  A/D: Roll left/right<br>\n  Q/E: Yaw left/right<br>\n  Shift: Speed boost<br>\n  R/F: Move up/down (vertical trim)<br>\n  Space: Level wings & slight auto-level<br>\n  Mouse drag: Look around (camera offset)<br>\n  Collision avoidance keeps you above ground.<br>\n</div>\n\n<script type=\"module\">\n  import * as THREE from \"https://unpkg.com/three@0.160.0/build/three.module.js\";\n  import { OrbitControls } from \"https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js\";\n\n  // ---------------------------\n  // Basic setup\n  // ---------------------------\n  const renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  document.body.appendChild(renderer.domElement);\n\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x88ccee);\n  scene.fog = new THREE.Fog(0x88ccee, 300, 2000);\n\n  const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);\n  camera.position.set(0, 80, 200);\n\n  // Optional: OrbitControls to look around when not flying\n  const orbit = new OrbitControls(camera, renderer.domElement);\n  orbit.enabled = false; // we will use custom flight camera\n\n  // Lighting\n  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x446688, 0.7);\n  hemiLight.position.set(0, 1, 0);\n  scene.add(hemiLight);\n\n  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);\n  dirLight.position.set(-200, 300, 100);\n  dirLight.castShadow = false;\n  scene.add(dirLight);\n\n  // ---------------------------\n  // Simple Perlin Noise (Improved) implementation\n  // ---------------------------\n  const ImprovedNoise = function () {\n    const p = new Uint8Array(256);\n    for (let i = 0; i < 256; i++) p[i] = i;\n    // shuffle\n    for (let i = 255; i > 0; i--) {\n      const n = Math.floor((i + 1) * Math.random());\n      const q = p[i];\n      p[i] = p[n];\n      p[n] = q;\n    }\n    const perm = new Uint8Array(512);\n    for (let i = 0; i < 512; i++) perm[i] = p[i & 255];\n\n    function fade(t) {\n      return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n    function lerp(t, a, b) {\n      return a + t * (b - a);\n    }\n    function grad(hash, x, y, z) {\n      const h = hash & 15;\n      const u = h < 8 ? x : y;\n      const v = h < 4 ? y : h === 12 || h === 14 ? x : z;\n      return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n    }\n    return {\n      noise(x, y, z) {\n        let X = Math.floor(x) & 255;\n        let Y = Math.floor(y) & 255;\n        let Z = Math.floor(z) & 255;\n\n        x -= Math.floor(x);\n        y -= Math.floor(y);\n        z -= Math.floor(z);\n\n        const u = fade(x);\n        const v = fade(y);\n        const w = fade(z);\n\n        const A = perm[X] + Y;\n        const AA = perm[A] + Z;\n        const AB = perm[A + 1] + Z;\n        const B = perm[X + 1] + Y;\n        const BA = perm[B] + Z;\n        const BB = perm[B + 1] + Z;\n\n        return lerp(\n          w,\n          lerp(\n            v,\n            lerp(\n              u,\n              grad(perm[AA], x, y, z),\n              grad(perm[BA], x - 1, y, z)\n            ),\n            lerp(\n              u,\n              grad(perm[AB], x, y - 1, z),\n              grad(perm[BB], x - 1, y - 1, z)\n            )\n          ),\n          lerp(\n            v,\n            lerp(\n              u,\n              grad(perm[AA + 1], x, y, z - 1),\n              grad(perm[BA + 1], x - 1, y, z - 1)\n            ),\n            lerp(\n              u,\n              grad(perm[AB + 1], x, y - 1, z - 1),\n              grad(perm[BB + 1], x - 1, y - 1, z - 1)\n            )\n          )\n        );\n      }\n    };\n  };\n\n  const perlin = new ImprovedNoise();\n  const noiseSeed = Math.random() * 10;\n\n  function fbm(x, z, octaves = 5, lacunarity = 2.0, gain = 0.5) {\n    let amp = 1.0;\n    let freq = 0.0025;\n    let sum = 0.0;\n    let max = 0.0;\n    for (let i = 0; i < octaves; i++) {\n      sum += amp * perlin.noise(x * freq + noiseSeed, z * freq + noiseSeed, noiseSeed);\n      max += amp;\n      amp *= gain;\n      freq *= lacunarity;\n    }\n    return sum / max; // -1..1\n  }\n\n  // ---------------------------\n  // Terrain generation with LOD (simple chunk system)\n  // ---------------------------\n  const WORLD_SIZE = 4000;\n  const CHUNK_SIZE = 256;\n  const CHUNK_RES = 128; // segments per side for each chunk\n  const HALF_WORLD = WORLD_SIZE / 2;\n\n  // Height function with river\n  function getHeight(x, z) {\n    // base terrain\n    const hBase = fbm(x, z, 5, 2.0, 0.55);\n    let h = hBase * 180; // scale\n\n    // define river along a gentle curve: near function f(x,z) = z - 0.3*x*sin(0.0007*x)\n    const riverCenter = 0.3 * Math.sin(x * 0.0007) * 600;\n    const distToRiver = Math.abs(z - riverCenter);\n    const riverWidth = 40;\n    const riverBank = 120;\n\n    if (distToRiver < riverBank) {\n      // lower terrain near river using smooth step\n      const t = THREE.MathUtils.smoothstep(distToRiver, 0, riverBank);\n      h = THREE.MathUtils.lerp(5, h, t); // near center -> low, far -> original\n    }\n\n    return h;\n  }\n\n  // Precompute a world height sampler on a grid to speed up collision & tree placement\n  const SAMPLE_RES = 1024;\n  const heightMap = [];\n  for (let zi = 0; zi < SAMPLE_RES; zi++) {\n    heightMap[zi] = new Float32Array(SAMPLE_RES);\n  }\n  const sampleStep = WORLD_SIZE / (SAMPLE_RES - 1);\n  for (let zi = 0; zi < SAMPLE_RES; zi++) {\n    const z = -HALF_WORLD + zi * sampleStep;\n    for (let xi = 0; xi < SAMPLE_RES; xi++) {\n      const x = -HALF_WORLD + xi * sampleStep;\n      heightMap[zi][xi] = getHeight(x, z);\n    }\n  }\n\n  function sampleHeightBilinear(x, z) {\n    // clamp to world bounds\n    x = THREE.MathUtils.clamp(x, -HALF_WORLD, HALF_WORLD);\n    z = THREE.MathUtils.clamp(z, -HALF_WORLD, HALF_WORLD);\n\n    const fx = (x + HALF_WORLD) / sampleStep;\n    const fz = (z + HALF_WORLD) / sampleStep;\n    const x0 = Math.floor(fx);\n    const z0 = Math.floor(fz);\n    const x1 = Math.min(x0 + 1, SAMPLE_RES - 1);\n    const z1 = Math.min(z0 + 1, SAMPLE_RES - 1);\n    const tx = fx - x0;\n    const tz = fz - z0;\n\n    const h00 = heightMap[z0][x0];\n    const h10 = heightMap[z0][x1];\n    const h01 = heightMap[z1][x0];\n    const h11 = heightMap[z1][x1];\n\n    const h0 = h00 * (1 - tx) + h10 * tx;\n    const h1 = h01 * (1 - tx) + h11 * tx;\n    return h0 * (1 - tz) + h1 * tz;\n  }\n\n  // Terrain material\n  const terrainMaterial = new THREE.MeshStandardMaterial({\n    color: 0x668855,\n    roughness: 1.0,\n    metalness: 0.0,\n    flatShading: true\n  });\n\n  // River material\n  const riverMaterial = new THREE.MeshStandardMaterial({\n    color: 0x2266aa,\n    roughness: 0.1,\n    metalness: 0.2,\n    transparent: true,\n    opacity: 0.8\n  });\n\n  // LOD chunks\n  const chunks = [];\n  const chunkGeometryCache = {};\n\n  function getChunkGeometry(resolution) {\n    if (chunkGeometryCache[resolution]) return chunkGeometryCache[resolution];\n    const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, resolution, resolution);\n    geo.rotateX(-Math.PI / 2);\n    chunkGeometryCache[resolution] = geo;\n    return geo;\n  }\n\n  function updateChunkHeights(mesh, cx, cz, resolution) {\n    const geo = mesh.geometry;\n    const pos = geo.attributes.position;\n    const vCount = pos.count;\n    const segX = resolution;\n    const segZ = resolution;\n    for (let i = 0; i < vCount; i++) {\n      const ix = i % (segX + 1);\n      const iz = Math.floor(i / (segX + 1));\n      const x = (ix / segX - 0.5) * CHUNK_SIZE + cx;\n      const z = (iz / segZ - 0.5) * CHUNK_SIZE + cz;\n      const y = sampleHeightBilinear(x, z);\n      pos.setY(i, y);\n    }\n    pos.needsUpdate = true;\n    geo.computeVertexNormals();\n  }\n\n  function createChunk(cx, cz) {\n    // Multiple LOD levels: near=64, mid=32, far=16 segments\n    const lod = new THREE.LOD();\n    const resLevels = [\n      { res: 64, dist: 0 },\n      { res: 32, dist: 600 },\n      { res: 16, dist: 1200 }\n    ];\n    for (const level of resLevels) {\n      const geo = getChunkGeometry(level.res);\n      const mesh = new THREE.Mesh(geo.clone(), terrainMaterial);\n      mesh.castShadow = false;\n      mesh.receiveShadow = true;\n      updateChunkHeights(mesh, cx, cz, level.res);\n      lod.addLevel(mesh, level.dist);\n    }\n    lod.position.set(cx, 0, cz);\n    scene.add(lod);\n    return lod;\n  }\n\n  // Generate all chunks in a grid\n  const chunksPerSide = WORLD_SIZE / CHUNK_SIZE;\n  for (let zi = 0; zi < chunksPerSide; zi++) {\n    for (let xi = 0; xi < chunksPerSide; xi++) {\n      const cx = -HALF_WORLD + CHUNK_SIZE * (xi + 0.5);\n      const cz = -HALF_WORLD + CHUNK_SIZE * (zi + 0.5);\n      const lod = createChunk(cx, cz);\n      chunks.push(lod);\n    }\n  }\n\n  // ---------------------------\n  // River mesh (follow same height map, but flattened)\n  // ---------------------------\n  // We create one large plane at low Y and mask heights near river path\n  (function createRiverMesh() {\n    const riverGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 512, 512);\n    riverGeo.rotateX(-Math.PI / 2);\n    const pos = riverGeo.attributes.position;\n    const vCount = pos.count;\n\n    for (let i = 0; i < vCount; i++) {\n      const x = pos.getX(i);\n      const z = pos.getZ(i);\n\n      const riverCenter = 0.3 * Math.sin(x * 0.0007) * 600;\n      const distToRiver = Math.abs(z - riverCenter);\n      const riverWidth = 35;\n      const riverBank = 120;\n\n      if (distToRiver < riverWidth) {\n        // place water slightly above terrain at that point\n        const ground = sampleHeightBilinear(x, z);\n        pos.setY(i, ground + 1.0);\n      } else if (distToRiver < riverBank) {\n        // fade banks into ground (avoid harsh edges)\n        const ground = sampleHeightBilinear(x, z);\n        const t = THREE.MathUtils.smoothstep(distToRiver, riverWidth, riverBank);\n        const y = THREE.MathUtils.lerp(ground + 1.0, ground - 10, t);\n        pos.setY(i, y);\n      } else {\n        // hide far away vertices by dropping them under ground\n        const ground = sampleHeightBilinear(x, z);\n        pos.setY(i, ground - 50);\n      }\n    }\n    pos.needsUpdate = true;\n    riverGeo.computeVertexNormals();\n\n    const riverMesh = new THREE.Mesh(riverGeo, riverMaterial);\n    riverMesh.receiveShadow = true;\n    scene.add(riverMesh);\n  })();\n\n  // ---------------------------\n  // Trees (Instanced Mesh)\n  // ---------------------------\n  const TREE_COUNT = 6000;\n  const trunkGeo = new THREE.CylinderGeometry(0.4, 0.8, 6, 6);\n  const foliageGeo = new THREE.ConeGeometry(3.2, 10, 8);\n  foliageGeo.translate(0, 8, 0);\n\n  const treeGeo = THREE.BufferGeometryUtils\n    ? THREE.BufferGeometryUtils.mergeBufferGeometries([trunkGeo, foliageGeo])\n    : (function () {\n        // simple manual merge if BufferGeometryUtils missing\n        const g1 = trunkGeo.clone();\n        const g2 = foliageGeo.clone();\n        const merged = new THREE.BufferGeometry();\n\n        function mergeGeometries(geos) {\n          const geometries = geos.map(g => g.toNonIndexed());\n          let totalVertices = 0;\n          for (const g of geometries) totalVertices += g.attributes.position.count;\n\n          const position = new Float32Array(totalVertices * 3);\n          const normal = new Float32Array(totalVertices * 3);\n          let offset = 0;\n\n          for (const g of geometries) {\n            const pos = g.attributes.position;\n            const norm = g.attributes.normal;\n            for (let i = 0; i < pos.count; i++) {\n              position[3 * (offset + i) + 0] = pos.getX(i);\n              position[3 * (offset + i) + 1] = pos.getY(i);\n              position[3 * (offset + i) + 2] = pos.getZ(i);\n              normal[3 * (offset + i) + 0] = norm.getX(i);\n              normal[3 * (offset + i) + 1] = norm.getY(i);\n              normal[3 * (offset + i) + 2] = norm.getZ(i);\n            }\n            offset += pos.count;\n          }\n\n          merged.setAttribute(\"position\", new THREE.BufferAttribute(position, 3));\n          merged.setAttribute(\"normal\", new THREE.BufferAttribute(normal, 3));\n          return merged;\n        }\n\n        return mergeGeometries([g1, g2]);\n      })();\n\n  const treeMaterial = new THREE.MeshStandardMaterial({\n    color: 0x2e5c1a,\n    roughness: 1.0,\n    metalness: 0.0,\n    flatShading: true\n  });\n\n  const trees = new THREE.InstancedMesh(treeGeo, treeMaterial, TREE_COUNT);\n  trees.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n  scene.add(trees);\n\n  (function scatterTrees() {\n    const dummy = new THREE.Object3D();\n    let i = 0;\n    while (i < TREE_COUNT) {\n      const x = (Math.random() - 0.5) * WORLD_SIZE;\n      const z = (Math.random() - 0.5) * WORLD_SIZE;\n      const riverCenter = 0.3 * Math.sin(x * 0.0007) * 600;\n      const distToRiver = Math.abs(z - riverCenter);\n      const riverWidth = 50;\n      if (distToRiver < riverWidth + 20) continue; // keep near-river clear\n\n      const h = sampleHeightBilinear(x, z);\n      if (h < 8 || h > 150) continue; // avoid too low (water) or too high peaks\n\n      dummy.position.set(x, h, z);\n      const s = 0.8 + Math.random() * 0.7;\n      dummy.scale.set(s, s, s);\n      dummy.rotation.y = Math.random() * Math.PI * 2;\n      dummy.updateMatrix();\n      trees.setMatrixAt(i, dummy.matrix);\n      i++;\n    }\n    trees.instanceMatrix.needsUpdate = true;\n  })();\n\n  // ---------------------------\n  // Drone / Plane Controller\n  // ---------------------------\n  const drone = new THREE.Object3D();\n  scene.add(drone);\n\n  // Simple plane model\n  const bodyGeo = new THREE.BoxGeometry(6, 1.2, 18);\n  const wingGeo = new THREE.BoxGeometry(20, 0.4, 3);\n  wingGeo.translate(0, 0, 0);\n  const tailGeo = new THREE.BoxGeometry(4, 0.6, 4);\n  tailGeo.translate(0, 1.2, -8);\n  const cockpitGeo = new THREE.ConeGeometry(2.5, 4, 12);\n  cockpitGeo.rotateX(Math.PI / 2);\n  cockpitGeo.translate(0, 0.7, 7.5);\n\n  const planeMat = new THREE.MeshStandardMaterial({\n    color: 0xffffff,\n    roughness: 0.4,\n    metalness: 0.3\n  });\n\n  const planeParts = [\n    new THREE.Mesh(bodyGeo, planeMat),\n    new THREE.Mesh(wingGeo, planeMat),\n    new THREE.Mesh(tailGeo, planeMat),\n    new THREE.Mesh(cockpitGeo, new THREE.MeshStandardMaterial({ color: 0x6699ff, roughness: 0.1, metalness: 0.8 }))\n  ];\n  planeParts.forEach(m => {\n    m.castShadow = true;\n    m.receiveShadow = true;\n    drone.add(m);\n  });\n\n  drone.position.set(0, 120, 0);\n  drone.rotation.order = \"YXZ\";\n  drone.lookAt(new THREE.Vector3(0, 110, -100));\n  drone.userData.velocity = new THREE.Vector3(0, 0, -120); // forward in local space\n\n  // Camera offset relative to drone\n  const cameraOffset = new THREE.Vector3(0, 4.5, 18);\n  const cameraLookOffset = new THREE.Vector3(0, 1.5, -20);\n\n  // Input\n  const keys = {};\n  window.addEventListener(\"keydown\", e => { keys[e.code] = true; });\n  window.addEventListener(\"keyup\", e => { keys[e.code] = false; });\n\n  // Mouse look\n  let isMouseDown = false;\n  let lastMouseX = 0;\n  let lastMouseY = 0;\n  let yawOffset = 0;\n  let pitchOffset = 0;\n  window.addEventListener(\"mousedown\", e => {\n    isMouseDown = true;\n    lastMouseX = e.clientX;\n    lastMouseY = e.clientY;\n  });\n  window.addEventListener(\"mouseup\", () => { isMouseDown = false; });\n  window.addEventListener(\"mousemove\", e => {\n    if (!isMouseDown) return;\n    const dx = e.clientX - lastMouseX;\n    const dy = e.clientY - lastMouseY;\n    lastMouseX = e.clientX;\n    lastMouseY = e.clientY;\n    yawOffset -= dx * 0.002;\n    pitchOffset -= dy * 0.002;\n    pitchOffset = THREE.MathUtils.clamp(pitchOffset, -0.7, 0.7);\n  });\n\n  // Flight parameters\n  let baseSpeed = 80;\n  let maxSpeed = 420;\n  let acceleration = 40;\n  let deceleration = 25;\n  let currentSpeed = baseSpeed;\n\n  let rollSpeed = 1.6;\n  let pitchSpeed = 1.4;\n  let yawSpeed = 1.2;\n\n  const tmpVec3 = new THREE.Vector3();\n  const tmpEuler = new THREE.Euler(0, 0, 0, \"YXZ\");\n\n  // ---------------------------\n  // Animation loop\n  // ---------------------------\n  const clock = new THREE.Clock();\n\n  function animate() {\n    requestAnimationFrame(animate);\n    const dt = clock.getDelta();\n\n    updateFlight(dt);\n    renderer.render(scene, camera);\n  }\n\n  function updateFlight(dt) {\n    // speed control\n    const boosting = !!keys[\"ShiftLeft\"] || !!keys[\"ShiftRight\"];\n    const targetSpeed = boosting ? maxSpeed : baseSpeed;\n    if (currentSpeed < targetSpeed) {\n      currentSpeed = Math.min(targetSpeed, currentSpeed + acceleration * dt * (boosting ? 2.0 : 1.0));\n    } else {\n      currentSpeed = Math.max(targetSpeed, currentSpeed - deceleration * dt);\n    }\n\n    // rotation input\n    let pitchInput = 0;\n    let rollInput = 0;\n    let yawInput = 0;\n    if (keys[\"KeyW\"]) pitchInput -= 1;\n    if (keys[\"KeyS\"]) pitchInput += 1;\n    if (keys[\"KeyA\"]) rollInput += 1;\n    if (keys[\"KeyD\"]) rollInput -= 1;\n    if (keys[\"KeyQ\"]) yawInput += 1;\n    if (keys[\"KeyE\"]) yawInput -= 1;\n\n    // small auto-stabilization\n    const autoLevel = !keys[\"KeyA\"] && !keys[\"KeyD\"];\n    if (autoLevel) {\n      drone.rotation.z *= (1 - Math.min(2.0 * dt, 1.0)); // damp roll\n    }\n\n    // spacebar: quickly level\n    if (keys[\"Space\"]) {\n      drone.rotation.z = THREE.MathUtils.lerp(drone.rotation.z, 0, 6.0 * dt);\n      drone.rotation.x = THREE.MathUtils.lerp(drone.rotation.x, 0, 3.0 * dt);\n    }\n\n    // apply rotations (ZYX rotation order)\n    tmpEuler.setFromQuaternion(drone.quaternion, \"YXZ\");\n    tmpEuler.x += pitchInput * pitchSpeed * dt;\n    tmpEuler.z += rollInput * rollSpeed * dt;\n    tmpEuler.y += yawInput * yawSpeed * dt;\n\n    // clamp pitch\n    tmpEuler.x = THREE.MathUtils.clamp(tmpEuler.x, -1.2, 1.2);\n\n    drone.quaternion.setFromEuler(tmpEuler);\n\n    // compute forward direction and move\n    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(drone.quaternion);\n    const move = forward.multiplyScalar(currentSpeed * dt);\n    drone.position.add(move);\n\n    // vertical trim R/F\n    if (keys[\"KeyR\"]) drone.position.y += 60 * dt;\n    if (keys[\"KeyF\"]) drone.position.y -= 60 * dt;\n\n    // keep drone within world bounds\n    drone.position.x = THREE.MathUtils.clamp(drone.position.x, -HALF_WORLD + 20, HALF_WORLD - 20);\n    drone.position.z = THREE.MathUtils.clamp(drone.position.z, -HALF_WORLD + 20, HALF_WORLD - 20);\n\n    // collision avoidance with terrain\n    const ground = sampleHeightBilinear(drone.position.x, drone.position.z);\n    const minAltitude = 20;\n    const desiredY = ground + minAltitude;\n    if (drone.position.y < desiredY) {\n      drone.position.y = THREE.MathUtils.lerp(drone.position.y, desiredY, 8.0 * dt);\n    }\n\n    // camera follow\n    const camOffsetWorld = cameraOffset.clone().applyQuaternion(drone.quaternion);\n    const camPos = drone.position.clone().add(camOffsetWorld);\n    camera.position.copy(camPos);\n\n    // camera look at point ahead\n    const lookDir = new THREE.Vector3(0, 0, -1)\n      .applyQuaternion(drone.quaternion)\n      .multiplyScalar(20);\n    const lookTarget = drone.position.clone().add(lookDir).add(new THREE.Vector3(0, 4, 0));\n\n    // apply mouse yaw/pitch offsets\n    const offsetEuler = new THREE.Euler(pitchOffset, yawOffset, 0, \"YXZ\");\n    const offsetDir = lookTarget.clone().sub(camera.position).applyEuler(offsetEuler);\n    const finalLook = camera.position.clone().add(offsetDir);\n\n    camera.lookAt(finalLook);\n\n    // Optional: update LOD with camera position\n    for (const lod of chunks) {\n      lod.update(camera);\n    }\n  }\n\n  // resize\n  window.addEventListener(\"resize\", () => {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  });\n\n  animate();\n</script>\n\n<!-- Note:\n  For best performance, use a modern browser with WebGL2 support.\n  World size, resolution, and counts can be tuned near the top of the script.\n-->\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 35.32241106033325,
    "status": "success",
    "timestamp": "2025-11-19 22:07:12",
    "evaluation": {
      "test_name": "terrain_flight_mode",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
        ],
        "warnings": [],
        "screenshot": "output/screenshots/terrain_flight_mode.png",
        "render_time_ms": 708.62,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 708.62ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
            ]
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "The evaluated code snippet is incomplete and does not fulfill the original request requirements. The request was to create a complete HTML file with procedural terrain generated using Three.js, with features like rivers, trees, Level of Detail (LOD) management, and a 'drone/plane' controller for navigation. The provided code only includes the basic setup for a Three.js scene with camera, renderer, and OrbitControls, and is missing significant portions, such as the procedural terrain generation using heightmaps or Perlin noise, the creation of rivers or trees, the implementation of LOD, and the custom drone/plane controller. Additionally, the code is cut off and not functional or executable in its current state.",
        "strengths": "The code has a well-structured basic setup for a Three.js scene, including the use of a WebGLRenderer, scene setup, camera configuration, and basic styling for full-window rendering. It adheres to modern standards, using ES6 module imports for Three.js and OrbitControls.",
        "weaknesses": "The code does not fulfill critical requirements of the original task, such as generating procedural terrain, implementing rivers, trees with instanced meshes, LOD, and a drone/plane controller. It is incomplete and lacks functionality. There are also no collision avoidance or speed boost features implemented, which were specifically requested.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "product_configurator",
    "prompt": "Create a complete HTML file with Three.js that implements a 3D product configurator. Create a 3D model (like a car, chair, or phone) with color, material, texture, and part toggles. Add environment reflections, soft shadows, and camera bookmarks. Include export current config as JSON and PNG snapshot functionality. The HTML file should be self-contained with Three.js loaded from CDN and include all 3D models as procedural geometry. Save the output as 'product_configurator.html'.",
    "response": "```html\n<!-- Save this file as: product_configurator.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>3D Product Configurator - Three.js</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      font-family: system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif;\n      background: #121212;\n      color: #eee;\n    }\n\n    #container {\n      position: absolute;\n      inset: 0;\n      overflow: hidden;\n    }\n\n    #ui {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      width: 290px;\n      max-height: calc(100vh - 20px);\n      overflow: auto;\n      background: rgba(0, 0, 0, 0.75);\n      padding: 12px 14px;\n      border-radius: 8px;\n      backdrop-filter: blur(10px);\n      box-shadow: 0 0 18px rgba(0, 0, 0, 0.6);\n      font-size: 13px;\n    }\n\n    #ui h2 {\n      margin: 4px 0 8px;\n      font-size: 16px;\n      font-weight: 600;\n    }\n\n    #ui h3 {\n      margin: 10px 0 4px;\n      font-size: 14px;\n      font-weight: 600;\n      border-bottom: 1px solid rgba(255,255,255,0.06);\n      padding-bottom: 2px;\n    }\n\n    .section {\n      margin-bottom: 8px;\n      padding-bottom: 6px;\n    }\n\n    label {\n      display: block;\n      margin: 3px 0;\n    }\n\n    input[type=\"color\"] {\n      padding: 0;\n      border: none;\n      width: 50px;\n      height: 22px;\n      vertical-align: middle;\n      margin-left: 4px;\n      background: transparent;\n    }\n\n    select, button {\n      font-size: 12px;\n      padding: 3px 6px;\n      margin: 2px 0;\n      border-radius: 4px;\n      border: 1px solid #444;\n      background: #1c1c1c;\n      color: #eee;\n    }\n\n    button {\n      cursor: pointer;\n    }\n\n    button:hover {\n      background: #2b2b2b;\n    }\n\n    .row {\n      display: flex;\n      gap: 4px;\n      flex-wrap: wrap;\n      align-items: center;\n    }\n\n    .row > * {\n      flex: 1 1 auto;\n    }\n\n    .small {\n      font-size: 11px;\n      opacity: 0.8;\n    }\n\n    #snapshotLink {\n      display: none;\n    }\n\n    #bookmarkButtons button {\n      width: 32%;\n    }\n\n    a {\n      color: #7fb9ff;\n    }\n\n    #footer {\n      margin-top: 4px;\n      font-size: 10px;\n      opacity: 0.7;\n    }\n  </style>\n</head>\n<body>\n<div id=\"container\"></div>\n\n<div id=\"ui\">\n  <h2>3D Phone Configurator</h2>\n\n  <div class=\"section\">\n    <div class=\"small\">\n      Drag to orbit, scroll to zoom, right-drag to pan.\n    </div>\n  </div>\n\n  <div class=\"section\">\n    <h3>Body</h3>\n    <label>\n      Color:\n      <input type=\"color\" id=\"bodyColor\" value=\"#1e88e5\">\n    </label>\n    <label>\n      Metallic:\n      <select id=\"bodyMetallic\">\n        <option value=\"0.1\">Low</option>\n        <option value=\"0.4\" selected>Medium</option>\n        <option value=\"0.9\">High</option>\n      </select>\n    </label>\n    <label>\n      Roughness:\n      <select id=\"bodyRoughness\">\n        <option value=\"0.1\">Glossy</option>\n        <option value=\"0.4\" selected>Satin</option>\n        <option value=\"0.8\">Matte</option>\n      </select>\n    </label>\n\n    <label>\n      Texture:\n      <select id=\"bodyTexture\">\n        <option value=\"none\" selected>None</option>\n        <option value=\"brushed\">Brushed</option>\n        <option value=\"carbon\">Carbon</option>\n      </select>\n    </label>\n  </div>\n\n  <div class=\"section\">\n    <h3>Screen</h3>\n    <label>\n      Screen On:\n      <input type=\"checkbox\" id=\"screenOn\" checked>\n    </label>\n    <label>\n      Wallpaper:\n      <select id=\"screenWallpaper\">\n        <option value=\"gradient\" selected>Gradient</option>\n        <option value=\"grid\">Grid</option>\n        <option value=\"waves\">Waves</option>\n      </select>\n    </label>\n  </div>\n\n  <div class=\"section\">\n    <h3>Extras</h3>\n    <label>\n      Show Camera Bump:\n      <input type=\"checkbox\" id=\"camBumpToggle\" checked>\n    </label>\n    <label>\n      Show Side Buttons:\n      <input type=\"checkbox\" id=\"buttonsToggle\" checked>\n    </label>\n    <label>\n      Show Stand:\n      <input type=\"checkbox\" id=\"standToggle\" checked>\n    </label>\n  </div>\n\n  <div class=\"section\">\n    <h3>Camera Views</h3>\n    <div id=\"bookmarkButtons\" class=\"row\">\n      <button data-view=\"front\">Front</button>\n      <button data-view=\"back\">Back</button>\n      <button data-view=\"iso\">Iso</button>\n    </div>\n    <div class=\"row\">\n      <button id=\"saveView\">Save Current</button>\n      <button id=\"loadView\">Load Saved</button>\n    </div>\n    <div class=\"small\">\n      Saved view is kept only in this session.\n    </div>\n  </div>\n\n  <div class=\"section\">\n    <h3>Export</h3>\n    <div class=\"row\">\n      <button id=\"exportJSON\">Export JSON</button>\n      <button id=\"exportPNG\">Export PNG</button>\n    </div>\n    <a id=\"snapshotLink\" download=\"phone_snapshot.png\">Download Snapshot</a>\n  </div>\n\n  <div id=\"footer\">\n    Demo: Procedural Three.js phone model with environment reflections &amp; soft shadows.\n  </div>\n</div>\n\n<!-- Three.js & OrbitControls via CDN -->\n<script src=\"https://unpkg.com/three@0.162.0/build/three.min.js\"></script>\n<script src=\"https://unpkg.com/three@0.162.0/examples/js/controls/OrbitControls.js\"></script>\n\n<script>\n(function () {\n  let renderer, scene, camera, controls;\n  let phoneGroup, bodyMesh, screenMesh, glassMesh;\n  let camBumpMesh, lensMesh, flashMesh, buttonsGroup, standMesh;\n  let envRT;\n  let bodyTextureBrushed, bodyTextureCarbon;\n  let screenTextures = {};\n  let savedView = null;\n\n  const params = {\n    bodyColor: '#1e88e5',\n    bodyMetallic: 0.4,\n    bodyRoughness: 0.4,\n    bodyTexture: 'none',\n    screenOn: true,\n    screenWallpaper: 'gradient',\n    camBump: true,\n    buttons: true,\n    stand: true\n  };\n\n  init();\n  animate();\n\n  function init() {\n    const container = document.getElementById('container');\n\n    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.outputEncoding = THREE.sRGBEncoding;\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    container.appendChild(renderer.domElement);\n\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x05070b);\n\n    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.05, 50);\n    camera.position.set(3, 1.8, 3);\n    scene.add(camera);\n\n    controls = new THREE.OrbitControls(camera, renderer.domElement);\n    controls.target.set(0, 1.1, 0);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.07;\n    controls.minDistance = 1.4;\n    controls.maxDistance = 7;\n    controls.maxPolarAngle = Math.PI * 0.9;\n\n    // Environment (procedural)\n    const cubeRes = 128;\n    envRT = new THREE.WebGLCubeRenderTarget(cubeRes, {\n      type: THREE.HalfFloatType,\n      generateMipmaps: true,\n      minFilter: THREE.LinearMipmapLinearFilter,\n      encoding: THREE.sRGBEncoding\n    });\n    envRT.texture.mapping = THREE.CubeReflectionMapping;\n    generateProceduralEnvironment(envRT);\n    scene.environment = envRT.texture;\n\n    // Lights\n    const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.35);\n    hemi.position.set(0, 2, 0);\n    scene.add(hemi);\n\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);\n    dirLight.position.set(5, 7, 3);\n    dirLight.castShadow = true;\n    dirLight.shadow.mapSize.set(2048, 2048);\n    dirLight.shadow.camera.near = 1;\n    dirLight.shadow.camera.far = 20;\n    dirLight.shadow.camera.left = -5;\n    dirLight.shadow.camera.right = 5;\n    dirLight.shadow.camera.top = 5;\n    dirLight.shadow.camera.bottom = -1;\n    scene.add(dirLight);\n\n    const fillLight = new THREE.DirectionalLight(0x99ccff, 0.25);\n    fillLight.position.set(-4, 2, -3);\n    scene.add(fillLight);\n\n    // Ground with soft shadows\n    const groundMat = new THREE.MeshStandardMaterial({\n      color: 0x111111,\n      roughness: 0.9,\n      metalness: 0,\n    });\n    const groundGeo = new THREE.CircleGeometry(6, 64);\n    const ground = new THREE.Mesh(groundGeo, groundMat);\n    ground.rotation.x = -Math.PI / 2;\n    ground.receiveShadow = true;\n    scene.add(ground);\n\n    // Phone model\n    createPhoneModel();\n\n    // Precompute textures\n    bodyTextureBrushed = createBrushedTexture();\n    bodyTextureCarbon = createCarbonTexture();\n    screenTextures.gradient = createScreenTexture('gradient');\n    screenTextures.grid = createScreenTexture('grid');\n    screenTextures.waves = createScreenTexture('waves');\n\n    // UI bindings\n    bindUI();\n\n    window.addEventListener('resize', onWindowResize);\n  }\n\n  function createPhoneModel() {\n    phoneGroup = new THREE.Group();\n    scene.add(phoneGroup);\n\n    const bodyWidth = 0.75;\n    const bodyHeight = 1.6;\n    const bodyDepth = 0.08;\n    const cornerRadius = 0.16;\n\n    const bodyGeo = roundedBox(bodyWidth, bodyHeight, bodyDepth, cornerRadius, 6);\n    const bodyMat = new THREE.MeshStandardMaterial({\n      color: new THREE.Color(params.bodyColor),\n      metalness: params.bodyMetallic,\n      roughness: params.bodyRoughness,\n      envMap: scene.environment,\n      envMapIntensity: 1.2\n    });\n    bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);\n    bodyMesh.castShadow = true;\n    bodyMesh.receiveShadow = true;\n    bodyMesh.position.y = 1.05;\n    phoneGroup.add(bodyMesh);\n\n    // Glass front layer\n    const glassGeo = roundedBox(bodyWidth * 0.94, bodyHeight * 0.94, bodyDepth * 0.02, cornerRadius * 0.9, 4);\n    const glassMat = new THREE.MeshPhysicalMaterial({\n      color: 0xffffff,\n      metalness: 0,\n      roughness: 0.05,\n      transparent: true,\n      opacity: 0.15,\n      transmission: 1.0,\n      thickness: 0.03,\n      envMap: scene.environment,\n      envMapIntensity: 1.2,\n      clearcoat: 1,\n      clearcoatRoughness: 0.1\n    });\n    glassMesh = new THREE.Mesh(glassGeo, glassMat);\n    glassMesh.position.z = bodyDepth / 2 + 0.001;\n    glassMesh.position.y = bodyMesh.position.y;\n    glassMesh.castShadow = false;\n    glassMesh.receiveShadow = false;\n    phoneGroup.add(glassMesh);\n\n    // Screen (behind glass)\n    const screenMargin = 0.07;\n    const screenGeo = new THREE.PlaneGeometry(\n      bodyWidth * 0.94 - screenMargin,\n      bodyHeight * 0.94 - screenMargin\n    );\n    const screenMat = new THREE.MeshBasicMaterial({\n      color: 0x000000,\n      toneMapped: false\n    });\n    screenMesh = new THREE.Mesh(screenGeo, screenMat);\n    screenMesh.position.z = bodyDepth / 2 - 0.01;\n    screenMesh.position.y = bodyMesh.position.y;\n    phoneGroup.add(screenMesh);\n\n    // Camera bump (back top-left)\n    const bumpWidth = 0.35;\n    const bumpHeight = 0.4;\n    const bumpDepth = 0.06;\n    const bumpRad = 0.08;\n    const bumpGeo = roundedBox(bumpWidth, bumpHeight, bumpDepth, bumpRad, 4);\n    const bumpMat = new THREE.MeshStandardMaterial({\n      color: 0x111111,\n      metalness: 0.6,\n      roughness: 0.2,\n      envMap: scene.environment,\n      envMapIntensity: 1.4\n    });\n    camBumpMesh = new THREE.Mesh(bumpGeo, bumpMat);\n    camBumpMesh.position.set(\n      -bodyWidth * 0.23,\n      bodyMesh.position.y + bodyHeight * 0.22,\n      -bodyDepth / 2 - bumpDepth / 2 + 0.005\n    );\n    camBumpMesh.castShadow = true;\n    camBumpMesh.receiveShadow = true;\n    phoneGroup.add(camBumpMesh);\n\n    // Camera lenses inside bump\n    const lensGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.03, 24);\n    const lensMat = new THREE.MeshPhysicalMaterial({\n      color: 0x222222,\n      metalness: 0.8,\n      roughness: 0.05,\n      envMap: scene.environment,\n      envMapIntensity: 1.5,\n      transparent: true,\n      opacity: 0.98,\n      clearcoat: 1,\n      clearcoatRoughness: 0.05\n    });\n    lensMesh = new THREE.Group();\n    const lensPositions = [\n      new THREE.Vector3(-0.07, 0.06, 0),\n      new THREE.Vector3(0.07, 0.06, 0),\n      new THREE.Vector3(0, -0.09, 0)\n    ];\n    lensPositions.forEach(p => {\n      const m = new THREE.Mesh(lensGeo, lensMat);\n      m.rotation.x = Math.PI / 2;\n      m.position.copy(p);\n      m.castShadow = true;\n      lensMesh.add(m);\n    });\n    lensMesh.position.copy(camBumpMesh.position);\n    lensMesh.position.z -= bumpDepth / 2 - 0.015;\n    phoneGroup.add(lensMesh);\n\n    // Flash\n    const flashGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.02, 20);\n    const flashMat = new THREE.MeshStandardMaterial({\n      emissive: 0xffffaa,\n      emissiveIntensity: 1.5,\n      color: 0xffffff,\n      metalness: 0.6,\n      roughness: 0.3\n    });\n    flashMesh = new THREE.Mesh(flashGeo, flashMat);\n    flashMesh.rotation.x = Math.PI / 2;\n    flashMesh.position.set(\n      camBumpMesh.position.x + bumpWidth * 0.25,\n      camBumpMesh.position.y + bumpHeight * 0.12,\n      camBumpMesh.position.z - bumpDepth / 2 + 0.01\n    );\n    flashMesh.castShadow = true;\n    phoneGroup.add(flashMesh);\n\n    // Side buttons\n    buttonsGroup = new THREE.Group();\n    const btnGeo = new THREE.BoxGeometry(0.02, 0.18, 0.02);\n    const btnMat = new THREE.MeshStandardMaterial({\n      color: 0xcccccc,\n      metalness: 0.8,\n      roughness: 0.3,\n      envMap: scene.environment,\n      envMapIntensity: 1.0\n    });\n\n    const volUp = new THREE.Mesh(btnGeo, btnMat);\n    volUp.position.set(bodyWidth / 2 + 0.01, bodyMesh.position.y + 0.23, 0);\n    volUp.castShadow = true;\n    buttonsGroup.add(volUp);\n\n    const volDown = volUp.clone();\n    volDown.position.y -= 0.25;\n    buttonsGroup.add(volDown);\n\n    const powerBtn = new THREE.Mesh(\n      new THREE.BoxGeometry(0.02, 0.12, 0.02),\n      btnMat\n    );\n    powerBtn.position.set(-bodyWidth / 2 - 0.01, bodyMesh.position.y + 0.05, 0);\n    powerBtn.castShadow = true;\n    buttonsGroup.add(powerBtn);\n\n    phoneGroup.add(buttonsGroup);\n\n    // Simple stand\n    const standGeo = new THREE.CylinderGeometry(0.55, 0.6, 0.05, 48);\n    const standMat = new THREE.MeshStandardMaterial({\n      color: 0x333333,\n      roughness: 0.7,\n      metalness: 0.2,\n      envMap: scene.environment,\n      envMapIntensity: 0.3\n    });\n    standMesh = new THREE.Mesh(standGeo, standMat);\n    standMesh.position.y = 0.99;\n    standMesh.castShadow = true;\n    standMesh.receiveShadow = true;\n    phoneGroup.add(standMesh);\n  }\n\n  // Rounded box helper (from Three.js examples, simplified)\n  function roundedBox(width, height, depth, radius, smoothness) {\n    const shape = new THREE.Shape();\n    const hw = width / 2 - radius;\n    const hh = height / 2 - radius;\n\n    shape.absarc(-hw, -hh, radius, -Math.PI, -Math.PI / 2, false);\n    shape.absarc(hw, -hh, radius, -Math.PI / 2, 0, false);\n    shape.absarc(hw, hh, radius, 0, Math.PI / 2, false);\n    shape.absarc(-hw, hh, radius, Math.PI / 2, Math.PI, false);\n    const extrudeSettings = {\n      depth: depth,\n      bevelEnabled: false,\n      steps: smoothness\n    };\n    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n    geometry.center();\n    return geometry;\n  }\n\n  function generateProceduralEnvironment(target) {\n    const size = target.width;\n    const ctx = document.createElement('canvas').getContext('2d');\n    ctx.canvas.width = size * 4;\n    ctx.canvas.height = size * 3;\n\n    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);\n    gradient.addColorStop(0, '#0c1624');\n    gradient.addColorStop(0.4, '#050811');\n    gradient.addColorStop(0.7, '#020308');\n    gradient.addColorStop(1, '#000000');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    ctx.fillStyle = 'rgba(90, 150, 255, 0.45)';\n    for (let i = 0; i < 40; i++) {\n      const r = 80 + Math.random() * 200;\n      const x = Math.random() * ctx.canvas.width;\n      const y = Math.random() * ctx.canvas.height * 0.7;\n      ctx.beginPath();\n      ctx.arc(x, y, r, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    const tmpTex = new THREE.CanvasTexture(ctx.canvas);\n    tmpTex.needsUpdate = true;\n    const cubeTex = new THREE.CubeTexture();\n    cubeTex.images = [];\n\n    // Very approximate mapping: sample six crops.\n    const w = ctx.canvas.width;\n    const h = ctx.canvas.height;\n    function crop(sx, sy, sw, sh) {\n      const c = document.createElement('canvas');\n      c.width = size;\n      c.height = size;\n      const cctx = c.getContext('2d');\n      cctx.drawImage(ctx.canvas, sx, sy, sw, sh, 0, 0, size, size);\n      return c;\n    }\n\n    cubeTex.images[0] = crop(0, h / 3, w / 4, h / 3);       // px\n    cubeTex.images[1] = crop(w * 3 / 4, h / 3, w / 4, h / 3); // nx\n    cubeTex.images[2] = crop(w / 4, 0, w / 4, h / 3);       // py\n    cubeTex.images[3] = crop(w / 4, h * 2 / 3, w / 4, h / 3); // ny\n    cubeTex.images[4] = crop(w / 4, h / 3, w / 4, h / 3);   // pz\n    cubeTex.images[5] = crop(w / 2, h / 3, w / 4, h / 3);   // nz\n    cubeTex.needsUpdate = true;\n    cubeTex.encoding = THREE.sRGBEncoding;\n\n    target.texture = cubeTex;\n    target.texture.needsUpdate = true;\n  }\n\n  // Brushed metal-like texture\n  function createBrushedTexture() {\n    const size = 256;\n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = size;\n    const ctx = canvas.getContext('2d');\n\n    const gradient = ctx.createLinearGradient(0, 0, size, 0);\n    gradient.addColorStop(0, '#bbbbbb');\n    gradient.addColorStop(0.5, '#f0f0f0');\n    gradient.addColorStop(1, '#aaaaaa');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, size, size);\n\n    ctx.fillStyle = 'rgba(180,180,180,0.35)';\n    for (let i = 0; i < 500; i++) {\n      const y = Math.random() * size;\n      const len = 15 + Math.random() * 20;\n      const alpha = 0.08 + Math.random() * 0.08;\n      ctx.strokeStyle = 'rgba(200,200,200,' + alpha + ')';\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(size, y + (Math.random() - 0.5) * len);\n      ctx.stroke();\n    }\n\n    const tex = new THREE.CanvasTexture(canvas);\n    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n    tex.repeat.set(2, 4);\n    tex.anisotropy = 8;\n    tex.needsUpdate = true;\n    return tex;\n  }\n\n  // Carbon fiber-like texture\n  function createCarbonTexture() {\n    const size = 128;\n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = size;\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = '#202020';\n    ctx.fillRect(0, 0, size, size);\n\n    const cell = 8;\n    for (let y = 0; y < size; y += cell) {\n      for (let x = 0; x < size; x += cell) {\n        const isEven = ((x / cell) + (y / cell)) % 2 === 0;\n        ctx.fillStyle = isEven ? '#2c2c2c' : '#111111';\n        ctx.fillRect(x, y, cell, cell);\n        ctx.fillStyle = 'rgba(255,255,255,0.06)';\n        ctx.fillRect(x, y, cell / 2, cell / 2);\n      }\n    }\n\n    const tex = new THREE.CanvasTexture(canvas);\n    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n    tex.repeat.set(6, 10);\n    tex.anisotropy = 8;\n    tex.needsUpdate = true;\n    return tex;\n  }\n\n  // Screen wallpaper texture\n  function createScreenTexture(type) {\n    const size = 256;\n    const canvas = document.createElement('canvas');\n    canvas.width = size;\n    canvas.height = size * 2; // portrait\n    const ctx = canvas.getContext('2d');\n\n    if (type === 'gradient') {\n      const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);\n      grd.addColorStop(0, '#2a64ff');\n      grd.addColorStop(0.4, '#9115ff');\n      grd.addColorStop(0.8, '#ff4f74');\n      grd.addColorStop(1, '#fee140');\n      ctx.fillStyle = grd;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.fillStyle = 'rgba(255,255,255,0.2)';\n      for (let i = 0; i < 40; i++) {\n        const r = 20 + Math.random() * 60;\n        const x = Math.random() * canvas.width;\n        const y = Math.random() * canvas.height;\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    } else if (type === 'grid') {\n      ctx.fillStyle = '#050505';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.strokeStyle = 'rgba(0,255,160,0.4)';\n      ctx.lineWidth = 1;\n      const step = 16;\n      for (let x = 0; x <= canvas.width; x += step) {\n        ctx.beginPath();\n        ctx.moveTo(x + 0.5, 0);\n        ctx.lineTo(x + 0.5, canvas.height);\n        ctx.stroke();\n      }\n      for (let y = 0; y <= canvas.height; y += step) {\n        ctx.beginPath();\n        ctx.moveTo(0, y + 0.5);\n        ctx.lineTo(canvas.width, y + 0.5);\n        ctx.stroke();\n      }\n      ctx.fillStyle = 'rgba(0,255,200,0.7)';\n      for (let i = 0; i < 50; i++) {\n        const r = 1 + Math.random() * 2;\n        const x = Math.random() * canvas.width;\n        const y = Math.random() * canvas.height;\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    } else if (type === 'waves') {\n      const grd = ctx.createLinearGradient(0, 0, canvas.width, 0);\n      grd.addColorStop(0, '#00172a');\n      grd.addColorStop(1, '#03506f');\n      ctx.fillStyle = grd;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';\n      ctx.lineWidth = 2.5;\n      for (let i = 0; i < 6; i++) {\n        const amp = 10 + i * 8;\n        const freq = 0.02 + i * 0.01;\n        const phase = i * Math.PI / 4;\n        ctx.beginPath();\n        for (let x = 0; x <= canvas.width; x++) {\n          const y = canvas.height / 2 +\n            Math.sin((x * freq) + phase) * amp +\n            (i - 3) * 18;\n          if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);\n        }\n        ctx.stroke();\n      }\n    }\n\n    const tex = new THREE.CanvasTexture(canvas);\n    tex.wrapS = THREE.ClampToEdgeWrapping;\n    tex.wrapT = THREE.ClampToEdgeWrapping;\n    tex.needsUpdate = true;\n    tex.anisotropy = 8;\n    tex.encoding = THREE.sRGBEncoding;\n    return tex;\n  }\n\n  function bindUI() {\n    const bodyColor = document.getElementById('bodyColor');\n    const bodyMetallic = document.getElementById('bodyMetallic');\n    const bodyRoughness = document.getElementById('bodyRoughness');\n    const bodyTexture = document.getElementById('bodyTexture');\n    const screenOn = document.getElementById('screenOn');\n    const screenWallpaper = document.getElementById('screenWallpaper');\n    const camBumpToggle = document.getElementById('camBumpToggle');\n    const buttonsToggle = document.getElementById('buttonsToggle');\n    const standToggle = document.getElementById('standToggle');\n    const exportJSON = document.getElementById('exportJSON');\n    const exportPNG = document.getElementById('exportPNG');\n    const snapshotLink = document.getElementById('snapshotLink');\n    const bookmarkButtons = document.querySelectorAll('#bookmarkButtons button');\n    const saveView = document.getElementById('saveView');\n    const loadView = document.getElementById('loadView');\n\n    bodyColor.addEventListener('input', () => {\n      params.bodyColor = bodyColor.value;\n      bodyMesh.material.color.set(params.bodyColor);\n    });\n\n    bodyMetallic.value = params.bodyMetallic;\n    bodyRoughness.value = params.bodyRoughness;\n\n    bodyMetallic.addEventListener('change', () => {\n      params.bodyMetallic = parseFloat(bodyMetallic.value);\n      bodyMesh.material.metalness = params.bodyMetallic;\n      bodyMesh.material.needsUpdate = true;\n    });\n\n    bodyRoughness.addEventListener('change', () => {\n      params.bodyRoughness = parseFloat(bodyRoughness.value);\n      bodyMesh.material.roughness = params.bodyRoughness;\n      bodyMesh.material.needsUpdate = true;\n    });\n\n    bodyTexture.addEventListener('change', () => {\n      params.bodyTexture = bodyTexture.value;\n      updateBodyTexture();\n    });\n\n    screenOn.addEventListener('change', () => {\n      params.screenOn = screenOn.checked;\n      updateScreen();\n    });\n\n    screenWallpaper.addEventListener('change', () => {\n      params.screenWallpaper = screenWallpaper.value;\n      updateScreen();\n    });\n\n    camBumpToggle.addEventListener('change', () => {\n      params.camBump = camBumpToggle.checked;\n      camBumpMesh.visible = params.camBump;\n      lensMesh.visible = params.camBump;\n      flashMesh.visible = params.camBump;\n    });\n\n    buttonsToggle.addEventListener('change', () => {\n      params.buttons = buttonsToggle.checked;\n      buttonsGroup.visible = params.buttons;\n    });\n\n    standToggle.addEventListener('change', () => {\n      params.stand = standToggle.checked;\n      standMesh.visible = params.stand;\n    });\n\n    // Camera bookmarks\n    bookmarkButtons.forEach(btn => {\n      btn.addEventListener('click', () => {\n        const view = btn.getAttribute('data-view');\n        jumpToView(view);\n      });\n    });\n\n    saveView.addEventListener('click', () => {\n      savedView = {\n        position: camera.position.clone(),\n        target: controls.target.clone()\n      };\n    });\n\n    loadView.addEventListener('click', () => {\n      if (!savedView) return;\n      camera.position.copy(savedView.position);\n      controls.target.copy(savedView.target);\n      controls.update();\n    });\n\n    // Export JSON\n    exportJSON.addEventListener('click', () => {\n      const config = getCurrentConfig();\n      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'phone_configuration.json';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    });\n\n    // Export PNG\n    exportPNG.addEventListener('click', () => {\n      // Render once to ensure up to date\n      renderer.render(scene, camera);\n      const dataURL = renderer.domElement.toDataURL('image/png');\n      snapshotLink.href = dataURL;\n      snapshotLink.click();\n    });\n\n    // Apply initial state\n    updateBodyTexture();\n    updateScreen();\n  }\n\n  function updateBodyTexture() {\n    const mat = bodyMesh.material;\n    if (params.bodyTexture === 'brushed') {\n      mat.map = bodyTextureBrushed;\n      mat.normalMap = null;\n    } else if (params.bodyTexture === 'carbon') {\n      mat.map = bodyTextureCarbon;\n      mat.normalMap = null;\n    } else {\n      mat.map = null;\n      mat.normalMap = null;\n    }\n    mat.needsUpdate = true;\n  }\n\n  function updateScreen() {\n    if (!params.screenOn) {\n      screenMesh.material.map = null;\n      screenMesh.material.color.set(0x000000);\n      screenMesh.material.needsUpdate = true;\n      return;\n    }\n    const tex = screenTextures[params.screenWallpaper] || screenTextures.gradient;\n    screenMesh.material.map = tex;\n    screenMesh.material.color.set(0xffffff);\n    screenMesh.material.needsUpdate = true;\n  }\n\n  function jumpToView(viewName) {\n    const targetPos = new THREE.Vector3();\n    const targetLook = new THREE.Vector3(0, bodyMesh.position.y, 0);\n\n    if (viewName === 'front') {\n      targetPos.set(0, bodyMesh.position.y, 2.4);\n    } else if (viewName === 'back') {\n      targetPos.set(0, bodyMesh.position.y, -2.4);\n    } else { // iso\n      targetPos.set(2.6, 1.9, 2.4);\n    }\n\n    animateCameraTo(targetPos, targetLook, 500);\n  }\n\n  function animateCameraTo(newPos, newTarget, duration) {\n    const startPos = camera.position.clone();\n    const startTarget = controls.target.clone();\n    const startTime = performance.now();\n\n    function update() {\n      const now = performance.now();\n      const t = Math.min((now - startTime) / duration, 1);\n      const s = t * (2 - t); // ease out\n      camera.position.lerpVectors(startPos, newPos, s);\n      controls.target.lerpVectors(startTarget, newTarget, s);\n      controls.update();\n      if (t < 1) {\n        requestAnimationFrame(update);\n      }\n    }\n    requestAnimationFrame(update);\n  }\n\n  function getCurrentConfig() {\n    return {\n      body: {\n        color: params.bodyColor,\n        metallic: params.bodyMetallic,\n        roughness: params.bodyRoughness,\n        texture: params.bodyTexture\n      },\n      screen: {\n        on: params.screenOn,\n        wallpaper: params.screenWallpaper\n      },\n      extras: {\n        cameraBump: params.camBump,\n        buttons: params.buttons,\n        stand: params.stand\n      },\n      camera: {\n        position: camera.position.toArray(),\n        target: controls.target.toArray()\n      }\n    };\n  }\n\n  function onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n\n  function animate() {\n    requestAnimationFrame(animate);\n    controls.update();\n    renderer.render(scene, camera);\n  }\n})();\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 47.15701198577881,
    "status": "success",
    "timestamp": "2025-11-19 22:08:11",
    "evaluation": {
      "test_name": "product_configurator",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "THREE is not defined"
        ],
        "warnings": [
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.162.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.162.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.162.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.162.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details."
        ],
        "screenshot": "output/screenshots/product_configurator.png",
        "render_time_ms": 670.39,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 670.39ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "THREE is not defined"
            ]
          },
          {
            "level": "warning",
            "message": "\u26a0\ufe0f  4 warning(s)"
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "1. The HTML file is incomplete, ending abruptly and missing much of the required Three.js JavaScript logic and HTML closing tags. 2. Key requirements from the original task are missing, such as the implementation of a 3D model with color, material, texture, and part toggles. 3. There's no evidence of environment reflections, soft shadows, or camera bookmarks being set up in the code provided. 4. Missing features include exporting the current config as JSON and PNG snapshot functionality. 5. The Three.js library is not included or referenced, which is critical for the requested functionality.",
        "strengths": "The HTML structure shows a clear intention for a structured UI with styling, and there is a defined layout for interaction panels (e.g., #ui).",
        "weaknesses": "The code is incomplete, missing major functionality described in the task such as the rendering and configuration logic for a 3D scene using Three.js, and the code lacks necessary scripts for 3D model rendering and configurator functionalities.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "physics_playground",
    "prompt": "Create a complete HTML file with Three.js integrated with a lightweight physics engine (cannon-es or similar) that includes stackable boxes, spheres, hinge joints, ragdoll, and interactive dragging with the mouse. Add reset button, gravity slider, and slow-motion toggle. The HTML file should be self-contained with Three.js and physics engine loaded from CDN. Save the output as 'physics_playground.html'.",
    "response": "```html\n<!-- Save this file as: physics_playground.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Physics Playground - Three.js + cannon-es</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      height: 100%;\n      background: #111;\n      font-family: Arial, sans-serif;\n      color: #eee;\n    }\n\n    #container {\n      width: 100%;\n      height: 100%;\n      position: relative;\n    }\n\n    #ui {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      padding: 10px 12px;\n      background: rgba(0, 0, 0, 0.55);\n      border-radius: 4px;\n      font-size: 13px;\n      z-index: 10;\n      backdrop-filter: blur(4px);\n    }\n\n    #ui h1 {\n      margin: 0 0 6px 0;\n      font-size: 16px;\n      font-weight: bold;\n    }\n\n    #ui button {\n      margin: 3px 0;\n      padding: 4px 8px;\n      font-size: 12px;\n      border-radius: 3px;\n      border: 1px solid #444;\n      background: #222;\n      color: #eee;\n      cursor: pointer;\n    }\n\n    #ui button:hover {\n      background: #333;\n    }\n\n    #ui label {\n      display: block;\n      margin-top: 6px;\n    }\n\n    #ui input[type=\"range\"] {\n      width: 160px;\n    }\n\n    #ui .row {\n      margin-top: 4px;\n    }\n\n    #help {\n      position: absolute;\n      bottom: 10px;\n      left: 10px;\n      padding: 6px 8px;\n      background: rgba(0, 0, 0, 0.45);\n      border-radius: 4px;\n      font-size: 11px;\n      color: #ccc;\n      max-width: 280px;\n    }\n\n    a {\n      color: #8cf;\n    }\n  </style>\n</head>\n<body>\n<div id=\"container\"></div>\n\n<div id=\"ui\">\n  <h1>Physics Playground</h1>\n  <div class=\"row\">\n    <button id=\"resetBtn\">Reset Scene</button>\n    <button id=\"slowMoBtn\">Slow Motion: OFF</button>\n  </div>\n  <div class=\"row\">\n    <label for=\"gravitySlider\">\n      Gravity: <span id=\"gravityValue\">-9.8</span> m/s\u00b2\n    </label>\n    <input id=\"gravitySlider\" type=\"range\" min=\"-30\" max=\"0\" step=\"0.1\" value=\"-9.8\">\n  </div>\n</div>\n\n<div id=\"help\">\n  Mouse:\n  <ul>\n    <li>Left-click + drag: rotate camera (OrbitControls)</li>\n    <li>Scroll: zoom</li>\n    <li>Right-click + drag: pan camera</li>\n    <li>Middle-click / Ctrl+Left: drag physics body</li>\n  </ul>\n  Objects:\n  <ul>\n    <li>Stackable boxes &amp; spheres</li>\n    <li>Simple hinge door</li>\n    <li>Basic ragdoll</li>\n  </ul>\n  Slow motion scales physics time-step (good for observing joints).\n</div>\n\n<!-- Three.js and cannon-es from CDN -->\n<script type=\"module\">\n  import * as THREE from \"https://unpkg.com/three@0.161.0/build/three.module.js\";\n  import { OrbitControls } from \"https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js\";\n  import * as CANNON from \"https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js\";\n\n  // ---------------------------------------------------------------------------\n  // Global variables\n  // ---------------------------------------------------------------------------\n  let renderer, scene, camera, controls;\n  let world;\n  let objects = [];   // { body, mesh }\n  let joints = [];\n  let ragdollParts = [];\n\n  let lastTime = performance.now() / 1000;\n  let slowMotion = false;\n  let timeScale = 1.0;\n\n  // Dragging\n  let mouse = new THREE.Vector2();\n  let raycaster = new THREE.Raycaster();\n  let dragConstraint = null;\n  let dragBody = null;\n  let dragPivot = new CANNON.Vec3();\n  let dragPoint = new CANNON.Vec3();\n  let planeMesh; // helper for visual plane (optional)\n\n  const container = document.getElementById(\"container\");\n\n  // ---------------------------------------------------------------------------\n  // Init\n  // ---------------------------------------------------------------------------\n  initThree();\n  initPhysics();\n  createSceneObjects();\n  initUI();\n  animate();\n\n  // ---------------------------------------------------------------------------\n  // THREE.js setup\n  // ---------------------------------------------------------------------------\n  function initThree() {\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x111111);\n\n    camera = new THREE.PerspectiveCamera(\n      60,\n      window.innerWidth / window.innerHeight,\n      0.1,\n      200\n    );\n    camera.position.set(10, 10, 18);\n\n    renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.shadowMap.enabled = true;\n    container.appendChild(renderer.domElement);\n\n    // Lights\n    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);\n    hemiLight.position.set(0, 20, 0);\n    scene.add(hemiLight);\n\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    dirLight.position.set(10, 20, 10);\n    dirLight.castShadow = true;\n    dirLight.shadow.mapSize.set(2048, 2048);\n    dirLight.shadow.camera.near = 0.5;\n    dirLight.shadow.camera.far = 100;\n    scene.add(dirLight);\n\n    // Ground plane (visual)\n    const groundGeom = new THREE.PlaneGeometry(60, 60);\n    const groundMat = new THREE.MeshStandardMaterial({\n      color: 0x303030,\n      metalness: 0.1,\n      roughness: 0.8\n    });\n    const groundMesh = new THREE.Mesh(groundGeom, groundMat);\n    groundMesh.rotation.x = -Math.PI / 2;\n    groundMesh.receiveShadow = true;\n    scene.add(groundMesh);\n\n    // Orbit controls\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.target.set(0, 2, 0);\n\n    window.addEventListener(\"resize\", onWindowResize);\n\n    // Mouse events for dragging\n    renderer.domElement.addEventListener(\"pointerdown\", onPointerDown);\n    renderer.domElement.addEventListener(\"pointermove\", onPointerMove);\n    renderer.domElement.addEventListener(\"pointerup\", onPointerUp);\n    renderer.domElement.addEventListener(\"pointerleave\", onPointerUp);\n  }\n\n  function onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Physics setup\n  // ---------------------------------------------------------------------------\n  function initPhysics() {\n    world = new CANNON.World({\n      allowSleep: true,\n      gravity: new CANNON.Vec3(0, -9.82, 0),\n      broadphase: new CANNON.SAPBroadphase()\n    });\n\n    world.defaultContactMaterial.friction = 0.3;\n    world.defaultContactMaterial.restitution = 0.1;\n\n    // Ground plane - physics\n    const groundShape = new CANNON.Plane();\n    const groundBody = new CANNON.Body({\n      mass: 0,\n      shape: groundShape,\n      material: new CANNON.Material(\"ground\")\n    });\n    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);\n    world.addBody(groundBody);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Scene content\n  // ---------------------------------------------------------------------------\n  function createSceneObjects() {\n    clearWorld();\n\n    // Recreate base\n    createStacks();\n    createSpheres();\n    createHingeDoor();\n    createRagdoll();\n  }\n\n  function clearWorld() {\n    // Remove bodies\n    if (world) {\n      for (let i = world.bodies.length - 1; i >= 0; i--) {\n        const b = world.bodies[i];\n        if (b.mass !== 0) {\n          world.removeBody(b);\n        }\n      }\n      // Remove constraints\n      for (let i = world.constraints.length - 1; i >= 0; i--) {\n        world.removeConstraint(world.constraints[i]);\n      }\n    }\n    // Remove meshes\n    for (const o of objects) {\n      scene.remove(o.mesh);\n    }\n    objects = [];\n    joints = [];\n    ragdollParts = [];\n  }\n\n  // Utility: create a box body + mesh\n  function createBox(size, position, mass = 1, color = 0x8888ff) {\n    const [sx, sy, sz] = size;\n    const shape = new CANNON.Box(new CANNON.Vec3(sx / 2, sy / 2, sz / 2));\n    const body = new CANNON.Body({ mass });\n    body.addShape(shape);\n    body.position.set(position.x, position.y, position.z);\n    body.linearDamping = 0.01;\n    body.angularDamping = 0.01;\n    world.addBody(body);\n\n    const geom = new THREE.BoxGeometry(sx, sy, sz);\n    const mat = new THREE.MeshStandardMaterial({ color });\n    const mesh = new THREE.Mesh(geom, mat);\n    mesh.castShadow = true;\n    mesh.receiveShadow = true;\n    mesh.position.copy(position);\n    scene.add(mesh);\n\n    objects.push({ body, mesh });\n    return { body, mesh };\n  }\n\n  // Utility: create sphere body + mesh\n  function createSphere(radius, position, mass = 1, color = 0xff8888) {\n    const shape = new CANNON.Sphere(radius);\n    const body = new CANNON.Body({ mass });\n    body.addShape(shape);\n    body.position.set(position.x, position.y, position.z);\n    body.linearDamping = 0.01;\n    body.angularDamping = 0.01;\n    world.addBody(body);\n\n    const geom = new THREE.SphereGeometry(radius, 24, 24);\n    const mat = new THREE.MeshStandardMaterial({ color });\n    const mesh = new THREE.Mesh(geom, mat);\n    mesh.castShadow = true;\n    mesh.receiveShadow = true;\n    mesh.position.copy(position);\n    scene.add(mesh);\n\n    objects.push({ body, mesh });\n    return { body, mesh };\n  }\n\n  // Stackable boxes\n  function createStacks() {\n    const boxSize = [1, 1, 1];\n    const levels = 5;\n    const startX = -4;\n    const startZ = -2;\n\n    for (let i = 0; i < levels; i++) {\n      const y = 0.5 + i * 1.02;\n      const count = levels - i;\n      const offsetX = startX + i * 0.5;\n      for (let j = 0; j < count; j++) {\n        createBox(\n          boxSize,\n          new THREE.Vector3(offsetX + j * 1.02, y, startZ),\n          1,\n          0x6699ff\n        );\n      }\n    }\n  }\n\n  // Some spheres\n  function createSpheres() {\n    const rows = 2;\n    const cols = 5;\n    const radius = 0.6;\n    const basePos = new THREE.Vector3(3, 1, 0);\n\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < cols; j++) {\n        const p = new THREE.Vector3(\n          basePos.x + j * (radius * 2.2),\n          basePos.y + i * (radius * 2.2),\n          basePos.z + (Math.random() - 0.5) * 1\n        );\n        createSphere(radius, p, 1, 0xff7777);\n      }\n    }\n  }\n\n  // Simple hinge door\n  function createHingeDoor() {\n    // Door frame (static boxes)\n    const frameColor = 0x444444;\n    const thickness = 0.3;\n\n    // Left pillar\n    createBox([thickness, 4, 1], new THREE.Vector3(-8, 2, 0), 0, frameColor);\n    // Right pillar\n    createBox([thickness, 4, 1], new THREE.Vector3(-4, 2, 0), 0, frameColor);\n    // Top beam\n    createBox([4, thickness, 1], new THREE.Vector3(-6, 4, 0), 0, frameColor);\n\n    // Door body\n    const doorWidth = 1.9;\n    const doorHeight = 3.5;\n    const doorThickness = 0.2;\n\n    const door = createBox(\n      [doorWidth, doorHeight, doorThickness],\n      new THREE.Vector3(-7, 2, 0),\n      3,\n      0x996633\n    );\n\n    // Hinge constraint between static world point and door\n    const pivotDoor = new CANNON.Vec3(-doorWidth / 2, 0, 0);\n    const pivotWorld = new CANNON.Vec3(-8 + thickness / 2, 2, 0);\n\n    const hinge = new CANNON.HingeConstraint(door.body, {\n      pivotA: pivotDoor,\n      axisA: new CANNON.Vec3(0, 1, 0),\n      pivotB: pivotWorld,\n      axisB: new CANNON.Vec3(0, 1, 0),\n      collideConnected: false\n    });\n\n    hinge.enableMotor();\n    hinge.setMotorSpeed(0); // not moving by default\n    world.addConstraint(hinge);\n    joints.push(hinge);\n  }\n\n  // Basic ragdoll\n  function createRagdoll() {\n    const basePos = new THREE.Vector3(0, 4, 4);\n\n    // Sizes\n    const torsoSize = [0.6, 1.2, 0.3];\n    const headRadius = 0.25;\n    const limbRadius = 0.15;\n    const upperArmLength = 0.6;\n    const lowerArmLength = 0.6;\n    const upperLegLength = 0.8;\n    const lowerLegLength = 0.8;\n\n    // Torso\n    const torso = createBox(\n      torsoSize,\n      basePos.clone().add(new THREE.Vector3(0, 0, 0)),\n      5,\n      0x55aa55\n    );\n\n    // Head\n    const head = createSphere(\n      headRadius,\n      basePos.clone().add(new THREE.Vector3(0, torsoSize[1] / 2 + headRadius + 0.05, 0)),\n      1,\n      0xffddaa\n    );\n\n    // Arms (boxes to approximate capsules)\n    const upperArmL = createBox(\n      [upperArmLength, limbRadius * 2, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(-torsoSize[0] / 2 - upperArmLength / 2, 0.3, 0)),\n      1,\n      0x55aa55\n    );\n    const lowerArmL = createBox(\n      [lowerArmLength, limbRadius * 2, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(-torsoSize[0] / 2 - upperArmLength - lowerArmLength / 2, 0.3, 0)),\n      1,\n      0x55aa55\n    );\n\n    const upperArmR = createBox(\n      [upperArmLength, limbRadius * 2, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(torsoSize[0] / 2 + upperArmLength / 2, 0.3, 0)),\n      1,\n      0x55aa55\n    );\n    const lowerArmR = createBox(\n      [lowerArmLength, limbRadius * 2, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(torsoSize[0] / 2 + upperArmLength + lowerArmLength / 2, 0.3, 0)),\n      1,\n      0x55aa55\n    );\n\n    // Legs\n    const upperLegL = createBox(\n      [limbRadius * 2, upperLegLength, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(-torsoSize[0] / 4, -torsoSize[1] / 2 - upperLegLength / 2, 0)),\n      2,\n      0x55aa55\n    );\n    const lowerLegL = createBox(\n      [limbRadius * 2, lowerLegLength, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(-torsoSize[0] / 4, -torsoSize[1] / 2 - upperLegLength - lowerLegLength / 2, 0)),\n      2,\n      0x55aa55\n    );\n\n    const upperLegR = createBox(\n      [limbRadius * 2, upperLegLength, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(torsoSize[0] / 4, -torsoSize[1] / 2 - upperLegLength / 2, 0)),\n      2,\n      0x55aa55\n    );\n    const lowerLegR = createBox(\n      [limbRadius * 2, lowerLegLength, limbRadius * 2],\n      basePos.clone().add(new THREE.Vector3(torsoSize[0] / 4, -torsoSize[1] / 2 - upperLegLength - lowerLegLength / 2, 0)),\n      2,\n      0x55aa55\n    );\n\n    // Store parts for easy reference (optional)\n    ragdollParts.push(\n      torso,\n      head,\n      upperArmL,\n      lowerArmL,\n      upperArmR,\n      lowerArmR,\n      upperLegL,\n      lowerLegL,\n      upperLegR,\n      lowerLegR\n    );\n\n    // Constraints (simple hinge-like constraints using ConeTwist or PointToPoint)\n    // Neck\n    addBallSocket(\n      torso.body,\n      head.body,\n      new CANNON.Vec3(0, torsoSize[1] / 2, 0),\n      new CANNON.Vec3(0, -headRadius, 0)\n    );\n\n    // Shoulders\n    addBallSocket(\n      torso.body,\n      upperArmL.body,\n      new CANNON.Vec3(-torsoSize[0] / 2, 0.3, 0),\n      new CANNON.Vec3(upperArmLength / 2, 0, 0)\n    );\n    addBallSocket(\n      torso.body,\n      upperArmR.body,\n      new CANNON.Vec3(torsoSize[0] / 2, 0.3, 0),\n      new CANNON.Vec3(-upperArmLength / 2, 0, 0)\n    );\n\n    // Elbows\n    addBallSocket(\n      upperArmL.body,\n      lowerArmL.body,\n      new CANNON.Vec3(-upperArmLength / 2, 0, 0),\n      new CANNON.Vec3(lowerArmLength / 2, 0, 0)\n    );\n    addBallSocket(\n      upperArmR.body,\n      lowerArmR.body,\n      new CANNON.Vec3(upperArmLength / 2, 0, 0),\n      new CANNON.Vec3(-lowerArmLength / 2, 0, 0)\n    );\n\n    // Hips\n    addBallSocket(\n      torso.body,\n      upperLegL.body,\n      new CANNON.Vec3(-torsoSize[0] / 4, -torsoSize[1] / 2, 0),\n      new CANNON.Vec3(0, upperLegLength / 2, 0)\n    );\n    addBallSocket(\n      torso.body,\n      upperLegR.body,\n      new CANNON.Vec3(torsoSize[0] / 4, -torsoSize[1] / 2, 0),\n      new CANNON.Vec3(0, upperLegLength / 2, 0)\n    );\n\n    // Knees\n    addBallSocket(\n      upperLegL.body,\n      lowerLegL.body,\n      new CANNON.Vec3(0, -upperLegLength / 2, 0),\n      new CANNON.Vec3(0, lowerLegLength / 2, 0)\n    );\n    addBallSocket(\n      upperLegR.body,\n      lowerLegR.body,\n      new CANNON.Vec3(0, -upperLegLength / 2, 0),\n      new CANNON.Vec3(0, lowerLegLength / 2, 0)\n    );\n  }\n\n  function addBallSocket(bodyA, bodyB, pivotA, pivotB) {\n    const c = new CANNON.PointToPointConstraint(bodyA, pivotA, bodyB, pivotB);\n    world.addConstraint(c);\n    joints.push(c);\n  }\n\n  // ---------------------------------------------------------------------------\n  // UI\n  // ---------------------------------------------------------------------------\n  function initUI() {\n    const resetBtn = document.getElementById(\"resetBtn\");\n    const slowMoBtn = document.getElementById(\"slowMoBtn\");\n    const gravitySlider = document.getElementById(\"gravitySlider\");\n    const gravityValue = document.getElementById(\"gravityValue\");\n\n    resetBtn.addEventListener(\"click\", () => {\n      createSceneObjects();\n    });\n\n    slowMoBtn.addEventListener(\"click\", () => {\n      slowMotion = !slowMotion;\n      timeScale = slowMotion ? 0.25 : 1.0;\n      slowMoBtn.textContent = \"Slow Motion: \" + (slowMotion ? \"ON\" : \"OFF\");\n    });\n\n    gravitySlider.addEventListener(\"input\", () => {\n      const g = parseFloat(gravitySlider.value);\n      gravityValue.textContent = g.toFixed(1);\n      world.gravity.set(0, g, 0);\n    });\n  }\n\n  // ---------------------------------------------------------------------------\n  // Mouse picking & dragging (constraint-based)\n  // ---------------------------------------------------------------------------\n  function getIntersectObject(event) {\n    const rect = renderer.domElement.getBoundingClientRect();\n    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n    raycaster.setFromCamera(mouse, camera);\n\n    const meshes = objects.map(o => o.mesh);\n    const intersects = raycaster.intersectObjects(meshes, false);\n    if (intersects.length === 0) return null;\n    return intersects[0];\n  }\n\n  function onPointerDown(event) {\n    // Use middle button or right button, or Ctrl+Left as drag\n    const isDragButton =\n      event.button === 1 ||\n      event.button === 2 ||\n      (event.button === 0 && (event.ctrlKey || event.metaKey));\n\n    if (!isDragButton) return;\n\n    const hit = getIntersectObject(event);\n    if (!hit) return;\n\n    event.preventDefault();\n\n    const pickedMesh = hit.object;\n    const obj = objects.find(o => o.mesh === pickedMesh);\n    if (!obj || !obj.body || obj.body.mass === 0) return;\n\n    dragBody = obj.body;\n\n    // Hit point in world coordinates\n    const hitPointWorld = new CANNON.Vec3(\n      hit.point.x,\n      hit.point.y,\n      hit.point.z\n    );\n\n    // Local pivot in body coordinates\n    const pivot = new CANNON.Vec3();\n    dragBody.pointToLocalFrame(hitPointWorld, pivot);\n    dragPivot.copy(pivot);\n\n    // Create a kinematic body at the hit point\n    const dragMass = 0;\n    const dragShape = new CANNON.Sphere(0.1);\n    const dragPointBody = new CANNON.Body({ mass: dragMass });\n    dragPointBody.addShape(dragShape);\n    dragPointBody.position.copy(hitPointWorld);\n    dragPointBody.collisionFilterGroup = 0;\n    dragPointBody.collisionFilterMask = 0;\n    world.addBody(dragPointBody);\n    dragPoint = dragPointBody.position;\n\n    // Constraint between drag point body and real body\n    const c = new CANNON.PointToPointConstraint(\n      dragBody,\n      dragPivot,\n      dragPointBody,\n      new CANNON.Vec3(0, 0, 0)\n    );\n    world.addConstraint(c);\n    dragConstraint = c;\n\n    // Update dragPoint position during move\n    updateDragPoint(event);\n  }\n\n  function onPointerMove(event) {\n    if (!dragConstraint) return;\n    updateDragPoint(event);\n  }\n\n  function onPointerUp() {\n    if (dragConstraint) {\n      world.removeConstraint(dragConstraint);\n      const b = dragConstraint.bodyB;\n      if (b) {\n        world.removeBody(b);\n      }\n      dragConstraint = null;\n      dragBody = null;\n    }\n  }\n\n  function updateDragPoint(event) {\n    const rect = renderer.domElement.getBoundingClientRect();\n    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n    raycaster.setFromCamera(mouse, camera);\n\n    const distance = camera.position.distanceTo(controls.target);\n    const dir = raycaster.ray.direction.clone().multiplyScalar(distance);\n    const newPos = raycaster.ray.origin.clone().add(dir);\n\n    dragPoint.set(newPos.x, newPos.y, newPos.z);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Animation loop\n  // ---------------------------------------------------------------------------\n  function animate() {\n    requestAnimationFrame(animate);\n\n    const now = performance.now() / 1000;\n    let dt = now - lastTime;\n    lastTime = now;\n\n    // Clamp dt to avoid large jumps when tab is inactive\n    dt = Math.min(dt, 0.05);\n    const fixedTimeStep = 1 / 60;\n    const maxSubSteps = 3;\n\n    world.step(fixedTimeStep * timeScale, dt * timeScale, maxSubSteps);\n\n    // Sync meshes with physics bodies\n    for (const o of objects) {\n      o.mesh.position.copy(o.body.position);\n      o.mesh.quaternion.copy(o.body.quaternion);\n    }\n\n    controls.update();\n    renderer.render(scene, camera);\n  }\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 38.99516987800598,
    "status": "success",
    "timestamp": "2025-11-19 22:08:57",
    "evaluation": {
      "test_name": "physics_playground",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
        ],
        "warnings": [],
        "screenshot": "output/screenshots/physics_playground.png",
        "render_time_ms": 687.19,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 687.19ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
            ]
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "The code provided does not fully implement the requirements of the original request. Several critical components are missing, which are essential for fulfilling the objective of integrating Three.js with a physics engine and enabling interactive functionality. Specifically, the code lacks the inclusion and setup of Three.js and a physics engine like cannon-es, which are fundamental to creating the described physics playground. Furthermore, there is no JavaScript logic to handle physics simulations, no mention of stackable boxes, spheres, hinge joints, or a ragdoll setup. Interactive elements such as mouse dragging and a procedural animation loop are absent. The UI elements for resetting the scene, a gravity slider, and a slow-motion toggle exist, but without the underlying functionality to support them.",
        "strengths": "The HTML and CSS structure is well-organized and modern, following HTML5 standards with a clean layout for UI components. The UI design is user-friendly and visually appealing.",
        "weaknesses": "The critical weakness is the lack of JavaScript logic to initialize, display, and manage the Three.js scene and physics simulation. The code does not include necessary script tags for Three.js or cannon-es CDN links or any logic to manipulate the scene and physics interactions. There are missing functionalities - stacking objects, physics engine integration, animation loop, interactive controls, and Three.js setup.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "data_driven_dashboard",
    "prompt": "Create a complete HTML file with Three.js that creates a 3D analytics scene turning a random dataset into bars, scatter points, and ribbons on a 3D grid. Include axis helpers, tooltips on hover, camera tween to views, theme toggle (dark/light), and CSV export of generated data. The HTML file should be self-contained with Three.js loaded from CDN and include sample data generation. Save the output as 'data_dashboard.html'.",
    "response": "```html\n<!-- Save this file as: data_dashboard.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>3D Data Dashboard - Three.js</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      height: 100%;\n      font-family: system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n      background-color: #111;\n      color: #eee;\n    }\n\n    #container {\n      width: 100vw;\n      height: 100vh;\n      position: relative;\n    }\n\n    #overlayUI {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      z-index: 10;\n      display: flex;\n      flex-direction: column;\n      gap: 6px;\n      background: rgba(0, 0, 0, 0.55);\n      padding: 8px 10px;\n      border-radius: 6px;\n      backdrop-filter: blur(4px);\n    }\n\n    #overlayUI h1 {\n      margin: 0 0 4px 0;\n      font-size: 15px;\n      font-weight: 600;\n    }\n\n    #overlayUI .row {\n      display: flex;\n      gap: 6px;\n      flex-wrap: wrap;\n      align-items: center;\n    }\n\n    button, select {\n      border-radius: 4px;\n      border: 1px solid #555;\n      background: #222;\n      color: #eee;\n      padding: 4px 8px;\n      font-size: 12px;\n      cursor: pointer;\n    }\n\n    button:hover, select:hover {\n      background: #333;\n    }\n\n    button:active {\n      transform: translateY(1px);\n    }\n\n    #themeToggle {\n      min-width: 90px;\n    }\n\n    #statusText {\n      font-size: 11px;\n      opacity: 0.8;\n    }\n\n    #tooltip {\n      position: absolute;\n      padding: 4px 6px;\n      font-size: 11px;\n      background: rgba(0, 0, 0, 0.8);\n      color: #fff;\n      border-radius: 4px;\n      pointer-events: none;\n      white-space: nowrap;\n      z-index: 20;\n      opacity: 0;\n      transition: opacity 0.1s ease-out;\n    }\n\n    .light-theme body {\n      background-color: #f7f7f7;\n      color: #111;\n    }\n\n    .light-theme #overlayUI {\n      background: rgba(255, 255, 255, 0.8);\n      color: #111;\n    }\n\n    .light-theme button,\n    .light-theme select {\n      background: #fff;\n      color: #111;\n      border-color: #bbb;\n    }\n\n    .light-theme button:hover,\n    .light-theme select:hover {\n      background: #f0f0f0;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"container\"></div>\n\n  <div id=\"overlayUI\">\n    <h1>3D Analytics Dashboard</h1>\n    <div class=\"row\">\n      <button id=\"regenBtn\">Regenerate Data</button>\n      <button id=\"exportBtn\">Export CSV</button>\n      <button id=\"themeToggle\">Dark Theme</button>\n    </div>\n    <div class=\"row\">\n      <label for=\"viewSelect\" style=\"font-size:12px;\">Camera View:</label>\n      <select id=\"viewSelect\">\n        <option value=\"free\">Free Orbit</option>\n        <option value=\"iso\">Isometric</option>\n        <option value=\"top\">Top</option>\n        <option value=\"sideX\">Side X</option>\n        <option value=\"sideZ\">Side Z</option>\n      </select>\n    </div>\n    <div id=\"statusText\">Hover a bar, point or ribbon for details.</div>\n  </div>\n\n  <div id=\"tooltip\"></div>\n\n  <!-- Three.js + OrbitControls from CDN -->\n  <script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js\"></script>\n  <script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js\"></script>\n\n  <script>\n    // Core globals\n    let scene, camera, renderer, controls;\n    let raycaster, mouse;\n    let tooltipEl = document.getElementById('tooltip');\n\n    // Collections\n    let data = [];\n    let barsGroup, pointsGroup, ribbonsGroup, gridHelper, axesHelper;\n    let pickableObjects = [];\n\n    // Theme and camera tween state\n    let isDarkTheme = true;\n    let tweenActive = false;\n    let tweenStart = null;\n    let tweenDuration = 800; // ms\n    let tweenFrom = {}, tweenTo = {};\n\n    const container = document.getElementById('container');\n\n    init();\n    animate();\n\n    function init() {\n      // Scene\n      scene = new THREE.Scene();\n      scene.background = new THREE.Color(0x050608);\n\n      // Camera\n      const aspect = window.innerWidth / window.innerHeight;\n      camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);\n      camera.position.set(40, 30, 40);\n\n      // Renderer\n      renderer = new THREE.WebGLRenderer({ antialias: true });\n      renderer.setPixelRatio(window.devicePixelRatio);\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      renderer.shadowMap.enabled = true;\n      container.appendChild(renderer.domElement);\n\n      // Controls\n      controls = new THREE.OrbitControls(camera, renderer.domElement);\n      controls.enableDamping = true;\n      controls.dampingFactor = 0.08;\n      controls.minDistance = 10;\n      controls.maxDistance = 120;\n      controls.target.set(10, 0, 10);\n      controls.update();\n\n      // Lights\n      const ambient = new THREE.AmbientLight(0xffffff, 0.5);\n      scene.add(ambient);\n\n      const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);\n      dirLight.position.set(40, 60, 20);\n      dirLight.castShadow = true;\n      dirLight.shadow.mapSize.set(2048, 2048);\n      scene.add(dirLight);\n\n      // Helpers\n      const size = 40;\n      const divisions = 20;\n      gridHelper = new THREE.GridHelper(size, divisions, 0x555555, 0x333333);\n      gridHelper.position.set(10, 0, 10);\n      scene.add(gridHelper);\n\n      axesHelper = new THREE.AxesHelper(15);\n      axesHelper.position.set(0, 0.01, 0);\n      scene.add(axesHelper);\n\n      // Data groups\n      barsGroup = new THREE.Group();\n      pointsGroup = new THREE.Group();\n      ribbonsGroup = new THREE.Group();\n      scene.add(barsGroup);\n      scene.add(pointsGroup);\n      scene.add(ribbonsGroup);\n\n      // Raycaster\n      raycaster = new THREE.Raycaster();\n      mouse = new THREE.Vector2();\n\n      // Generate initial data and objects\n      generateData();\n      buildVisuals();\n\n      // Events\n      window.addEventListener('resize', onWindowResize);\n      window.addEventListener('mousemove', onMouseMove);\n      window.addEventListener('mouseout', () => setTooltipVisible(false));\n      window.addEventListener('mouseleave', () => setTooltipVisible(false));\n\n      document.getElementById('regenBtn').addEventListener('click', () => {\n        generateData();\n        buildVisuals();\n      });\n\n      document.getElementById('exportBtn').addEventListener('click', exportCSV);\n\n      document.getElementById('themeToggle').addEventListener('click', () => {\n        isDarkTheme = !isDarkTheme;\n        applyTheme();\n      });\n\n      document.getElementById('viewSelect').addEventListener('change', (e) => {\n        tweenToView(e.target.value);\n      });\n\n      applyTheme();\n    }\n\n    // Generate random sample data\n    function generateData() {\n      data = [];\n      const count = 80; // total points\n      const maxX = 20;\n      const maxZ = 20;\n\n      for (let i = 0; i < count; i++) {\n        const x = Math.floor(Math.random() * maxX);\n        const z = Math.floor(Math.random() * maxZ);\n        const value = Math.random() * 10 + 1; // height\n        const category = ['A', 'B', 'C'][Math.floor(Math.random() * 3)];\n        const series = Math.floor(Math.random() * 4); // for ribbons\n        data.push({ id: i, x, z, value, category, series });\n      }\n    }\n\n    // Build bars, points and ribbons from current data\n    function buildVisuals() {\n      // Clear existing\n      barsGroup.clear();\n      pointsGroup.clear();\n      ribbonsGroup.clear();\n      pickableObjects = [];\n\n      const barGeom = new THREE.BoxGeometry(0.8, 1, 0.8);\n      const pointGeom = new THREE.SphereGeometry(0.18, 16, 16);\n\n      const categoryColors = {\n        A: new THREE.Color(0x5DA5DA),\n        B: new THREE.Color(0xF15854),\n        C: new THREE.Color(0x60BD68)\n      };\n\n      // Bars and points\n      data.forEach(d => {\n        const c = categoryColors[d.category] || new THREE.Color(0xffffff);\n\n        // Bars\n        const barMat = new THREE.MeshStandardMaterial({\n          color: c.clone().multiplyScalar(0.9),\n          roughness: 0.4,\n          metalness: 0.2\n        });\n        const bar = new THREE.Mesh(barGeom, barMat);\n        bar.castShadow = true;\n        bar.receiveShadow = true;\n\n        bar.scale.y = d.value;\n        bar.position.set(d.x, d.value / 2, d.z);\n        bar.userData = { type: 'bar', data: d };\n        barsGroup.add(bar);\n        pickableObjects.push(bar);\n\n        // Scatter points\n        const pointMat = new THREE.MeshStandardMaterial({\n          color: c,\n          emissive: c.clone().multiplyScalar(0.2),\n          roughness: 0.3\n        });\n        const point = new THREE.Mesh(pointGeom, pointMat);\n        point.position.set(d.x, d.value + 0.2, d.z);\n        point.userData = { type: 'point', data: d };\n        pointsGroup.add(point);\n        pickableObjects.push(point);\n      });\n\n      // Ribbons per series (sorted by x then z)\n      const bySeries = {};\n      data.forEach(d => {\n        if (!bySeries[d.series]) bySeries[d.series] = [];\n        bySeries[d.series].push(d);\n      });\n\n      Object.keys(bySeries).forEach((s, idx) => {\n        const seriesData = bySeries[s].slice().sort((a, b) => {\n          if (a.x === b.x) return a.z - b.z;\n          return a.x - b.x;\n        });\n\n        if (seriesData.length < 2) return;\n\n        const ribbonColor = new THREE.Color().setHSL((idx * 0.2) % 1, 0.6, 0.5);\n        const ribbonMat = new THREE.MeshStandardMaterial({\n          color: ribbonColor,\n          side: THREE.DoubleSide,\n          transparent: true,\n          opacity: 0.6\n        });\n\n        const points = [];\n        seriesData.forEach((d, i) => {\n          const y = d.value + 0.4; // slightly above bars\n          points.push(new THREE.Vector3(d.x, y, d.z));\n        });\n\n        // Create a tube-like ribbon (swept rectangle) along a catmull curve\n        const curve = new THREE.CatmullRomCurve3(points);\n        const segments = Math.max(20, points.length * 4);\n        const tubeRadius = 0.1;\n        const radialSegments = 6;\n        const closed = false;\n        const tubeGeom = new THREE.TubeGeometry(curve, segments, tubeRadius, radialSegments, closed);\n        const mesh = new THREE.Mesh(tubeGeom, ribbonMat);\n        mesh.castShadow = true;\n        mesh.userData = { type: 'ribbon', series: Number(s), points: seriesData };\n        ribbonsGroup.add(mesh);\n        pickableObjects.push(mesh);\n      });\n    }\n\n    // Theme application\n    function applyTheme() {\n      if (isDarkTheme) {\n        document.documentElement.classList.remove('light-theme');\n        scene.background = new THREE.Color(0x050608);\n        gridHelper.material.color.set(0x333333);\n        gridHelper.material.opacity = 0.9;\n        axesHelper.children.forEach(ch => {\n          if (ch.material) ch.material.linewidth = 2;\n        });\n        document.getElementById('themeToggle').textContent = 'Light Theme';\n      } else {\n        document.documentElement.classList.add('light-theme');\n        scene.background = new THREE.Color(0xf5f5f5);\n        gridHelper.material.color.set(0xbbbbbb);\n        gridHelper.material.opacity = 1.0;\n        document.getElementById('themeToggle').textContent = 'Dark Theme';\n      }\n    }\n\n    // CSV export\n    function exportCSV() {\n      if (!data.length) return;\n      const headers = ['id', 'x', 'z', 'value', 'category', 'series'];\n      const rows = data.map(d => [d.id, d.x, d.z, d.value.toFixed(4), d.category, d.series]);\n      const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\\n');\n      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'random_3d_dataset.csv';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }\n\n    // Tooltip helpers\n    function setTooltipVisible(visible) {\n      tooltipEl.style.opacity = visible ? '1' : '0';\n    }\n\n    function setTooltipContent(html, x, y) {\n      tooltipEl.innerHTML = html;\n      tooltipEl.style.left = (x + 10) + 'px';\n      tooltipEl.style.top = (y + 10) + 'px';\n    }\n\n    function formatTooltip(obj) {\n      const ud = obj.userData;\n      if (!ud) return '';\n      if (ud.type === 'bar' || ud.type === 'point') {\n        const d = ud.data;\n        return `\n          <b>${ud.type === 'bar' ? 'Bar' : 'Point'}</b><br/>\n          id: ${d.id}<br/>\n          x: ${d.x}, z: ${d.z}<br/>\n          value: ${d.value.toFixed(2)}<br/>\n          category: ${d.category}<br/>\n          series: ${d.series}\n        `;\n      }\n      if (ud.type === 'ribbon') {\n        return `\n          <b>Ribbon Series ${ud.series}</b><br/>\n          points: ${ud.points.length}<br/>\n          value range: ${getSeriesRange(ud.points)}\n        `;\n      }\n      return '';\n    }\n\n    function getSeriesRange(arr) {\n      let min = Infinity, max = -Infinity;\n      arr.forEach(d => {\n        if (d.value < min) min = d.value;\n        if (d.value > max) max = d.value;\n      });\n      return `${min.toFixed(2)} - ${max.toFixed(2)}`;\n    }\n\n    // Camera tweening without extra libs\n    function tweenToView(view) {\n      // free mode = no tween (just keep controls)\n      if (view === 'free') return;\n\n      let targetPos, targetLook = new THREE.Vector3(10, 0, 10);\n\n      switch (view) {\n        case 'iso':\n          targetPos = new THREE.Vector3(40, 35, 40);\n          break;\n        case 'top':\n          targetPos = new THREE.Vector3(10, 70, 10);\n          targetLook = new THREE.Vector3(10, 0, 10);\n          break;\n        case 'sideX':\n          targetPos = new THREE.Vector3(60, 15, 10);\n          break;\n        case 'sideZ':\n          targetPos = new THREE.Vector3(10, 15, 60);\n          break;\n        default:\n          targetPos = camera.position.clone();\n      }\n\n      tweenActive = true;\n      tweenStart = performance.now();\n      tweenFrom = {\n        camPos: camera.position.clone(),\n        target: controls.target.clone()\n      };\n      tweenTo = {\n        camPos: targetPos,\n        target: targetLook\n      };\n    }\n\n    function updateTween() {\n      if (!tweenActive) return;\n      const now = performance.now();\n      const elapsed = now - tweenStart;\n      const t = Math.min(1, elapsed / tweenDuration);\n\n      const ease = t < 0.5\n        ? 2 * t * t\n        : -1 + (4 - 2 * t) * t; // simple ease-in-out\n\n      camera.position.lerpVectors(tweenFrom.camPos, tweenTo.camPos, ease);\n      controls.target.lerpVectors(tweenFrom.target, tweenTo.target, ease);\n      controls.update();\n\n      if (t >= 1) {\n        tweenActive = false;\n      }\n    }\n\n    // Events\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    function onMouseMove(event) {\n      // Normalized device coords\n      const rect = renderer.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n\n      mouse.x = (x / rect.width) * 2 - 1;\n      mouse.y = -(y / rect.height) * 2 + 1;\n\n      raycaster.setFromCamera(mouse, camera);\n      const intersects = raycaster.intersectObjects(pickableObjects, false);\n\n      if (intersects.length > 0) {\n        const obj = intersects[0].object;\n        const html = formatTooltip(obj);\n        if (html) {\n          setTooltipContent(html, event.clientX, event.clientY);\n          setTooltipVisible(true);\n          document.getElementById('statusText').textContent =\n            'Hovering over ' + obj.userData.type;\n        }\n      } else {\n        setTooltipVisible(false);\n        document.getElementById('statusText').textContent =\n          'Hover a bar, point or ribbon for details.';\n      }\n    }\n\n    // Animation loop\n    function animate() {\n      requestAnimationFrame(animate);\n      controls.update();\n      updateTween();\n      renderer.render(scene, camera);\n    }\n  </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 23.962323904037476,
    "status": "success",
    "timestamp": "2025-11-19 22:09:28",
    "evaluation": {
      "test_name": "data_driven_dashboard",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "THREE.OrbitControls is not a constructor"
        ],
        "warnings": [
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation",
          "[.WebGL-0x11c001ddc00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x11c001ddc00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x11c001ddc00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x11c001ddc00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat)"
        ],
        "screenshot": "output/screenshots/data_driven_dashboard.png",
        "render_time_ms": 647.81,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 647.81ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "THREE.OrbitControls is not a constructor"
            ]
          },
          {
            "level": "warning",
            "message": "\u26a0\ufe0f  9 warning(s)"
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "The HTML file begins by setting up some styling for a 3D data dashboard, with provisions for overlay UI, buttons, tooltips, and themes. However, the code is incomplete: it lacks the core Three.js setup, such as the importing of Three.js or the creation of a 3D scene. It also doesn't include data generation, rendering, tooltip functionality, camera views, or CSV export capabilities as requested. The code structure is good with a clean and understandable CSS, but the JavaScript functionality is almost non-existent. As the code does not fulfill the majority of requirements from the original request, it demonstrates poor completion based on the criteria provided.",
        "strengths": "1. The CSS is well-written and reflects a clear structure for UI components.\n2. The use of semantic HTML5 elements like `<!DOCTYPE html>`, `<html>`, `<head>`, and `<title>` is appropriate.\n3. Styles for dark/light themes are partially implemented.",
        "weaknesses": "1. Missing import for Three.js from a CDN, which is crucial for creating the 3D scene.\n2. No JavaScript logic to create and manage the 3D environment or handle user interactions as per the requirements.\n3. Incomplete feature implementation: no axis helpers, no tooltips, no camera control, no data export functionality.\n4. The code cuts off mid-way through a style rule, indicating incompleteness.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "molecular_explorer",
    "prompt": "Create a complete HTML file with Three.js that renders molecules from a provided or random molecular structure with ball-and-stick and space-filling modes, bond inference, atom coloring by element, section clipping, explode animation, and snapshot export. Include sample molecules (water, caffeine, DNA segment). The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'molecular_explorer.html'.",
    "response": "```html\n<!-- Save this file as: molecular_explorer.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Molecular Explorer - Three.js</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      width: 100%;\n      height: 100%;\n      font-family: Arial, sans-serif;\n      background-color: #111;\n      color: #eee;\n    }\n    #container {\n      position: absolute;\n      top: 0; left: 0;\n      width: 100%; height: 100%;\n      overflow: hidden;\n    }\n    #ui {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      z-index: 10;\n      background: rgba(0,0,0,0.65);\n      padding: 10px 12px;\n      border-radius: 6px;\n      font-size: 13px;\n      max-width: 320px;\n    }\n    #ui h1 {\n      font-size: 16px;\n      margin: 0 0 6px 0;\n      padding: 0;\n      font-weight: bold;\n    }\n    #ui label {\n      display: inline-block;\n      margin: 4px 0;\n    }\n    #ui select, #ui input[type=\"range\"], #ui button {\n      width: 100%;\n      margin: 4px 0;\n      font-size: 12px;\n    }\n    #ui small {\n      color: #aaa;\n      font-size: 11px;\n    }\n    #footer {\n      position: absolute;\n      bottom: 5px;\n      left: 10px;\n      z-index: 10;\n      background: rgba(0,0,0,0.5);\n      padding: 4px 8px;\n      border-radius: 4px;\n      font-size: 11px;\n      color: #ccc;\n    }\n    .row {\n      margin-top: 4px;\n      margin-bottom: 4px;\n    }\n    .inline {\n      display: inline-block;\n      width: 49%;\n    }\n  </style>\n</head>\n<body>\n<div id=\"container\"></div>\n\n<div id=\"ui\">\n  <h1>Molecular Explorer</h1>\n\n  <label for=\"moleculeSelect\">Molecule</label>\n  <select id=\"moleculeSelect\">\n    <option value=\"water\">Water (H\u2082O)</option>\n    <option value=\"caffeine\">Caffeine</option>\n    <option value=\"dna\">DNA Segment</option>\n    <option value=\"random\">Random small molecule</option>\n  </select>\n\n  <label for=\"modeSelect\">Render mode</label>\n  <select id=\"modeSelect\">\n    <option value=\"ballstick\">Ball-and-stick</option>\n    <option value=\"spacefill\">Space-filling</option>\n  </select>\n\n  <div class=\"row\">\n    <div class=\"inline\">\n      <label for=\"explodeRange\">Explode</label>\n      <input id=\"explodeRange\" type=\"range\" min=\"0\" max=\"1.5\" step=\"0.01\" value=\"0\">\n    </div>\n    <div class=\"inline\">\n      <label for=\"clipRange\">Section clip</label>\n      <input id=\"clipRange\" type=\"range\" min=\"-10\" max=\"10\" step=\"0.1\" value=\"10\">\n    </div>\n  </div>\n\n  <button id=\"explodeAnimBtn\">Toggle Explode Animation</button>\n  <button id=\"snapshotBtn\">Snapshot to PNG</button>\n\n  <label for=\"customMol\">Custom molecule (JSON)</label>\n  <textarea id=\"customMol\" rows=\"4\" style=\"width:100%;font-size:11px;\"></textarea>\n  <button id=\"loadCustomBtn\">Load custom JSON</button>\n\n  <small>\n    JSON format: { \"atoms\":[{\"element\":\"C\",\"x\":0,\"y\":0,\"z\":0},...],\n    \"bonds\":[{\"a\":0,\"b\":1},...]}<br/>\n    If \"bonds\" is omitted, bonds are inferred from distances.\n  </small>\n</div>\n\n<div id=\"footer\">\n  Drag: rotate \u2022 Scroll: zoom \u2022 Right-drag: pan \u2022 Explode + clip to explore interior.\n</div>\n\n<!-- Three.js and helpers from CDN -->\n<script src=\"https://unpkg.com/three@0.160.0/build/three.min.js\"></script>\n<script src=\"https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js\"></script>\n\n<script>\n// =====================================================\n// Basic Three.js setup\n// =====================================================\nlet scene, camera, renderer, controls;\nlet currentGroup = null;\nlet currentMoleculeData = null;\nlet explodeFactor = 0;\nlet explodeAnimating = false;\nlet explodeDirectionVectors = [];\nlet clipPlane;\nlet ballStickMode = true;\n\nconst container = document.getElementById('container');\n\ninit();\nanimate();\n\nfunction init() {\n  scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x050505);\n\n  const width = window.innerWidth;\n  const height = window.innerHeight;\n\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 35);\n\n  renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(window.devicePixelRatio || 1);\n  container.appendChild(renderer.domElement);\n\n  controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.1;\n  controls.rotateSpeed = 0.5;\n\n  // Lights\n  const ambLight = new THREE.AmbientLight(0xffffff, 0.3);\n  scene.add(ambLight);\n\n  const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);\n  dirLight1.position.set(10, 10, 10);\n  scene.add(dirLight1);\n\n  const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.6);\n  dirLight2.position.set(-10, -5, -10);\n  scene.add(dirLight2);\n\n  // Clipping plane (YZ plane, clipping positive X)\n  clipPlane = new THREE.Plane(new THREE.Vector3(1, 0, 0), 10); // d is adjustable\n  renderer.localClippingEnabled = true;\n\n  // UI events\n  document.getElementById('moleculeSelect').addEventListener('change', onMoleculeChange);\n  document.getElementById('modeSelect').addEventListener('change', onModeChange);\n  document.getElementById('explodeRange').addEventListener('input', onExplodeChange);\n  document.getElementById('clipRange').addEventListener('input', onClipChange);\n  document.getElementById('explodeAnimBtn').addEventListener('click', () => {\n    explodeAnimating = !explodeAnimating;\n  });\n  document.getElementById('snapshotBtn').addEventListener('click', saveSnapshot);\n  document.getElementById('loadCustomBtn').addEventListener('click', loadCustomMolecule);\n\n  window.addEventListener('resize', onWindowResize, false);\n\n  // Initial molecule\n  loadMoleculeData(sampleMolecules.water);\n}\n\nfunction onWindowResize() {\n  const width = window.innerWidth;\n  const height = window.innerHeight;\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n  renderer.setSize(width, height);\n}\n\n// =====================================================\n// Molecule data\n// =====================================================\n\n// Minimal van der Waals radii for space-filling (in \u00c5, arbitrary scale)\nconst vdwRadii = {\n  H: 1.2,\n  C: 1.7,\n  N: 1.55,\n  O: 1.52,\n  P: 1.8,\n  S: 1.8\n};\n\n// Atom colors by element (CPK-like)\nconst elementColors = {\n  H: 0xffffff,\n  C: 0x444444,\n  N: 0x3050f8,\n  O: 0xff0d0d,\n  F: 0x90e050,\n  Cl: 0x1ff01f,\n  Br: 0xa62929,\n  I: 0x940094,\n  P: 0xffa500,\n  S: 0xffff30,\n  B: 0xffc0c0,\n  Fe: 0xe06633,\n  default: 0xaaaaaa\n};\n\n// Approximate covalent radii for bond inference (\u00c5)\nconst covalentRadii = {\n  H: 0.31,\n  C: 0.76,\n  N: 0.71,\n  O: 0.66,\n  P: 1.07,\n  S: 1.05,\n  default: 0.8\n};\n\n// Sample molecules\nconst sampleMolecules = {\n  // Coordinates in \u00c5ngstrom; small, simple\n  water: {\n    name: \"Water\",\n    atoms: [\n      { element: \"O\", x: 0.000, y: 0.000, z: 0.000 },\n      { element: \"H\", x: 0.9572, y: 0.000, z: 0.000 },\n      { element: \"H\", x: -0.239, y: 0.927, z: 0.000 }\n    ]\n    // bonds inferred\n  },\n\n  // Caffeine coordinates (simplified, approximate planar structure)\n  caffeine: {\n    name: \"Caffeine\",\n    atoms: [\n      { element: \"C\", x: 0.000,  y: 1.393, z: 0.000 },\n      { element: \"N\", x: 1.214,  y: 0.696, z: 0.000 },\n      { element: \"C\", x: 1.214,  y:-0.696, z: 0.000 },\n      { element: \"N\", x: 0.000,  y:-1.393, z: 0.000 },\n      { element: \"C\", x:-1.214,  y:-0.696, z: 0.000 },\n      { element: \"N\", x:-1.214,  y: 0.696, z: 0.000 },\n      { element: \"C\", x: 2.428,  y: 1.393, z: 0.000 },\n      { element: \"O\", x: 3.642,  y: 0.696, z: 0.000 },\n      { element: \"N\", x: 2.428,  y:-1.393, z: 0.000 },\n      { element: \"C\", x: 3.642,  y:-0.696, z: 0.000 },\n      { element: \"O\", x: 4.856,  y:-1.393, z: 0.000 },\n      { element: \"C\", x:-2.428,  y:-1.393, z: 0.000 },\n      { element: \"O\", x:-3.642,  y:-0.696, z: 0.000 },\n      { element: \"N\", x:-2.428,  y: 1.393, z: 0.000 },\n      { element: \"C\", x:-3.642,  y: 0.696, z: 0.000 },\n      // Some hydrogens\n      { element: \"H\", x: 0.000,  y: 2.479, z: 0.000 },\n      { element: \"H\", x: 0.000,  y:-2.479, z: 0.000 },\n      { element: \"H\", x: 2.428,  y: 2.479, z: 0.000 },\n      { element: \"H\", x: 2.428,  y:-2.479, z: 0.000 },\n      { element: \"H\", x:-2.428, y: 2.479, z: 0.000 },\n      { element: \"H\", x:-2.428, y:-2.479, z: 0.000 },\n      { element: \"H\", x: 3.642,  y: 1.781, z: 0.000 },\n      { element: \"H\", x:-3.642, y: 1.781, z: 0.000 }\n    ]\n  },\n\n  // Very small DNA-like segment (simplified: backbone + two base pairs)\n  dna: {\n    name: \"DNA segment\",\n    atoms: [\n      // Backbone (P-O-C)\n      { element: \"P\", x: -4.0, y:  0.0, z: 0.0 },\n      { element: \"O\", x: -3.0, y:  1.0, z: 0.0 },\n      { element: \"O\", x: -3.0, y: -1.0, z: 0.0 },\n      { element: \"C\", x: -2.0, y:  0.0, z: 0.0 },\n      { element: \"C\", x: -1.0, y:  0.5, z: 0.0 },\n      { element: \"C\", x:  0.0, y:  1.0, z: 0.0 },\n\n      { element: \"P\", x:  4.0, y:  0.0, z: 0.0 },\n      { element: \"O\", x:  3.0, y:  1.0, z: 0.0 },\n      { element: \"O\", x:  3.0, y: -1.0, z: 0.0 },\n      { element: \"C\", x:  2.0, y:  0.0, z: 0.0 },\n      { element: \"C\", x:  1.0, y:  0.5, z: 0.0 },\n      { element: \"C\", x:  0.0, y: -1.0, z: 0.0 },\n\n      // Base pair 1 (A-T, heavily simplified)\n      { element: \"N\", x: -0.5, y:  2.0, z: 0.8 },\n      { element: \"C\", x:  0.5, y:  2.3, z: 0.8 },\n      { element: \"N\", x:  1.5, y:  2.0, z: 0.8 },\n\n      { element: \"N\", x: -0.5, y: -2.0, z: -0.8 },\n      { element: \"C\", x:  0.5, y: -2.3, z: -0.8 },\n      { element: \"N\", x:  1.5, y: -2.0, z: -0.8 },\n\n      // Base pair 2 (G-C, simplified)\n      { element: \"N\", x: -1.0, y:  2.5, z: -0.8 },\n      { element: \"C\", x:  0.0, y:  3.0, z: -0.8 },\n      { element: \"N\", x:  1.0, y:  2.5, z: -0.8 },\n\n      { element: \"N\", x: -1.0, y: -2.5, z:  0.8 },\n      { element: \"C\", x:  0.0, y: -3.0, z:  0.8 },\n      { element: \"N\", x:  1.0, y: -2.5, z:  0.8 },\n\n      // A few hydrogens\n      { element: \"H\", x: -5.0, y:  0.0, z: 0.0 },\n      { element: \"H\", x:  5.0, y:  0.0, z: 0.0 },\n      { element: \"H\", x: -2.0, y:  1.1, z: 0.0 },\n      { element: \"H\", x:  2.0, y: -1.1, z: 0.0 }\n    ]\n  }\n};\n\n// =====================================================\n// Molecule utilities\n// =====================================================\n\nfunction getElementColor(element) {\n  return elementColors[element] || elementColors.default;\n}\n\nfunction getVDWRadius(element) {\n  return vdwRadii[element] || 1.5;\n}\n\nfunction getCovalentRadius(element) {\n  return covalentRadii[element] || covalentRadii.default;\n}\n\n// Infer bonds by distance between atoms\nfunction inferBonds(mol) {\n  const atoms = mol.atoms;\n  const bonds = [];\n  for (let i = 0; i < atoms.length; i++) {\n    const a = atoms[i];\n    for (let j = i + 1; j < atoms.length; j++) {\n      const b = atoms[j];\n      const dx = a.x - b.x;\n      const dy = a.y - b.y;\n      const dz = a.z - b.z;\n      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n      const rA = getCovalentRadius(a.element);\n      const rB = getCovalentRadius(b.element);\n      const maxDist = (rA + rB) * 1.25; // fudge factor\n      if (dist > 0.1 && dist <= maxDist) {\n        bonds.push({ a: i, b: j });\n      }\n    }\n  }\n  mol.bonds = bonds;\n}\n\n// Random small molecule generator\nfunction generateRandomMolecule(numAtoms = 12) {\n  const elements = [\"C\", \"C\", \"C\", \"H\", \"H\", \"H\", \"H\", \"O\", \"N\", \"S\"];\n  const atoms = [];\n  for (let i = 0; i < numAtoms; i++) {\n    const element = elements[Math.floor(Math.random() * elements.length)];\n    atoms.push({\n      element,\n      x: (Math.random() - 0.5) * 8,\n      y: (Math.random() - 0.5) * 8,\n      z: (Math.random() - 0.5) * 8\n    });\n  }\n  return { name: \"Random molecule\", atoms };\n}\n\n// Build Three.js group from molecule data\nfunction buildMoleculeGroup(mol, mode) {\n  if (!mol.bonds) inferBonds(mol);\n\n  const group = new THREE.Group();\n\n  // Prepare clipping planes\n  const clippingPlanes = [clipPlane];\n\n  // Atoms\n  const atomMeshes = [];\n  const atomPositions = [];\n\n  const ballStickAtomRadius = 0.35;\n  const bondRadius = 0.12;\n\n  const spaceFillScale = 0.4; // global scale to keep sizes reasonable\n\n  for (let i = 0; i < mol.atoms.length; i++) {\n    const a = mol.atoms[i];\n    const color = getElementColor(a.element);\n    const radius = mode === \"spacefill\"\n      ? getVDWRadius(a.element) * spaceFillScale\n      : ballStickAtomRadius;\n\n    const geom = new THREE.SphereGeometry(radius, 24, 24);\n    const mat = new THREE.MeshPhongMaterial({\n      color,\n      shininess: 50,\n      specular: 0x111111,\n      clippingPlanes,\n      clipShadows: true\n    });\n\n    const mesh = new THREE.Mesh(geom, mat);\n    mesh.position.set(a.x, a.y, a.z);\n    mesh.userData = { atomIndex: i, basePosition: mesh.position.clone() };\n\n    group.add(mesh);\n    atomMeshes.push(mesh);\n    atomPositions.push(mesh.position.clone());\n  }\n\n  // Bonds (only in ball-and-stick mode)\n  if (mode === \"ballstick\") {\n    const cylinderGeom = new THREE.CylinderGeometry(bondRadius, bondRadius, 1, 16, 1, true);\n    const bondMat = new THREE.MeshPhongMaterial({\n      color: 0xcccccc,\n      shininess: 30,\n      clippingPlanes,\n      clipShadows: true\n    });\n\n    mol.bonds.forEach((bond) => {\n      const start = atomPositions[bond.a];\n      const end = atomPositions[bond.b];\n\n      const bondMesh = new THREE.Mesh(cylinderGeom, bondMat);\n      alignCylinderToPoints(bondMesh, start, end);\n      group.add(bondMesh);\n    });\n  }\n\n  // Compute explode directions (radial from center)\n  const center = new THREE.Vector3();\n  mol.atoms.forEach((a) => {\n    center.x += a.x;\n    center.y += a.y;\n    center.z += a.z;\n  });\n  center.multiplyScalar(1 / mol.atoms.length);\n\n  explodeDirectionVectors = atomPositions.map((pos) => {\n    const dir = new THREE.Vector3().subVectors(pos, center);\n    if (dir.lengthSq() < 1e-4) dir.set(Math.random(), Math.random(), Math.random());\n    return dir.normalize();\n  });\n\n  group.userData.atomMeshes = atomMeshes;\n  group.userData.molecule = mol;\n\n  // Center group\n  const box = new THREE.Box3().setFromObject(group);\n  const size = new THREE.Vector3();\n  box.getSize(size);\n  const centerBox = new THREE.Vector3();\n  box.getCenter(centerBox);\n  group.position.sub(centerBox);\n\n  return group;\n}\n\n// Align cylinder between two points\nfunction alignCylinderToPoints(mesh, start, end) {\n  const dir = new THREE.Vector3().subVectors(end, start);\n  const length = dir.length();\n\n  mesh.scale.set(1, length, 1); // y-axis is height\n\n  const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);\n  mesh.position.copy(mid);\n\n  const axis = new THREE.Vector3(0, 1, 0);\n  dir.normalize();\n  const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, dir);\n  mesh.quaternion.copy(quaternion);\n}\n\n// =====================================================\n// UI Handlers\n// =====================================================\n\nfunction onMoleculeChange() {\n  const val = document.getElementById('moleculeSelect').value;\n  let mol;\n  if (val === \"water\") mol = sampleMolecules.water;\n  else if (val === \"caffeine\") mol = sampleMolecules.caffeine;\n  else if (val === \"dna\") mol = sampleMolecules.dna;\n  else if (val === \"random\") mol = generateRandomMolecule(18);\n\n  loadMoleculeData(mol);\n}\n\nfunction onModeChange() {\n  ballStickMode = document.getElementById('modeSelect').value === \"ballstick\";\n  if (currentMoleculeData) {\n    loadMoleculeData(currentMoleculeData, false);\n  }\n}\n\nfunction onExplodeChange(e) {\n  explodeFactor = parseFloat(e.target.value);\n  updateExplode();\n}\n\nfunction onClipChange(e) {\n  const d = parseFloat(e.target.value);\n  clipPlane.constant = d;\n}\n\n// =====================================================\n// Loading and rebuilding\n// =====================================================\n\nfunction loadMoleculeData(mol, resetControls = true) {\n  currentMoleculeData = JSON.parse(JSON.stringify(mol)); // clone\n\n  if (currentGroup) {\n    scene.remove(currentGroup);\n  }\n\n  const mode = ballStickMode ? \"ballstick\" : \"spacefill\";\n  currentGroup = buildMoleculeGroup(currentMoleculeData, mode);\n  scene.add(currentGroup);\n\n  explodeFactor = parseFloat(document.getElementById('explodeRange').value);\n  updateExplode();\n\n  if (resetControls) {\n    controls.target.set(0, 0, 0);\n    camera.position.set(0, 0, 35);\n    controls.update();\n  }\n}\n\n// Apply explode factor\nfunction updateExplode() {\n  if (!currentGroup) return;\n  const atomMeshes = currentGroup.userData.atomMeshes || [];\n  for (let i = 0; i < atomMeshes.length; i++) {\n    const mesh = atomMeshes[i];\n    const base = mesh.userData.basePosition;\n    const dir = explodeDirectionVectors[i];\n    const newPos = new THREE.Vector3().copy(base).addScaledVector(dir, explodeFactor * 5.0);\n    mesh.position.copy(newPos);\n  }\n\n  // Recompute bonds if in ball-and-stick (bond geometry does not know about explode,\n  // so fastest is to rebuild the whole group).\n  if (ballStickMode && currentMoleculeData) {\n    const mol = currentGroup.userData.molecule;\n    const mode = \"ballstick\";\n    const explodedMol = { name: mol.name, atoms: [] };\n    const meshes = currentGroup.userData.atomMeshes;\n    for (let i = 0; i < mol.atoms.length; i++) {\n      const a = mol.atoms[i];\n      const pos = meshes[i].position;\n      explodedMol.atoms.push({\n        element: a.element,\n        x: pos.x, y: pos.y, z: pos.z\n      });\n    }\n    explodedMol.bonds = mol.bonds; // reuse\n    scene.remove(currentGroup);\n    currentGroup = buildMoleculeGroup(explodedMol, mode);\n    scene.add(currentGroup);\n  }\n}\n\nfunction saveSnapshot() {\n  const link = document.createElement('a');\n  link.href = renderer.domElement.toDataURL('image/png');\n  link.download = 'molecule_snapshot.png';\n  link.click();\n}\n\nfunction loadCustomMolecule() {\n  const text = document.getElementById('customMol').value.trim();\n  if (!text) return;\n  try {\n    const mol = JSON.parse(text);\n    if (!mol.atoms || !Array.isArray(mol.atoms) || mol.atoms.length === 0) {\n      alert(\"Invalid custom molecule: 'atoms' array missing or empty.\");\n      return;\n    }\n    loadMoleculeData(mol);\n  } catch (e) {\n    alert(\"Failed to parse JSON: \" + e.message);\n  }\n}\n\n// =====================================================\n// Render loop\n// =====================================================\n\nfunction animate() {\n  requestAnimationFrame(animate);\n\n  if (explodeAnimating) {\n    let v = parseFloat(document.getElementById('explodeRange').value);\n    v += 0.01;\n    if (v > 1.5) v = 0;\n    document.getElementById('explodeRange').value = v.toFixed(2);\n    explodeFactor = v;\n    updateExplode();\n  }\n\n  controls.update();\n  renderer.render(scene, camera);\n}\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 42.435662031173706,
    "status": "success",
    "timestamp": "2025-11-19 22:10:18",
    "evaluation": {
      "test_name": "molecular_explorer",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "THREE.OrbitControls is not a constructor"
        ],
        "warnings": [
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/build/three.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "A parser-blocking, cross site (i.e. different eTLD+1) script, https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See https://www.chromestatus.com/feature/5718547946799104 for more details.",
          "Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation",
          "[.WebGL-0x104001cbd00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x104001cbd00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x104001cbd00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels",
          "[.WebGL-0x104001cbd00]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat)"
        ],
        "screenshot": "output/screenshots/molecular_explorer.png",
        "render_time_ms": 750.01,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 750.01ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "THREE.OrbitControls is not a constructor"
            ]
          },
          {
            "level": "warning",
            "message": "\u26a0\ufe0f  9 warning(s)"
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "1. The code does not fulfill the requirement of being a complete HTML file. It contains substantial unfinished sections, such as the incomplete `<select>` list and missing JavaScript implementation for Three.js to render molecules. 2. It lacks the Three.js import script tag, which is critical since Three.js needs to be loaded from CDN for 3D rendering. 3. It does not include logic for rendering ball-and-stick or space-filling modes, bond inference, atom coloring, section clipping, explode animation, or snapshot export \u2013 all key functionalities outlined in the request. 4. The HTML structure and initial CSS setup are adequate for the UI elements like molecule selection, but these elements are not integrated with any rendering or functionality logic.",
        "strengths": "The HTML/CSS structure for UI setup is clearly outlined, following a professional style with regards to layout and styling. The basic UI design gives a good starting point for integrating further functionality.",
        "weaknesses": "The JavaScript section is missing, notably the logic for rendering molecules with Three.js. Critical functionalities like rendering modes, animations, and data handling for sample molecules are absent. The file is incomplete concerning the described requirements: CDN link for Three.js, and logic to infer bonds, color atoms, and handle animations.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "space_shooter_prototype",
    "prompt": "Create a complete HTML file with Three.js that builds a simple on-rails space shooter with starfield background, enemy waves (instanced meshes), laser projectiles, hit effects (GPU particles), health/score UI, and post-processing bloom. Provide difficulty scaling and mobile touch controls. The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'space_shooter.html'.",
    "response": "```html\n<!-- Save this file as space_shooter.html and open in a modern browser -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>On-Rails Space Shooter - Three.js</title>\n  <style>\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      background: black;\n      font-family: system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif;\n      color: #fff;\n    }\n    #ui {\n      position: fixed;\n      top: 10px;\n      left: 10px;\n      z-index: 10;\n      font-size: 14px;\n      text-shadow: 0 0 4px #000;\n      user-select: none;\n      pointer-events: none;\n    }\n    #ui div {\n      margin-bottom: 4px;\n    }\n    #centerMessage {\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      font-size: 32px;\n      font-weight: bold;\n      color: #fff;\n      text-shadow: 0 0 8px #000;\n      z-index: 10;\n      user-select: none;\n      pointer-events: none;\n      text-align: center;\n    }\n    /* Simple touch controls overlay */\n    #touchControls {\n      position: fixed;\n      bottom: 10px;\n      left: 0;\n      right: 0;\n      height: 120px;\n      z-index: 9;\n      display: flex;\n      justify-content: space-between;\n      pointer-events: none;\n    }\n    .touchArea {\n      flex: 1;\n      pointer-events: auto;\n      touch-action: none;\n    }\n    .touchArea.left {\n      background: radial-gradient(circle at top left, rgba(255,255,255,0.1), transparent);\n    }\n    .touchArea.right {\n      background: radial-gradient(circle at top right, rgba(255,255,255,0.1), transparent);\n    }\n    .hint {\n      position: fixed;\n      bottom: 4px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 11px;\n      color: #aaa;\n      text-shadow: 0 0 4px #000;\n      pointer-events: none;\n    }\n  </style>\n</head>\n<body>\n<div id=\"ui\">\n  <div id=\"health\">Health: 100</div>\n  <div id=\"score\">Score: 0</div>\n  <div id=\"wave\">Wave: 1</div>\n</div>\n<div id=\"centerMessage\"></div>\n\n<div id=\"touchControls\">\n  <div class=\"touchArea left\" id=\"touchLeft\"></div>\n  <div class=\"touchArea right\" id=\"touchRight\"></div>\n</div>\n<div class=\"hint\">Desktop: Move with mouse / A-D, shoot with Space. Mobile: Drag left side to move, tap right side to shoot.</div>\n\n<!-- Three.js and examples from CDN -->\n<script type=\"module\">\n  import * as THREE from \"https://unpkg.com/three@0.160.0/build/three.module.js\";\n  import { OrbitControls } from \"https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js\";\n  import { EffectComposer } from \"https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js\";\n  import { RenderPass } from \"https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js\";\n  import { UnrealBloomPass } from \"https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js\";\n\n  // --------------------------------------------------\n  // Basic setup\n  // --------------------------------------------------\n  const renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  document.body.appendChild(renderer.domElement);\n\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x000010);\n\n  const camera = new THREE.PerspectiveCamera(\n    70,\n    window.innerWidth / window.innerHeight,\n    0.1,\n    2000\n  );\n  camera.position.set(0, 2, 12);\n\n  // Optional: keep for debugging (not used for control)\n  const controls = new OrbitControls(camera, renderer.domElement);\n  controls.enabled = false;\n\n  const clock = new THREE.Clock();\n\n  // --------------------------------------------------\n  // Lighting\n  // --------------------------------------------------\n  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\n  scene.add(ambientLight);\n\n  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);\n  dirLight.position.set(3, 5, 2);\n  scene.add(dirLight);\n\n  // --------------------------------------------------\n  // Post-processing (Bloom)\n  // --------------------------------------------------\n  const composer = new EffectComposer(renderer);\n  const renderPass = new RenderPass(scene, camera);\n  composer.addPass(renderPass);\n\n  const bloomPass = new UnrealBloomPass(\n    new THREE.Vector2(window.innerWidth, window.innerHeight),\n    1.2,  // strength\n    0.4,  // radius\n    0.85  // threshold\n  );\n  composer.addPass(bloomPass);\n\n  // --------------------------------------------------\n  // Player ship\n  // --------------------------------------------------\n  const playerGroup = new THREE.Group();\n  scene.add(playerGroup);\n\n  const shipGeo = new THREE.ConeGeometry(0.4, 1.2, 16);\n  const shipMat = new THREE.MeshStandardMaterial({\n    color: 0x00ffff,\n    emissive: 0x0080ff,\n    emissiveIntensity: 0.8,\n    metalness: 0.3,\n    roughness: 0.2\n  });\n  const shipMesh = new THREE.Mesh(shipGeo, shipMat);\n  shipMesh.rotation.x = Math.PI / 2;\n  playerGroup.add(shipMesh);\n\n  const thrusterGeo = new THREE.CylinderGeometry(0.1, 0.25, 0.4, 8);\n  const thrusterMat = new THREE.MeshStandardMaterial({\n    color: 0xffaa00,\n    emissive: 0xff6600,\n    emissiveIntensity: 1.5,\n    metalness: 0.2,\n    roughness: 0.5\n  });\n  const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);\n  thruster.position.set(0, -0.6, 0);\n  thruster.rotation.x = Math.PI / 2;\n  playerGroup.add(thruster);\n\n  playerGroup.position.set(0, 0, 0);\n\n  // Player stats\n  let playerHealth = 100;\n  let score = 0;\n  let wave = 1;\n  let isGameOver = false;\n\n  const healthEl = document.getElementById(\"health\");\n  const scoreEl = document.getElementById(\"score\");\n  const waveEl = document.getElementById(\"wave\");\n  const centerMessageEl = document.getElementById(\"centerMessage\");\n\n  function updateUI() {\n    healthEl.textContent = `Health: ${Math.max(0, Math.floor(playerHealth))}`;\n    scoreEl.textContent = `Score: ${score}`;\n    waveEl.textContent = `Wave: ${wave}`;\n  }\n  updateUI();\n\n  function showCenterMessage(msg, time = 2) {\n    centerMessageEl.textContent = msg;\n    centerMessageEl.style.opacity = \"1\";\n    if (time > 0) {\n      setTimeout(() => {\n        centerMessageEl.style.opacity = \"0\";\n      }, time * 1000);\n    }\n  }\n  showCenterMessage(\"On-Rails Space Shooter\");\n\n  // --------------------------------------------------\n  // Starfield background (instanced points)\n  // --------------------------------------------------\n  const starCount = 4000;\n  const starGeo = new THREE.BufferGeometry();\n  const starPositions = new Float32Array(starCount * 3);\n  for (let i = 0; i < starCount; i++) {\n    const i3 = i * 3;\n    starPositions[i3 + 0] = (Math.random() - 0.5) * 80;\n    starPositions[i3 + 1] = (Math.random() - 0.5) * 80;\n    starPositions[i3 + 2] = -Math.random() * 800;\n  }\n  starGeo.setAttribute(\n    \"position\",\n    new THREE.BufferAttribute(starPositions, 3)\n  );\n  const starMat = new THREE.PointsMaterial({\n    color: 0xffffff,\n    size: 0.15,\n    sizeAttenuation: true\n  });\n  const starField = new THREE.Points(starGeo, starMat);\n  scene.add(starField);\n\n  // --------------------------------------------------\n  // Enemies (Instanced Mesh)\n  // --------------------------------------------------\n  const ENEMY_POOL = 200;\n  const enemyGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7);\n  const enemyMat = new THREE.MeshStandardMaterial({\n    color: 0xff3366,\n    emissive: 0xff0033,\n    emissiveIntensity: 0.7,\n    metalness: 0.2,\n    roughness: 0.5\n  });\n\n  const enemyMesh = new THREE.InstancedMesh(enemyGeo, enemyMat, ENEMY_POOL);\n  enemyMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n  scene.add(enemyMesh);\n\n  const enemyData = [];\n  for (let i = 0; i < ENEMY_POOL; i++) {\n    enemyData.push({\n      alive: false,\n      position: new THREE.Vector3(),\n      velocityZ: -10,\n      hp: 1,\n      waveTag: 0\n    });\n    enemyMesh.setMatrixAt(i, new THREE.Matrix4()); // identity\n  }\n  enemyMesh.instanceMatrix.needsUpdate = true;\n\n  let currentEnemiesAlive = 0;\n  let lastWaveTime = 0;\n\n  function spawnEnemyWave(waveNumber) {\n    const numEnemies = Math.min(\n      ENEMY_POOL - currentEnemiesAlive,\n      5 + waveNumber * 2\n    );\n    if (numEnemies <= 0) return;\n\n    const zStart = -80 - waveNumber * 20;\n    const spreadX = 5 + waveNumber * 0.8;\n    const spreadY = 3 + waveNumber * 0.5;\n\n    let spawned = 0;\n    for (let i = 0; i < ENEMY_POOL && spawned < numEnemies; i++) {\n      const e = enemyData[i];\n      if (e.alive) continue;\n\n      e.alive = true;\n      currentEnemiesAlive++;\n      e.waveTag = waveNumber;\n      e.hp = 1 + Math.floor(waveNumber * 0.15);\n\n      const row = Math.floor(spawned / 6);\n      const col = spawned % 6;\n      const x = ((col / 5) - 0.5) * spreadX * 2;\n      const y = ((row / 4) - 0.5) * spreadY * 2;\n      const jitterX = (Math.random() - 0.5) * 1.2;\n      const jitterY = (Math.random() - 0.5) * 1.2;\n\n      e.position.set(x + jitterX, y + jitterY, zStart - row * 8);\n      e.velocityZ = 8 + waveNumber * 0.7; // forward speed toward player\n\n      const mat = new THREE.Matrix4();\n      mat.compose(\n        e.position,\n        new THREE.Quaternion().setFromEuler(\n          new THREE.Euler(\n            (Math.random() - 0.5) * 0.4,\n            (Math.random() - 0.5) * 0.4,\n            (Math.random() - 0.5) * 0.4\n          )\n        ),\n        new THREE.Vector3(1, 1, 1)\n      );\n      enemyMesh.setMatrixAt(i, mat);\n\n      spawned++;\n    }\n    enemyMesh.instanceMatrix.needsUpdate = true;\n  }\n\n  // --------------------------------------------------\n  // Lasers (simple pool of meshes)\n  // --------------------------------------------------\n  const LASER_POOL = 80;\n  const laserGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.6, 4);\n  const laserMat = new THREE.MeshBasicMaterial({\n    color: 0x00ffcc\n  });\n\n  const laserMeshes = [];\n  const laserData = [];\n  const laserGroup = new THREE.Group();\n  scene.add(laserGroup);\n\n  for (let i = 0; i < LASER_POOL; i++) {\n    const m = new THREE.Mesh(laserGeo, laserMat);\n    m.rotation.x = Math.PI / 2;\n    m.visible = false;\n    laserGroup.add(m);\n    laserMeshes.push(m);\n    laserData.push({\n      alive: false,\n      velocity: new THREE.Vector3(0, 0, -80)\n    });\n  }\n\n  let lastShotTime = 0;\n  const FIRE_INTERVAL = 0.16;\n\n  function shootLaser() {\n    const now = clock.getElapsedTime();\n    if (now - lastShotTime < FIRE_INTERVAL || isGameOver) return;\n    lastShotTime = now;\n\n    for (let i = 0; i < LASER_POOL; i++) {\n      const d = laserData[i];\n      const m = laserMeshes[i];\n      if (!d.alive) {\n        d.alive = true;\n        m.visible = true;\n        m.position.copy(playerGroup.position);\n        m.position.z -= 1.0;\n        break;\n      }\n    }\n  }\n\n  // --------------------------------------------------\n  // GPU-ish particles (simple Points + per-particle life)\n  // --------------------------------------------------\n  const MAX_PARTICLES = 500;\n  const particlePositions = new Float32Array(MAX_PARTICLES * 3);\n  const particleLife = new Float32Array(MAX_PARTICLES);\n  const particleStartLife = new Float32Array(MAX_PARTICLES);\n  const particleVelocity = new Float32Array(MAX_PARTICLES * 3);\n\n  const particleGeo = new THREE.BufferGeometry();\n  particleGeo.setAttribute(\n    \"position\",\n    new THREE.BufferAttribute(particlePositions, 3)\n  );\n\n  const particleMat = new THREE.PointsMaterial({\n    color: 0xffee55,\n    size: 0.25,\n    transparent: true,\n    opacity: 1.0,\n    depthWrite: false,\n    blending: THREE.AdditiveBlending\n  });\n\n  const particles = new THREE.Points(particleGeo, particleMat);\n  scene.add(particles);\n\n  function spawnExplosion(pos, count = 30) {\n    for (let i = 0; i < MAX_PARTICLES && count > 0; i++) {\n      if (particleLife[i] <= 0) {\n        const i3 = i * 3;\n        particlePositions[i3 + 0] = pos.x;\n        particlePositions[i3 + 1] = pos.y;\n        particlePositions[i3 + 2] = pos.z;\n\n        const dir = new THREE.Vector3(\n          (Math.random() - 0.5) * 2,\n          (Math.random() - 0.5) * 2,\n          (Math.random() - 0.5) * 2\n        ).normalize().multiplyScalar(10 + Math.random() * 10);\n\n        particleVelocity[i3 + 0] = dir.x;\n        particleVelocity[i3 + 1] = dir.y;\n        particleVelocity[i3 + 2] = dir.z;\n\n        const life = 0.6 + Math.random() * 0.4;\n        particleLife[i] = life;\n        particleStartLife[i] = life;\n\n        count--;\n      }\n    }\n    particleGeo.attributes.position.needsUpdate = true;\n  }\n\n  // --------------------------------------------------\n  // Input handling (mouse/keyboard/touch)\n  // --------------------------------------------------\n  let moveInput = 0; // -1 to 1\n  let targetX = 0;\n\n  // Keyboard\n  const keys = {};\n  window.addEventListener(\"keydown\", (e) => {\n    keys[e.code] = true;\n    if (e.code === \"Space\") shootLaser();\n  });\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.code] = false;\n  });\n\n  // Mouse move \u2013 control X position\n  window.addEventListener(\"mousemove\", (e) => {\n    const ndcX = (e.clientX / window.innerWidth) * 2 - 1;\n    targetX = ndcX * 5;\n  });\n\n  // Mouse click to fire\n  window.addEventListener(\"mousedown\", (e) => {\n    if (e.button === 0) shootLaser();\n  });\n\n  // Touch controls: left side drag -> move, right side tap/hold -> fire\n  const leftArea = document.getElementById(\"touchLeft\");\n  const rightArea = document.getElementById(\"touchRight\");\n\n  let touchActiveLeft = false;\n  let touchStartX = 0;\n  let playerStartX = 0;\n\n  function onTouchStartLeft(e) {\n    e.preventDefault();\n    touchActiveLeft = true;\n    const t = e.changedTouches[0];\n    touchStartX = t.clientX;\n    playerStartX = playerGroup.position.x;\n  }\n  function onTouchMoveLeft(e) {\n    if (!touchActiveLeft) return;\n    e.preventDefault();\n    const t = e.changedTouches[0];\n    const dx = t.clientX - touchStartX;\n    const range = 6; // max horizontal move\n    targetX = THREE.MathUtils.clamp(\n      playerStartX + (dx / window.innerWidth) * range * 2,\n      -range,\n      range\n    );\n  }\n  function onTouchEndLeft(e) {\n    e.preventDefault();\n    touchActiveLeft = false;\n  }\n\n  leftArea.addEventListener(\"touchstart\", onTouchStartLeft, { passive: false });\n  leftArea.addEventListener(\"touchmove\", onTouchMoveLeft, { passive: false });\n  leftArea.addEventListener(\"touchend\", onTouchEndLeft, { passive: false });\n  leftArea.addEventListener(\"touchcancel\", onTouchEndLeft, { passive: false });\n\n  // Right side: tap to shoot, hold for auto-fire\n  let fireIntervalId = null;\n  function startAutoFire() {\n    if (fireIntervalId) return;\n    shootLaser();\n    fireIntervalId = setInterval(shootLaser, 200);\n  }\n  function stopAutoFire() {\n    if (!fireIntervalId) return;\n    clearInterval(fireIntervalId);\n    fireIntervalId = null;\n  }\n\n  rightArea.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    startAutoFire();\n  }, { passive: false });\n  rightArea.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    stopAutoFire();\n  }, { passive: false });\n  rightArea.addEventListener(\"touchcancel\", (e) => {\n    e.preventDefault();\n    stopAutoFire();\n  }, { passive: false });\n\n  // --------------------------------------------------\n  // Difficulty and game over\n  // --------------------------------------------------\n  function damagePlayer(amount) {\n    playerHealth -= amount;\n    if (playerHealth <= 0 && !isGameOver) {\n      playerHealth = 0;\n      isGameOver = true;\n      showCenterMessage(\"Game Over\\nTap or Press R to Restart\", 0);\n    }\n    updateUI();\n  }\n\n  function restartGame() {\n    isGameOver = false;\n    playerHealth = 100;\n    score = 0;\n    wave = 1;\n    lastWaveTime = 0;\n    currentEnemiesAlive = 0;\n    playerGroup.position.set(0, 0, 0);\n    targetX = 0;\n\n    // clear enemies\n    for (let i = 0; i < ENEMY_POOL; i++) {\n      enemyData[i].alive = false;\n      const mat = new THREE.Matrix4();\n      enemyMesh.setMatrixAt(i, mat);\n    }\n    enemyMesh.instanceMatrix.needsUpdate = true;\n\n    // clear lasers\n    for (let i = 0; i < LASER_POOL; i++) {\n      laserData[i].alive = false;\n      laserMeshes[i].visible = false;\n    }\n\n    // clear particles\n    for (let i = 0; i < MAX_PARTICLES; i++) {\n      particleLife[i] = 0;\n    }\n    particleGeo.attributes.position.needsUpdate = true;\n\n    updateUI();\n    showCenterMessage(\"On-Rails Space Shooter\");\n  }\n\n  window.addEventListener(\"keydown\", (e) => {\n    if (e.code === \"KeyR\") {\n      restartGame();\n    }\n  });\n  window.addEventListener(\"mousedown\", () => {\n    if (isGameOver) restartGame();\n  });\n  window.addEventListener(\"touchstart\", () => {\n    if (isGameOver) restartGame();\n  }, { passive: true });\n\n  // --------------------------------------------------\n  // Main animation loop\n  // --------------------------------------------------\n  function animate() {\n    requestAnimationFrame(animate);\n    const dt = clock.getDelta();\n    const t = clock.getElapsedTime();\n\n    // Keyboard-based movement\n    let moveDir = 0;\n    if (keys[\"KeyA\"] || keys[\"ArrowLeft\"]) moveDir -= 1;\n    if (keys[\"KeyD\"] || keys[\"ArrowRight\"]) moveDir += 1;\n    if (moveDir !== 0) {\n      targetX += moveDir * 12 * dt;\n      targetX = THREE.MathUtils.clamp(targetX, -8, 8);\n    }\n\n    // Smoothly move player towards targetX (on-rails)\n    playerGroup.position.x += (targetX - playerGroup.position.x) * 6 * dt;\n    playerGroup.position.y = Math.sin(t * 0.7) * 0.3; // subtle bobbing\n    playerGroup.position.z = 0;\n\n    shipMesh.rotation.z = THREE.MathUtils.lerp(\n      shipMesh.rotation.z,\n      -playerGroup.position.x * 0.06,\n      10 * dt\n    );\n\n    // Thruster flicker\n    thruster.scale.y = 0.8 + Math.sin(t * 50) * 0.2;\n\n    // Starfield scroll\n    const starPosAttr = starGeo.attributes.position;\n    for (let i = 0; i < starCount; i++) {\n      const i3 = i * 3;\n      starPosAttr.array[i3 + 2] += 40 * dt;\n      if (starPosAttr.array[i3 + 2] > 10) {\n        starPosAttr.array[i3 + 0] = (Math.random() - 0.5) * 80;\n        starPosAttr.array[i3 + 1] = (Math.random() - 0.5) * 80;\n        starPosAttr.array[i3 + 2] = -800;\n      }\n    }\n    starPosAttr.needsUpdate = true;\n\n    // Update lasers\n    for (let i = 0; i < LASER_POOL; i++) {\n      const d = laserData[i];\n      const m = laserMeshes[i];\n      if (!d.alive) continue;\n      m.position.addScaledVector(d.velocity, dt);\n      if (m.position.z < -250) {\n        d.alive = false;\n        m.visible = false;\n      }\n    }\n\n    // Update enemies and collisions\n    const tempMat = new THREE.Matrix4();\n    const tempQuat = new THREE.Quaternion();\n    const tempScale = new THREE.Vector3(1, 1, 1);\n\n    for (let i = 0; i < ENEMY_POOL; i++) {\n      const e = enemyData[i];\n      if (!e.alive) continue;\n\n      // Move toward player\n      e.position.z += e.velocityZ * dt;\n\n      // Slight wave motion\n      e.position.x += Math.sin(t * 2 + i) * 0.01 * (1 + wave * 0.2);\n\n      // Rotation wiggle\n      const rot = new THREE.Euler(\n        0,\n        t * 1.2 + i * 0.1,\n        Math.sin(t * 2 + i) * 0.3\n      );\n      tempQuat.setFromEuler(rot);\n      tempMat.compose(e.position, tempQuat, tempScale);\n      enemyMesh.setMatrixAt(i, tempMat);\n\n      // If it passes the player, damage player and despawn\n      if (e.position.z > 6) {\n        e.alive = false;\n        currentEnemiesAlive--;\n        damagePlayer(5 + wave);\n      }\n    }\n    enemyMesh.instanceMatrix.needsUpdate = true;\n\n    // Laser-enemy collision (simple distance check)\n    for (let ei = 0; ei < ENEMY_POOL; ei++) {\n      const e = enemyData[ei];\n      if (!e.alive) continue;\n\n      for (let li = 0; li < LASER_POOL; li++) {\n        const ld = laserData[li];\n        const lm = laserMeshes[li];\n        if (!ld.alive) continue;\n\n        const dx = lm.position.x - e.position.x;\n        const dy = lm.position.y - e.position.y;\n        const dz = lm.position.z - e.position.z;\n        const distSq = dx * dx + dy * dy + dz * dz;\n        if (distSq < 1.0) {\n          // Hit\n          ld.alive = false;\n          lm.visible = false;\n\n          e.hp -= 1;\n          spawnExplosion(lm.position, 20);\n          if (e.hp <= 0) {\n            e.alive = false;\n            currentEnemiesAlive--;\n            score += 10 + wave;\n            updateUI();\n          }\n        }\n      }\n    }\n\n    // Player-enemy collision (if any gets too close)\n    for (let i = 0; i < ENEMY_POOL; i++) {\n      const e = enemyData[i];\n      if (!e.alive) continue;\n      const dx = playerGroup.position.x - e.position.x;\n      const dy = playerGroup.position.y - e.position.y;\n      const dz = playerGroup.position.z - e.position.z;\n      const d2 = dx * dx + dy * dy + dz * dz;\n      if (d2 < 1.5) {\n        // Collision\n        spawnExplosion(e.position, 40);\n        e.alive = false;\n        currentEnemiesAlive--;\n        damagePlayer(20 + wave * 2);\n      }\n    }\n\n    // Update particle system\n    for (let i = 0; i < MAX_PARTICLES; i++) {\n      if (particleLife[i] > 0) {\n        const life = particleLife[i] - dt;\n        const norm = life / (particleStartLife[i] || 1);\n        particleLife[i] = life;\n        const i3 = i * 3;\n        particlePositions[i3 + 0] += particleVelocity[i3 + 0] * dt;\n        particlePositions[i3 + 1] += particleVelocity[i3 + 1] * dt;\n        particlePositions[i3 + 2] += particleVelocity[i3 + 2] * dt;\n\n        if (life <= 0) {\n          // hide\n          particlePositions[i3 + 0] = 9999;\n          particlePositions[i3 + 1] = 9999;\n          particlePositions[i3 + 2] = 9999;\n        }\n      }\n    }\n    particleGeo.attributes.position.needsUpdate = true;\n\n    // Simple difficulty scaling & wave spawning\n    const waveInterval = Math.max(3, 10 - wave * 0.4);\n    if (!isGameOver) {\n      if (currentEnemiesAlive === 0 && t - lastWaveTime > waveInterval) {\n        spawnEnemyWave(wave);\n        lastWaveTime = t;\n        wave++;\n        updateUI();\n      }\n    }\n\n    // Minor camera follow of player\n    camera.position.x += (playerGroup.position.x * 0.3 - camera.position.x) * 2 * dt;\n    camera.lookAt(new THREE.Vector3(0, 0, -40));\n\n    composer.render();\n  }\n\n  animate();\n\n  // --------------------------------------------------\n  // Resize handling\n  // --------------------------------------------------\n  window.addEventListener(\"resize\", () => {\n    const w = window.innerWidth;\n    const h = window.innerHeight;\n    camera.aspect = w / h;\n    camera.updateProjectionMatrix();\n    renderer.setSize(w, h);\n    composer.setSize(w, h);\n  });\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 37.85313701629639,
    "status": "success",
    "timestamp": "2025-11-19 22:11:10",
    "evaluation": {
      "test_name": "space_shooter_prototype",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
        ],
        "warnings": [],
        "screenshot": "output/screenshots/space_shooter_prototype.png",
        "render_time_ms": 737.43,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 737.43ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
            ]
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "The provided code does not fulfill the main requirements of the original request. Although it sets up the basic HTML structure and some UI elements, it does not include core functionality like the instantiation of the Three.js scene, camera setup, enemy waves, laser projectiles, GPU particles for hit effects, or post-processing bloom. Also, some HTML tags appear to be cut-off or incomplete indicating the code is unfinished. The use of modern JavaScript standards isn't demonstrated as the actual JavaScript code is missing.",
        "strengths": "Includes basic HTML structure and styling with a responsive UI. CSS setup is clean and focuses on a mobile-friendly interface.",
        "weaknesses": "Missing substantial JavaScript functionality like scene setup, rendering loop, enemy management, and interactions as requested. Code is incomplete and does not showcase any Three.js usage.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  },
  {
    "test_name": "architectural_walkthrough",
    "prompt": "Create a complete HTML file with Three.js that creates an interactive walkthrough for a procedurally generated house with first-person controls with collision detection, baked/IBL lighting, light probes, room-based culling, interactive hotspots that toggle materials/furniture, and a minimap. Include multiple rooms and furniture. The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'architectural_walkthrough.html'.",
    "response": "```html\n<!-- Save this file as: architectural_walkthrough.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Procedural House Walkthrough - Three.js</title>\n    <style>\n        html, body {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            height: 100%;\n            background: #000;\n            font-family: Arial, sans-serif;\n            color: #fff;\n        }\n        #info {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            padding: 8px 12px;\n            background: rgba(0,0,0,0.5);\n            font-size: 12px;\n            max-width: 340px;\n            z-index: 10;\n        }\n        #info b {\n            color: #ffd27f;\n        }\n        #crosshair {\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            width: 12px;\n            height: 12px;\n            margin-left: -6px;\n            margin-top: -6px;\n            border-radius: 50%;\n            border: 2px solid rgba(255,255,255,0.8);\n            box-sizing: border-box;\n            pointer-events: none;\n            z-index: 5;\n        }\n        #minimap {\n            position: absolute;\n            right: 10px;\n            bottom: 10px;\n            width: 220px;\n            height: 220px;\n            border: 2px solid rgba(255,255,255,0.7);\n            background: rgba(0,0,0,0.7);\n            z-index: 5;\n        }\n        #minimap canvas {\n            width: 100%;\n            height: 100%;\n            display: block;\n        }\n        #lockOverlay {\n            position: absolute;\n            inset: 0;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            background: radial-gradient(circle at center, rgba(255,255,255,0.1), rgba(0,0,0,0.9));\n            color: #fff;\n            cursor: pointer;\n            z-index: 20;\n        }\n        #lockOverlay.hidden {\n            display: none;\n        }\n        #lockOverlay button {\n            padding: 10px 20px;\n            font-size: 14px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<div id=\"info\">\n    <b>Procedural House Walkthrough</b><br>\n    Click the screen to capture the mouse.<br>\n    <b>Move:</b> W/A/S/D &nbsp; <b>Look:</b> Mouse &nbsp; <b>Height:</b> Space / Shift<br>\n    <b>Interact:</b> E (while looking at hotspot)<br>\n    Hotspots toggle furniture and materials (sofa, table, bed, wall colors).<br>\n    Minimap shows top view and player position.<br>\n</div>\n<div id=\"crosshair\"></div>\n<div id=\"minimap\"></div>\n<div id=\"lockOverlay\">\n    <div>\n        <h2>Click to Start Walkthrough</h2>\n        <p>Use mouse to look around and WASD to move.</p>\n        <button>Enter</button>\n    </div>\n</div>\n\n<script type=\"module\">\n    import * as THREE from 'https://unpkg.com/three@0.163.0/build/three.module.js';\n    import { PointerLockControls } from 'https://unpkg.com/three@0.163.0/examples/jsm/controls/PointerLockControls.js';\n    import { OrbitControls } from 'https://unpkg.com/three@0.163.0/examples/jsm/controls/OrbitControls.js';\n    import { LightProbeGenerator } from 'https://unpkg.com/three@0.163.0/examples/jsm/lights/LightProbeGenerator.js';\n\n    let renderer, scene, camera, controls;\n    let minimapCamera, minimapRenderer, minimapContainer;\n    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;\n    let moveUp = false, moveDown = false;\n    let prevTime = performance.now();\n    const velocity = new THREE.Vector3();\n    const direction = new THREE.Vector3();\n    const objects = [];       // collision objects\n    const rooms = [];         // for room-based culling\n    const hotspots = [];      // interactive hotspots\n    const playerRadius = 0.4; // collision radius\n    const playerHeight = 1.7;\n    let houseGroup;\n    let envTexture;\n    let lightProbe;\n    const tmpBox = new THREE.Box3();\n    const playerPosition = new THREE.Vector3();\n    const raycaster = new THREE.Raycaster();\n    const hotMaterialOn = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n    const hotMaterialOff = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n\n    init();\n    animate();\n\n    function init() {\n        const w = window.innerWidth;\n        const h = window.innerHeight;\n\n        renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(w, h);\n        renderer.shadowMap.enabled = true;\n        renderer.outputEncoding = THREE.sRGBEncoding;\n        document.body.appendChild(renderer.domElement);\n\n        scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x101018);\n\n        camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 100);\n        camera.position.set(0, playerHeight, 8);\n\n        controls = new PointerLockControls(camera, document.body);\n\n        const overlay = document.getElementById('lockOverlay');\n        overlay.addEventListener('click', () => controls.lock());\n        overlay.querySelector('button').addEventListener('click', () => controls.lock());\n        controls.addEventListener('lock', () => overlay.classList.add('hidden'));\n        controls.addEventListener('unlock', () => overlay.classList.remove('hidden'));\n\n        // Key controls\n        const onKeyDown = function (event) {\n            switch (event.code) {\n                case 'ArrowUp':\n                case 'KeyW':\n                    moveForward = true;\n                    break;\n                case 'ArrowLeft':\n                case 'KeyA':\n                    moveLeft = true;\n                    break;\n                case 'ArrowDown':\n                case 'KeyS':\n                    moveBackward = true;\n                    break;\n                case 'ArrowRight':\n                case 'KeyD':\n                    moveRight = true;\n                    break;\n                case 'Space':\n                    moveUp = true;\n                    break;\n                case 'ShiftLeft':\n                case 'ShiftRight':\n                    moveDown = true;\n                    break;\n            }\n        };\n        const onKeyUp = function (event) {\n            switch (event.code) {\n                case 'ArrowUp':\n                case 'KeyW':\n                    moveForward = false;\n                    break;\n                case 'ArrowLeft':\n                case 'KeyA':\n                    moveLeft = false;\n                    break;\n                case 'ArrowDown':\n                case 'KeyS':\n                    moveBackward = false;\n                    break;\n                case 'ArrowRight':\n                case 'KeyD':\n                    moveRight = false;\n                    break;\n                case 'Space':\n                    moveUp = false;\n                    break;\n                case 'ShiftLeft':\n                case 'ShiftRight':\n                    moveDown = false;\n                    break;\n                case 'KeyE':\n                    triggerHotspot();\n                    break;\n            }\n        };\n        document.addEventListener('keydown', onKeyDown);\n        document.addEventListener('keyup', onKeyUp);\n\n        // \"Baked\" / IBL lighting via procedural environment map\n        const pmrem = new THREE.PMREMGenerator(renderer);\n        pmrem.compileEquirectangularShader();\n\n        const envScene = new THREE.Scene();\n        const envCamera = new THREE.PerspectiveCamera(90, 1, 0.1, 10);\n        envCamera.position.set(0,0,0.01);\n        const grad = new THREE.Mesh(\n            new THREE.SphereGeometry(5, 32, 32),\n            new THREE.ShaderMaterial({\n                side: THREE.BackSide,\n                uniforms: {\n                    topColor: { value: new THREE.Color(0x8899ff) },\n                    bottomColor: { value: new THREE.Color(0x202025) }\n                },\n                vertexShader: `\n                    varying vec3 vWorldPosition;\n                    void main() {\n                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n                        vWorldPosition = worldPosition.xyz;\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                    }\n                `,\n                fragmentShader: `\n                    varying vec3 vWorldPosition;\n                    uniform vec3 topColor;\n                    uniform vec3 bottomColor;\n                    void main() {\n                        float h = normalize(vWorldPosition).y * 0.5 + 0.5;\n                        gl_FragColor = vec4(mix(bottomColor, topColor, h), 1.0);\n                    }\n                `\n            })\n        );\n        envScene.add(grad);\n        const envRT = pmrem.fromScene(envScene, 0.1);\n        envTexture = envRT.texture;\n        scene.environment = envTexture;\n\n        // LightProbe from env\n        lightProbe = LightProbeGenerator.fromCubeTexture(envTexture);\n        scene.add(lightProbe);\n\n        // Additional lights (to simulate baked indoor lighting)\n        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);\n        hemi.position.set(0, 20, 0);\n        scene.add(hemi);\n\n        const mainSpot = new THREE.SpotLight(0xfff0e0, 1.2, 40, Math.PI / 4, 0.3, 1);\n        mainSpot.position.set(0, 8, 0);\n        mainSpot.castShadow = true;\n        mainSpot.shadow.mapSize.set(1024, 1024);\n        scene.add(mainSpot);\n\n        // Floor plane for entire house\n        const floorMat = new THREE.MeshStandardMaterial({\n            color: 0x888888,\n            roughness: 0.7,\n            metalness: 0.05\n        });\n        const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), floorMat);\n        floor.rotation.x = -Math.PI / 2;\n        floor.receiveShadow = true;\n        scene.add(floor);\n\n        // Procedurally generate house\n        houseGroup = new THREE.Group();\n        scene.add(houseGroup);\n        generateHouse();\n\n        // Minimap\n        minimapContainer = document.getElementById('minimap');\n        minimapRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n        minimapRenderer.setSize(minimapContainer.clientWidth, minimapContainer.clientHeight);\n        minimapContainer.appendChild(minimapRenderer.domElement);\n\n        minimapCamera = new THREE.OrthographicCamera(-20, 20, 20, -20, 0.1, 100);\n        minimapCamera.position.set(0, 30, 0);\n        minimapCamera.up.set(0, 0, -1);\n        minimapCamera.lookAt(0, 0, 0);\n\n        window.addEventListener('resize', onWindowResize);\n    }\n\n    // Procedural house: 3 main rooms (living, kitchen, bedroom) + hallway\n    function generateHouse() {\n        const wallHeight = 3;\n        const wallThickness = 0.2;\n\n        // Layout definition\n        const roomsDef = [\n            { name: 'Living',  x: -4, z:  0, w: 8, d: 6, color: 0xf5f5f5 },\n            { name: 'Kitchen', x:  6, z:  0, w: 6, d: 6, color: 0xf0f4ff },\n            { name: 'Bedroom', x: -4, z: -8, w: 8, d: 6, color: 0xfff5f0 },\n            { name: 'Hall',    x:  1, z: -4, w: 5, d: 4, color: 0xf8f8f8 }\n        ];\n\n        const wallMat = new THREE.MeshStandardMaterial({\n            color: 0xffffff,\n            roughness: 0.6,\n            metalness: 0.0\n        });\n\n        const doorHeight = 2.2;\n        const doorWidth = 1.0;\n\n        roomsDef.forEach((r) => {\n            const roomGroup = new THREE.Group();\n            roomGroup.userData.name = r.name;\n            houseGroup.add(roomGroup);\n\n            const floorMat = new THREE.MeshStandardMaterial({\n                color: r.color,\n                roughness: 0.8,\n                metalness: 0.0\n            });\n            const floor = new THREE.Mesh(new THREE.PlaneGeometry(r.w, r.d), floorMat);\n            floor.rotation.x = -Math.PI / 2;\n            floor.position.set(r.x, 0.01, r.z);\n            floor.receiveShadow = true;\n            roomGroup.add(floor);\n\n            const ceilMat = new THREE.MeshStandardMaterial({\n                color: 0xffffff,\n                roughness: 0.9,\n                metalness: 0.0\n            });\n            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(r.w, r.d), ceilMat);\n            ceil.rotation.x = Math.PI / 2;\n            ceil.position.set(r.x, wallHeight, r.z);\n            ceil.receiveShadow = false;\n            roomGroup.add(ceil);\n\n            // Walls with simple rectangular cut for doorways, chosen per room to connect spaces\n            const halfW = r.w / 2;\n            const halfD = r.d / 2;\n\n            // Helper to add wall segments\n            function addWall(x1, z1, x2, z2, hasDoor = false, doorDir = 'center') {\n                const length = Math.hypot(x2 - x1, z2 - z1);\n                const wallGeom = new THREE.BoxGeometry(length, wallHeight, wallThickness);\n                const wall = new THREE.Mesh(wallGeom, wallMat.clone());\n                wall.castShadow = true;\n                wall.receiveShadow = true;\n\n                const midX = (x1 + x2) / 2;\n                const midZ = (z1 + z2) / 2;\n                wall.position.set(midX, wallHeight / 2, midZ);\n                const angle = Math.atan2(z2 - z1, x2 - x1);\n                wall.rotation.y = -angle;\n\n                roomGroup.add(wall);\n                objects.push(wall);\n\n                if (hasDoor) {\n                    // Simulate door opening by hiding central portion using a clipping box (approx: scale)\n                    const cutSize = doorWidth / length;\n                    if (doorDir === 'center') {\n                        wall.geometry = new THREE.BoxGeometry(length, wallHeight, wallThickness);\n                        // Create invisible collision boxes for side segments\n                        const sideLen = (length - doorWidth) / 2;\n                        const left = new THREE.Mesh(\n                            new THREE.BoxGeometry(sideLen, wallHeight, wallThickness),\n                            wall.material\n                        );\n                        const right = new THREE.Mesh(\n                            new THREE.BoxGeometry(sideLen, wallHeight, wallThickness),\n                            wall.material\n                        );\n                        left.position.set(\n                            midX + Math.cos(-angle) * (- (doorWidth / 2 - sideLen / 2)),\n                            wallHeight / 2,\n                            midZ + Math.sin(-angle) * (- (doorWidth / 2 - sideLen / 2))\n                        );\n                        right.position.set(\n                            midX + Math.cos(-angle) * ((doorWidth / 2 - sideLen / 2)),\n                            wallHeight / 2,\n                            midZ + Math.sin(-angle) * ((doorWidth / 2 - sideLen / 2))\n                        );\n                        left.rotation.y = -angle;\n                        right.rotation.y = -angle;\n                        roomGroup.add(left);\n                        roomGroup.add(right);\n                        objects.push(left, right);\n                        wall.visible = false; // keep only side blocks\n                    }\n                }\n            }\n\n            const x = r.x, z = r.z;\n            const xL = x - halfW, xR = x + halfW;\n            const zF = z + halfD, zB = z - halfD;\n\n            // Four walls. Put doors according to room type\n            const isLiving = r.name === 'Living';\n            const isKitchen = r.name === 'Kitchen';\n            const isBedroom = r.name === 'Bedroom';\n            const isHall = r.name === 'Hall';\n\n            // Front wall (towards +z)\n            let frontDoor = false;\n            if (isLiving) frontDoor = true;           // entrance to outside\n            if (isHall) frontDoor = true;             // connects to living\n            addWall(xL, zF, xR, zF, frontDoor, 'center');\n\n            // Back wall (towards -z)\n            let backDoor = false;\n            if (isHall) backDoor = true;              // connects to bedroom\n            if (isKitchen) backDoor = true;           // opens to rear ward / outside\n            addWall(xR, zB, xL, zB, backDoor, 'center');\n\n            // Left wall (-x)\n            let leftDoor = false;\n            if (isKitchen) leftDoor = true;           // connect kitchen to hall\n            addWall(xL, zB, xL, zF, leftDoor, 'center');\n\n            // Right wall (+x)\n            let rightDoor = false;\n            if (isLiving) rightDoor = true;           // connect living to hall\n            addWall(xR, zF, xR, zB, rightDoor, 'center');\n\n            // For room-based culling: bounding box\n            const rBox = new THREE.Box3().setFromCenterAndSize(\n                new THREE.Vector3(r.x, wallHeight / 2, r.z),\n                new THREE.Vector3(r.w, wallHeight, r.d)\n            );\n            rooms.push({ name: r.name, group: roomGroup, bounds: rBox });\n\n            // Add furniture / hotspots depending on room\n            if (isLiving) createLivingRoom(roomGroup, r);\n            if (isKitchen) createKitchen(roomGroup, r);\n            if (isBedroom) createBedroom(roomGroup, r);\n        });\n    }\n\n    function createHotspot(position, label, toggleFn) {\n        const geo = new THREE.SphereGeometry(0.15, 16, 16);\n        const mesh = new THREE.Mesh(geo, hotMaterialOn.clone());\n        mesh.position.copy(position);\n        mesh.userData.isHotspot = true;\n        mesh.userData.label = label;\n        mesh.userData.toggleFn = toggleFn;\n        mesh.renderOrder = 2;\n        hotspots.push(mesh);\n        scene.add(mesh);\n    }\n\n    function createLivingRoom(group, r) {\n        // Sofa (toggle on/off)\n        const sofaMat1 = new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.7 });\n        const sofaMat2 = new THREE.MeshStandardMaterial({ color: 0x884444, roughness: 0.6 });\n\n        const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.4, 0.8), sofaMat1);\n        sofaBase.position.set(r.x - r.w/4, 0.2, r.z);\n        sofaBase.castShadow = true;\n        sofaBase.receiveShadow = true;\n\n        const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 0.2), sofaMat1);\n        sofaBack.position.set(r.x - r.w/4, 0.75, r.z - 0.3);\n        sofaBack.castShadow = true;\n\n        const sofaGroup = new THREE.Group();\n        sofaGroup.add(sofaBase);\n        sofaGroup.add(sofaBack);\n        sofaGroup.userData.altMaterials = [sofaMat1, sofaMat2];\n        sofaGroup.userData.stateIndex = 0;\n        group.add(sofaGroup);\n\n        objects.push(sofaGroup);\n\n        // Coffee table (toggle visible)\n        const tableMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.2, roughness: 0.4 });\n        const tableTop = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.6), tableMat);\n        tableTop.castShadow = true;\n        tableTop.position.set(r.x, 0.45, r.z);\n\n        const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);\n        const legs = new THREE.Group();\n        const offsets = [\n            [0.5, 0.25],\n            [-0.5, 0.25],\n            [0.5, -0.25],\n            [-0.5, -0.25]\n        ];\n        offsets.forEach(o => {\n            const leg = new THREE.Mesh(legGeo, tableMat);\n            leg.position.set(tableTop.position.x + o[0], 0.2, tableTop.position.z + o[1]);\n            leg.castShadow = true;\n            legs.add(leg);\n        });\n\n        const tableGroup = new THREE.Group();\n        tableGroup.add(tableTop);\n        tableGroup.add(legs);\n        group.add(tableGroup);\n        objects.push(tableGroup);\n\n        // Hotspot to toggle sofa material\n        createHotspot(\n            new THREE.Vector3(sofaBase.position.x, 1.1, sofaBase.position.z),\n            'Sofa Material',\n            () => {\n                const idx = (sofaGroup.userData.stateIndex + 1) % sofaGroup.userData.altMaterials.length;\n                sofaGroup.userData.stateIndex = idx;\n                const mat = sofaGroup.userData.altMaterials[idx];\n                sofaBase.material = mat;\n                sofaBack.material = mat;\n            }\n        );\n\n        // Hotspot to toggle coffee table visibility\n        createHotspot(\n            new THREE.Vector3(tableTop.position.x, 0.9, tableTop.position.z),\n            'Coffee Table',\n            () => {\n                tableGroup.visible = !tableGroup.visible;\n            }\n        );\n    }\n\n    function createKitchen(group, r) {\n        // Counter along back wall\n        const counterMat = new THREE.MeshStandardMaterial({ color: 0xd0d0d0, roughness: 0.4 });\n        const counter = new THREE.Mesh(new THREE.BoxGeometry(r.w - 0.5, 0.9, 0.6), counterMat);\n        counter.position.set(r.x, 0.45, r.z - r.d/2 + 0.3);\n        counter.castShadow = true;\n        counter.receiveShadow = true;\n        group.add(counter);\n        objects.push(counter);\n\n        // \"Fridge\" block (toggle color)\n        const fridgeMat1 = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.3 });\n        const fridgeMat2 = new THREE.MeshStandardMaterial({ color: 0xccccff, roughness: 0.3, metalness: 0.4 });\n        const fridge = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.7), fridgeMat1);\n        fridge.position.set(r.x + r.w/2 - 0.4, 0.9, r.z - r.d/2 + 0.5);\n        fridge.castShadow = true;\n        group.add(fridge);\n        objects.push(fridge);\n\n        fridge.userData.altMaterials = [fridgeMat1, fridgeMat2];\n        fridge.userData.stateIndex = 0;\n\n        createHotspot(\n            new THREE.Vector3(fridge.position.x, fridge.position.y + 0.5, fridge.position.z + 0.4),\n            'Fridge Color',\n            () => {\n                const idx = (fridge.userData.stateIndex + 1) % fridge.userData.altMaterials.length;\n                fridge.userData.stateIndex = idx;\n                fridge.material = fridge.userData.altMaterials[idx];\n            }\n        );\n    }\n\n    function createBedroom(group, r) {\n        // Bed (toggle sheets color)\n        const bedMat1 = new THREE.MeshStandardMaterial({ color: 0x99ccff, roughness: 0.8 });\n        const bedMat2 = new THREE.MeshStandardMaterial({ color: 0xffcc99, roughness: 0.8 });\n\n        const bedBase = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.4, 1.4), new THREE.MeshStandardMaterial({ color: 0x663300 }));\n        bedBase.position.set(r.x, 0.2, r.z);\n        bedBase.castShadow = true;\n\n        const sheets = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.2, 1.3), bedMat1);\n        sheets.position.set(r.x, 0.55, r.z);\n        sheets.castShadow = true;\n\n        const headboard = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.8, 0.15), new THREE.MeshStandardMaterial({ color: 0x552200 }));\n        headboard.position.set(r.x, 0.9, r.z - 0.7);\n        headboard.castShadow = true;\n\n        const bedGroup = new THREE.Group();\n        bedGroup.add(bedBase);\n        bedGroup.add(sheets);\n        bedGroup.add(headboard);\n        bedGroup.userData.altSheets = [bedMat1, bedMat2];\n        bedGroup.userData.stateIndex = 0;\n        group.add(bedGroup);\n        objects.push(bedGroup);\n\n        createHotspot(\n            new THREE.Vector3(sheets.position.x, 1.0, sheets.position.z),\n            'Bed Sheets',\n            () => {\n                const idx = (bedGroup.userData.stateIndex + 1) % bedGroup.userData.altSheets.length;\n                bedGroup.userData.stateIndex = idx;\n                sheets.material = bedGroup.userData.altSheets[idx];\n            }\n        );\n\n        // Wardrobe (toggle visibility)\n        const wardrobeMat = new THREE.MeshStandardMaterial({ color: 0xdedede, roughness: 0.6 });\n        const wardrobe = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.0, 0.6), wardrobeMat);\n        wardrobe.position.set(r.x - r.w/2 + 0.8, 1.0, r.z + r.d/2 - 0.3);\n        wardrobe.castShadow = true;\n        group.add(wardrobe);\n        objects.push(wardrobe);\n\n        createHotspot(\n            new THREE.Vector3(wardrobe.position.x, 1.8, wardrobe.position.z + 0.4),\n            'Wardrobe',\n            () => {\n                wardrobe.visible = !wardrobe.visible;\n            }\n        );\n\n        // Hotspot to toggle wall color of bedroom\n        const roomWalls = [];\n        group.traverse((o) => {\n            if (o.isMesh && o.material && o.material.color && o.geometry.parameters && o.geometry.parameters.height === 3) {\n                roomWalls.push(o);\n            }\n        });\n        const altWallMat1 = new THREE.Color(0xfff5f0);\n        const altWallMat2 = new THREE.Color(0xd0f0ff);\n        group.userData.altWallColors = [altWallMat1, altWallMat2];\n        group.userData.wallColorIndex = 0;\n\n        createHotspot(\n            new THREE.Vector3(r.x + r.w/2 - 0.5, 1.5, r.z),\n            'Bedroom Wall Color',\n            () => {\n                const idx = (group.userData.wallColorIndex + 1) % group.userData.altWallColors.length;\n                group.userData.wallColorIndex = idx;\n                const col = group.userData.altWallColors[idx];\n                roomWalls.forEach(w => w.material.color.copy(col));\n            }\n        );\n    }\n\n    function triggerHotspot() {\n        // Raycast from camera center\n        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);\n        const intersects = raycaster.intersectObjects(hotspots, false);\n        if (intersects.length > 0) {\n            const hot = intersects[0].object;\n            if (hot.userData.toggleFn) {\n                hot.userData.toggleFn();\n                hot.material = (hot.material === hotMaterialOn) ? hotMaterialOff : hotMaterialOn;\n            }\n        }\n    }\n\n    function onWindowResize() {\n        const w = window.innerWidth;\n        const h = window.innerHeight;\n        camera.aspect = w / h;\n        camera.updateProjectionMatrix();\n        renderer.setSize(w, h);\n\n        if (minimapContainer) {\n            minimapRenderer.setSize(minimapContainer.clientWidth, minimapContainer.clientHeight);\n        }\n    }\n\n    function updateControls(delta) {\n        if (!controls.isLocked) return;\n\n        const speed = 5.0;\n        const damping = 10.0;\n\n        velocity.x -= velocity.x * damping * delta;\n        velocity.z -= velocity.z * damping * delta;\n        velocity.y -= velocity.y * damping * delta;\n\n        direction.z = Number(moveForward) - Number(moveBackward);\n        direction.x = Number(moveRight) - Number(moveLeft);\n        direction.y = Number(moveUp) - Number(moveDown);\n        direction.normalize();\n\n        if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;\n        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;\n        if (moveUp || moveDown) velocity.y -= direction.y * speed * delta;\n\n        // Proposed movement\n        const oldPos = controls.getObject().position.clone();\n        const newPos = oldPos.clone();\n        const forward = new THREE.Vector3();\n        camera.getWorldDirection(forward);\n\n        // Convert local velocity to world\n        const quat = controls.getObject().quaternion;\n        const vel = velocity.clone().applyQuaternion(quat);\n\n        newPos.addScaledVector(vel, delta);\n\n        // Simple collision detection: check spheres against boxes\n        const finalPos = collideWithWorld(oldPos, newPos);\n\n        controls.getObject().position.copy(finalPos);\n        camera.position.y = playerHeight; // keep eye height constant\n    }\n\n    function collideWithWorld(oldPos, newPos) {\n        const sphere = { center: newPos.clone().setY(playerHeight / 2), radius: playerRadius };\n\n        let correction = new THREE.Vector3(0, 0, 0);\n\n        for (let i = 0; i < objects.length; i++) {\n            const obj = objects[i];\n            if (!obj.visible) continue;\n            tmpBox.setFromObject(obj);\n            const closestPoint = tmpBox.clampPoint(sphere.center, new THREE.Vector3());\n            const dist = closestPoint.distanceTo(sphere.center);\n            if (dist < sphere.radius) {\n                const pushDir = sphere.center.clone().sub(closestPoint).normalize();\n                const pushDist = sphere.radius - dist;\n                correction.add(pushDir.multiplyScalar(pushDist));\n            }\n        }\n\n        newPos.add(correction);\n        return newPos;\n    }\n\n    function updateRoomCulling() {\n        playerPosition.copy(controls.getObject().position);\n\n        // base: hide all\n        rooms.forEach(r => {\n            r.group.visible = false;\n        });\n\n        // Show room that contains player; also show immediate neighbors by overlap\n        let activeRooms = [];\n        rooms.forEach(r => {\n            if (r.bounds.containsPoint(playerPosition)) {\n                r.group.visible = true;\n                activeRooms.push(r);\n            }\n        });\n\n        // If none, show all as fallback\n        if (activeRooms.length === 0) {\n            rooms.forEach(r => r.group.visible = true);\n            return;\n        }\n\n        // Show neighbors that intersect with active rooms\n        rooms.forEach(r => {\n            for (let ar of activeRooms) {\n                if (ar === r) continue;\n                const b = r.bounds.clone();\n                if (b.intersectsBox(ar.bounds)) {\n                    r.group.visible = true;\n                    break;\n                }\n            }\n        });\n    }\n\n    function updateMinimap() {\n        if (!minimapRenderer) return;\n\n        // Sync minimap camera center to player XZ\n        const pos = controls.getObject().position;\n        minimapCamera.position.x = pos.x;\n        minimapCamera.position.z = pos.z;\n        minimapCamera.lookAt(pos.x, 0, pos.z - 1);\n\n        // Offscreen render\n        minimapRenderer.clear();\n        minimapRenderer.render(scene, minimapCamera);\n\n        // Draw simple player marker overlay in 2D using DOM canvas overlay\n        // (cheap alternative: small triangle via html canvas on top of WebGL canvas)\n        // For simplicity, we skip drawing direction; the player is implicit center.\n    }\n\n    function animate() {\n        requestAnimationFrame(animate);\n        const time = performance.now();\n        const delta = (time - prevTime) / 1000;\n        prevTime = time;\n\n        updateControls(delta);\n        updateRoomCulling();\n\n        renderer.render(scene, camera);\n        updateMinimap();\n    }\n</script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "openai/gpt-5.1"
    },
    "agent_name": "BenchAgent",
    "execution_time": 55.64448404312134,
    "status": "success",
    "timestamp": "2025-11-19 22:12:12",
    "evaluation": {
      "test_name": "architectural_walkthrough",
      "functional": {
        "score": 85,
        "passed": true,
        "renders": true,
        "errors": [
          "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
        ],
        "warnings": [],
        "screenshot": "output/screenshots/architectural_walkthrough.png",
        "render_time_ms": 960.72,
        "feedback": [
          {
            "level": "success",
            "message": "\u2705 Renders successfully in 960.72ms"
          },
          {
            "level": "error",
            "message": "\u274c 1 console error(s)",
            "details": [
              "Failed to resolve module specifier \"three\". Relative references must start with either \"/\", \"./\", or \"../\"."
            ]
          }
        ]
      },
      "quality": {
        "quality_score": 50,
        "raw_score": 1,
        "reasoning": "1. The task requires creating a complete HTML file for an architectural walkthrough using Three.js with various features like first-person controls, collision detection, interactive hotspots, and a minimap. 2. The given code snippet is an incomplete HTML document; it lacks necessary functionalities and features as requested. 3. Three.js library import is missing, which is critical for using 3D features. 4. The JavaScript section supposed to implement 3D rendering, object creation, and event handling is incomplete or missing. 5. There is some basic CSS and HTML structure, but it does not cover the complex requirements like procedural generation, lighting, collision, hotspot interaction, etc.",
        "strengths": "The code includes a basic HTML and CSS setup that defines a structure for UI elements like info, crosshair, minimap, and lock overlay.",
        "weaknesses": "The code is incomplete and lacks most critical functionalities required by the task, such as Three.js setup, procedural generation, lighting setup, implementation of first-person controls, and more.",
        "confidence": "high"
      },
      "overall_score": 74,
      "passed": true
    }
  }
]