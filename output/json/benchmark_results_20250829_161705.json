[
  {
    "test_name": "rotating_cube_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays a rotating 3D cube. The cube should have different colored faces, rotate continuously, and include proper lighting. The HTML file should be self-contained with Three.js loaded from CDN. Include camera controls for user interaction. Save the output as 'rotating_cube.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rotating 3D Cube with Three.js</title>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            background-color: #000;\n        }\n    </style>\n</head>\n<body>\n    <script>\n        // Scene, Camera, Renderer\n        var scene = new THREE.Scene();\n        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        var renderer = new THREE.WebGLRenderer();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // Materials for different colored faces\n        var materials = [\n            new THREE.MeshLambertMaterial({ color: 0xff0000 }), // Front: Red\n            new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Back: Green\n            new THREE.MeshLambertMaterial({ color: 0x0000ff }), // Top: Blue\n            new THREE.MeshLambertMaterial({ color: 0xff00ff }), // Bottom: Magenta\n            new THREE.MeshLambertMaterial({ color: 0xffff00 }), // Right: Yellow\n            new THREE.MeshLambertMaterial({ color: 0xffa500 })  // Left: Orange\n        ];\n\n        // Cube Geometry and Mesh\n        var geometry = new THREE.BoxGeometry(2, 2, 2);\n        var cube = new THREE.Mesh(geometry, materials);\n        scene.add(cube);\n\n        // Lighting\n        var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n        scene.add(ambientLight);\n        var pointLight = new THREE.PointLight(0xffffff, 1);\n        pointLight.position.set(10, 10, 10);\n        scene.add(pointLight);\n\n        // Camera Position\n        camera.position.z = 5;\n\n        // Camera Controls\n        var controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n        controls.dampingFactor = 0.05;\n\n        // Animation Loop\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // Rotate the cube continuously\n            cube.rotation.x += 0.01;\n            cube.rotation.y += 0.01;\n\n            // Update controls\n            controls.update();\n\n            // Render the scene\n            renderer.render(scene, camera);\n        }\n\n        // Start the animation\n        animate();\n\n        // Handle window resize\n        window.addEventListener('resize', function() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": "xai/grok-code-fast-1",
    "agent_name": "BenchAgent",
    "execution_time": 7.901647329330444,
    "status": "success",
    "timestamp": "2025-08-29 16:16:29"
  },
  {
    "test_name": "solar_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that simulates a simple solar system. Include the sun (yellow sphere) at the center, Earth (blue sphere) orbiting around it, and the moon (gray sphere) orbiting around Earth. Add realistic orbital speeds and include stars in the background. The HTML should be self-contained with Three.js from CDN. Save the output as 'solar_system.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Simple Solar System Simulation</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #000; }\n        #solarSystemCanvas { display: block; }\n    </style>\n</head>\n<body>\n    <canvas id=\"solarSystemCanvas\"></canvas>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js\"></script>\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);\n        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('solarSystemCanvas') });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n\n        // Lighting: Sun as point light\n        const sunLight = new THREE.PointLight(0xffffff, 2, 1000);\n        scene.add(sunLight);\n\n        // Ambient light for visibility\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.1);\n        scene.add(ambientLight);\n\n        // Create Sun\n        const sunGeometry = new THREE.SphereGeometry(20, 32, 32);\n        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow\n        const sun = new THREE.Mesh(sunGeometry, sunMaterial);\n        scene.add(sun);\n        sunLight.position.copy(sun.position); // Light at sun's position\n\n        // Create Earth\n        const earthGeometry = new THREE.SphereGeometry(5, 32, 32);\n        const earthMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff }); // Blue\n        const earth = new THREE.Mesh(earthGeometry, earthMaterial);\n        earth.position.set(200, 0, 0); // Distance from sun (exaggerated for visibility)\n        scene.add(earth);\n\n        // Create Moon\n        const moonGeometry = new THREE.SphereGeometry(1.5, 16, 16);\n        const moonMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 }); // Gray\n        const moon = new THREE.Mesh(moonGeometry, moonMaterial);\n        moon.position.set(20, 0, 0); // Distance from Earth (exaggerated)\n        earth.add(moon); // Moon orbits Earth\n\n        // Create stars background\n        const starCount = 10000;\n        const starGeometry = new THREE.BufferGeometry();\n        const starPositions = new Float32Array(starCount * 3);\n        for (let i = 0; i < starCount; i++) {\n            starPositions[i * 3] = (Math.random() - 0.5) * 2000; // X\n            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 2000; // Y\n            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 2000; // Z\n        }\n        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));\n        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });\n        const stars = new THREE.Points(starGeometry, starMaterial);\n        scene.add(stars);\n\n        // Camera position\n        camera.position.set(0, 100, 500);\n        camera.lookAt(0, 0, 0);\n\n        // Orbital speeds (realistic relative: Earth ~1 orbit/year, Moon ~12 orbits/year)\n        // Speed up for visibility: Earth 0.01 rad/frame, Moon 0.12 rad/frame (adjust as needed)\n        let earthAngle = 0;\n        let moonAngle = 0;\n        const earthSpeed = 0.01; // Radians per frame\n        const moonSpeed = 0.12; // Faster relative to Earth\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // Update Earth orbit around Sun\n            earthAngle += earthSpeed;\n            earth.position.x = 200 * Math.cos(earthAngle);\n            earth.position.z = 200 * Math.sin(earthAngle);\n\n            // Update Moon orbit around Earth\n            moonAngle += moonSpeed;\n            moon.position.x = 20 * Math.cos(moonAngle);\n            moon.position.z = 20 * Math.sin(moonAngle);\n\n            // Rotate planets for effect\n            sun.rotation.y += 0.005;\n            earth.rotation.y += 0.02;\n            moon.rotation.y += 0.01;\n\n            renderer.render(scene, camera);\n        }\n        animate();\n\n        // Handle window resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": "xai/grok-code-fast-1",
    "agent_name": "BenchAgent",
    "execution_time": 7.3840038776397705,
    "status": "success",
    "timestamp": "2025-08-29 16:16:37"
  },
  {
    "test_name": "particle_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays an animated particle system. The particles should move in interesting patterns (like a fountain, explosion, or flowing stream), change colors over time, and respond to mouse movement. Include at least 1000 particles with realistic physics. The HTML should be self-contained with Three.js from CDN. Save the output as 'particle_system.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Animated Particle System</title>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js\"></script>\n    <style>\n        body { margin: 0; overflow: hidden; }\n    </style>\n</head>\n<body>\n    <script>\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n        camera.position.z = 5;\n\n        const particleCount = 1000;\n        const positions = new Float32Array(particleCount * 3);\n        const velocities = new Float32Array(particleCount * 3);\n        const colors = new Float32Array(particleCount * 3);\n        const ages = new Float32Array(particleCount); // For color cycling based on age\n\n        const geometry = new THREE.BufferGeometry();\n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n        const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });\n        const points = new THREE.Points(geometry, material);\n        scene.add(points);\n\n        // Initialize particles in a fountain pattern (radial burst from a central point)\n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            positions[i3] = (Math.random() - 0.5) * 0.5; // Slight spread at start\n            positions[i3 + 1] = -2; // Start at bottom\n            positions[i3 + 2] = (Math.random() - 0.5) * 0.5;\n            const angle = Math.random() * Math.PI * 2; // Radial direction\n            const speed = Math.random() * 0.5 + 0.2;\n            velocities[i3] = Math.cos(angle) * speed;\n            velocities[i3 + 1] = Math.random() * 3 + 1; // Upward velocity for fountain effect\n            velocities[i3 + 2] = Math.sin(angle) * speed;\n            ages[i] = Math.random() * 10; // Random age for initial color\n        }\n\n        geometry.attributes.position.needsUpdate = true;\n        geometry.attributes.color.needsUpdate = true;\n\n        const mouse = new THREE.Vector2();\n        const mouse3D = new THREE.Vector3();\n        const raycaster = new THREE.Raycaster();\n\n        document.addEventListener('mousemove', (event) => {\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n            raycaster.setFromCamera(mouse, camera);\n            mouse3D.copy(raycaster.ray.origin).add(raycaster.ray.direction.multiplyScalar(5)); // Project to a plane at z=0 for simplicity\n        });\n\n        const gravity = new THREE.Vector3(0, -0.005, 0); // Gravity\n        const clock = new THREE.Clock();\n\n        function animate() {\n            requestAnimationFrame(animate);\n            const delta = clock.getDelta();\n\n            for (let i = 0; i < particleCount; i++) {\n                const i3 = i * 3;\n                const pos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n                const vel = new THREE.Vector3(velocities[i3], velocities[i3 + 1], velocities[i3 + 2]);\n\n                // Apply gravity (physics)\n                vel.add(gravity.clone().multiplyScalar(delta * 60));\n\n                // Mouse attraction (respond to mouse)\n                const toMouse = mouse3D.clone().sub(pos);\n                const distance = toMouse.length();\n                if (distance > 0.1) { // Avoid singularity\n                    toMouse.normalize().multiplyScalar(0.01 / Math.max(distance * 0.1, 0.01)); // Attraction force\n                    vel.add(toMouse.clone().multiplyScalar(delta * 60));\n                }\n\n                // Update velocity\n                velocities[i3] = vel.x;\n                velocities[i3 + 1] = vel.y;\n                velocities[i3 + 2] = vel.z;\n\n                // Update position\n                positions[i3] += vel.x * delta * 60;\n                positions[i3 + 1] += vel.y * delta * 60;\n                positions[i3 + 2] += vel.z * delta * 60;\n\n                // Respawn if particle goes below or far away (for continuous fountain)\n                if (positions[i3 + 1] < -2 || positions[i3] > 10 || positions[i3] < -10 || positions[i3 + 2] > 10 || positions[i3 + 2] < -10) {\n                    positions[i3] = (Math.random() - 0.5) * 0.5;\n                    positions[i3 + 1] = -2;\n                    positions[i3 + 2] = (Math.random() - 0.5) * 0.5;\n                    const angle = Math.random() * Math.PI * 2;\n                    const speed = Math.random() * 0.5 + 0.2;\n                    velocities[i3] = Math.cos(angle) * speed;\n                    velocities[i3 + 1] = Math.random() * 3 + 1;\n                    velocities[i3 + 2] = Math.sin(angle) * speed;\n                    ages[i] = 0; // Reset age\n                }\n\n                // Update age and color (change over time)\n                ages[i] += delta;\n                const hue = (ages[i] * 0.5) % 1; // Hue cycles based on age\n                const color = new THREE.Color().setHSL(hue, 0.8, 0.6); // Saturated, bright colors\n                colors[i3] = color.r;\n                colors[i3 + 1] = color.g;\n                colors[i3 + 2] = color.b;\n            }\n\n            geometry.attributes.position.needsUpdate = true;\n            geometry.attributes.color.needsUpdate = true;\n\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": "xai/grok-code-fast-1",
    "agent_name": "BenchAgent",
    "execution_time": 18.357232093811035,
    "status": "success",
    "timestamp": "2025-08-29 16:16:55"
  },
  {
    "test_name": "terrain_simulation",
    "prompt": "Create a complete HTML file with Three.js that generates and displays a 3D terrain landscape. The terrain should have hills and valleys using noise or height maps, include realistic texturing (grass, rock, etc.), and allow the user to fly through the scene with keyboard controls (WASD). Add fog effects for depth. The HTML should be self-contained with Three.js from CDN. Save the output as 'terrain_landscape.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Terrain Landscape with Three.js</title>\n    <style>\n        body { margin: 0; overflow: hidden; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js\"></script>\n\n    <script>\n        // Initialize Three.js scene\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.getElementById('container').appendChild(renderer.domElement);\n\n        // Add fog for depth\n        scene.fog = new THREE.FogExp2(0x87CEEB, 0.002); // Sky blue fog with density\n\n        // Lighting\n        const light = new THREE.DirectionalLight(0xffffff, 1);\n        light.position.set(100, 100, 50).normalize();\n        scene.add(light);\n        const ambientLight = new THREE.AmbientLight(0x404040);\n        scene.add(ambientLight);\n\n        // Terrain parameters\n        const width = 100;\n        const height = 100;\n        const widthSegments = 100;\n        const heightSegments = 100;\n        const scale = 10; // Scale for noise\n        const maxHeight = 20;\n\n        // Generate height map using Perlin noise\n        const geometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);\n        const vertices = geometry.attributes.position.array;\n\n        const noise = new noise.Noise(Math.random()); // Initialize noise with random seed\n\n        for (let i = 0; i < vertices.length; i += 3) {\n            const x = vertices[i] / scale;\n            const y = vertices[i + 1] / scale;\n            vertices[i + 2] = noise.perlin2(x, y) * maxHeight; // Height based on noise\n        }\n\n        geometry.attributes.position.needsUpdate = true;\n        geometry.computeVertexNormals(); // Compute normals for lighting\n\n        // Textures (simple procedural or base64 placeholders; in real use, load images)\n        const grassTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='); // Placeholder green\n        const rockTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mOcvHPjPwMDAwMDAwB0YCuRNfQRHQAAAABJRU5ErkJggg=='); // Placeholder gray\n\n        // Material with blending (simple approach: base grass, overlay rock for high areas)\n        // For realism, we can create a custom shader, but here we use standard material\n        const material = new THREE.MeshLambertMaterial({\n            map: grassTexture,\n            transparent: true\n        });\n\n        // Create terrain mesh\n        const terrain = new THREE.Mesh(geometry, material);\n        terrain.rotation.x = -Math.PI / 2; // Rotate to horizontal\n        scene.add(terrain);\n\n        // Add some rocks as spheres for variety\n        for (let i = 0; i < 20; i++) {\n            const rockGeometry = new THREE.SphereGeometry(2, 8, 8);\n            const rockMaterial = new THREE.MeshLambertMaterial({ map: rockTexture });\n            const rock = new THREE.Mesh(rockGeometry, rockMaterial);\n            rock.position.set((Math.random() - 0.5) * width, maxHeight / 2, (Math.random() - 0.5) * height);\n            scene.add(rock);\n        }\n\n        // Camera initial position\n        camera.position.set(0, 10, 30);\n\n        // Keyboard controls (WASD for movement)\n        const keys = { w: false, a: false, s: false, d: false };\n        const speed = 0.5;\n\n        function onKeyDown(event) {\n            switch (event.code) {\n                case 'KeyW': keys.w = true; break;\n                case 'KeyA': keys.a = true; break;\n                case 'KeyS': keys.s = true; break;\n                case 'KeyD': keys.d = true; break;\n            }\n        }\n\n        function onKeyUp(event) {\n            switch (event.code) {\n                case 'KeyW': keys.w = false; break;\n                case 'KeyA': keys.a = false; break;\n                case 'KeyS': keys.s = false; break;\n                case 'KeyD': keys.d = false; break;\n            }\n        }\n\n        document.addEventListener('keydown', onKeyDown, false);\n        document.addEventListener('keyup', onKeyUp, false);\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // Handle movement\n            if (keys.w) camera.position.z -= speed;\n            if (keys.s) camera.position.z += speed;\n            if (keys.a) camera.position.x -= speed;\n            if (keys.d) camera.position.x += speed;\n\n            renderer.render(scene, camera);\n        }\n        animate();\n\n        // Handle window resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": "xai/grok-code-fast-1",
    "agent_name": "BenchAgent",
    "execution_time": 10.22589898109436,
    "status": "success",
    "timestamp": "2025-08-29 16:17:05"
  }
]