[
  {
    "test_name": "rotating_cube_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays a rotating 3D cube. The cube should have different colored faces, rotate continuously, and include proper lighting. The HTML file should be self-contained with Three.js loaded from CDN. Include camera controls for user interaction. Save the output as 'rotating_cube.html'.",
    "response": "Below is the complete HTML file for displaying a rotating 3D cube with different colored faces using Three.js. The file includes proper lighting and camera controls for user interaction. Save this as `rotating_cube.html`.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rotating 3D Cube</title>\n    <style>\n        body { margin: 0; }\n        canvas { display: block; }\n    </style>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.142.0/examples/js/controls/OrbitControls.js\"></script>\n</head>\n<body>\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // Cube setup\n        const geometry = new THREE.BoxGeometry();\n        const materials = [\n            new THREE.MeshBasicMaterial({ color: 0xff0000 }), // Red\n            new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // Green\n            new THREE.MeshBasicMaterial({ color: 0x0000ff }), // Blue\n            new THREE.MeshBasicMaterial({ color: 0xffff00 }), // Yellow\n            new THREE.MeshBasicMaterial({ color: 0xff00ff }), // Magenta\n            new THREE.MeshBasicMaterial({ color: 0x00ffff })  // Cyan\n        ];\n        const cube = new THREE.Mesh(geometry, materials);\n        scene.add(cube);\n\n        // Lighting\n        const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light\n        scene.add(ambientLight);\n        const pointLight = new THREE.PointLight(0xffffff, 1, 100);\n        pointLight.position.set(10, 10, 10);\n        scene.add(pointLight);\n\n        // Camera and controls\n        camera.position.z = 5;\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            cube.rotation.x += 0.01;\n            cube.rotation.y += 0.01;\n            controls.update();\n            renderer.render(scene, camera);\n        }\n\n        // Adjust scene on window resize\n        window.addEventListener('resize', () => {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        });\n\n        animate();\n    </script>\n</body>\n</html>\n```\n\n### Instructions\n\n1. Copy the above HTML content.\n2. Create a new file named `rotating_cube.html`.\n3. Paste the copied HTML content into the file.\n4. Save the file and open it in a web browser to view the rotating 3D cube.",
    "model": "gpt-4o",
    "agent_name": "BenchAgent",
    "execution_time": 8.058034181594849,
    "status": "success",
    "timestamp": "2025-08-29 15:33:41"
  },
  {
    "test_name": "solar_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that simulates a simple solar system. Include the sun (yellow sphere) at the center, Earth (blue sphere) orbiting around it, and the moon (gray sphere) orbiting around Earth. Add realistic orbital speeds and include stars in the background. The HTML should be self-contained with Three.js from CDN. Save the output as 'solar_system.html'.",
    "response": "Below is a complete HTML file using Three.js that simulates a simple solar system with a sun, Earth, and moon. The sun is at the center, Earth orbits around the sun, and the moon orbits around Earth. Stars are added in the background, and realistic orbital speeds are included for both Earth and the moon. Save this content as 'solar_system.html'.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Simple Solar System</title>\n    <style>\n        body { margin: 0; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n<script>\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);\n    const renderer = new THREE.WebGLRenderer();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n\n    // Add stars to the background\n    const starsGeometry = new THREE.BufferGeometry();\n    const starsMaterial = new THREE.PointsMaterial({ color: 0x888888, size: 0.7 });\n    const starCount = 10000;\n    const starVertices = [];\n\n    for (let i = 0; i < starCount; i++) {\n        const x = THREE.MathUtils.randFloatSpread(1000);\n        const y = THREE.MathUtils.randFloatSpread(1000);\n        const z = THREE.MathUtils.randFloatSpread(1000);\n        starVertices.push(x, y, z);\n    }\n\n    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));\n    const starField = new THREE.Points(starsGeometry, starsMaterial);\n    scene.add(starField);\n\n    // Sun\n    const sunGeometry = new THREE.SphereGeometry(5, 32, 32);\n    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });\n    const sun = new THREE.Mesh(sunGeometry, sunMaterial);\n    scene.add(sun);\n\n    // Earth\n    const earthGeometry = new THREE.SphereGeometry(1, 32, 32);\n    const earthMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });\n    const earth = new THREE.Mesh(earthGeometry, earthMaterial);\n    \n    // Moon\n    const moonGeometry = new THREE.SphereGeometry(0.27, 32, 32);\n    const moonMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });\n    const moon = new THREE.Mesh(moonGeometry, moonMaterial);\n\n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0x404040);\n    scene.add(ambientLight);\n    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);\n    directionalLight.position.set(10, 10, 5).normalize();\n    scene.add(directionalLight);\n\n    const earthOrbitRadius = 20;\n    const moonOrbitRadius = 3;\n\n    // Create a pivot point for Earth's orbit\n    const earthPivot = new THREE.Object3D();\n    sun.add(earthPivot);\n    earthPivot.add(earth);\n\n    // Create a pivot point for Moon's orbit\n    const moonPivot = new THREE.Object3D();\n    earth.add(moonPivot);\n    moonPivot.add(moon);\n    moon.position.x = moonOrbitRadius;\n\n    camera.position.z = 50;\n\n    const animate = function() {\n        requestAnimationFrame(animate);\n\n        // Earth's orbit around the Sun\n        earthPivot.rotation.y += 0.01 * (2 * Math.PI / 365); // Earth orbits once per year\n        earth.position.x = earthOrbitRadius;\n\n        // Moon's orbit around the Earth\n        moonPivot.rotation.y += 0.01 * (2 * Math.PI / 27); // Moon orbits once per 27 days\n\n        renderer.render(scene, camera);\n    };\n\n    animate();\n</script>\n</body>\n</html>\n```\n\nThis HTML file includes a script that sets up a 3D scene using Three.js, including the sun, Earth, and moon with respective orbits, and stars in the background for added realism. Save this content as `solar_system.html` and open it in a browser to see the simulation.",
    "model": "gpt-4o",
    "agent_name": "BenchAgent",
    "execution_time": 11.1163911819458,
    "status": "success",
    "timestamp": "2025-08-29 15:33:52"
  },
  {
    "test_name": "particle_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays an animated particle system. The particles should move in interesting patterns (like a fountain, explosion, or flowing stream), change colors over time, and respond to mouse movement. Include at least 1000 particles with realistic physics. The HTML should be self-contained with Three.js from CDN. Save the output as 'particle_system.html'.",
    "response": "Below is the code for a self-contained HTML file using Three.js to create an animated particle system. This example will create a fountain-like effect where particles emit from a central point and respond to mouse movements.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Particle System with Three.js</title>\n    <style>\n        body { margin: 0; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js\"></script>\n    <script>\n        let scene, camera, renderer, particles, particleSystem, clock;\n        const PARTICLE_COUNT = 1000;\n\n        init();\n        animate();\n\n        function init() {\n            // Scene\n            scene = new THREE.Scene();\n\n            // Camera\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n            camera.position.z = 5;\n\n            // Renderer\n            renderer = new THREE.WebGLRenderer();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            document.body.appendChild(renderer.domElement);\n\n            // Particles\n            particles = new THREE.BufferGeometry();\n            let positions = [];\n            let colors = [];\n            let velocities = [];\n\n            for (let i = 0; i < PARTICLE_COUNT; i++) {\n                positions.push(0, 0, 0);\n\n                let color = new THREE.Color();\n                color.setHSL(i / PARTICLE_COUNT, 1.0, 0.5);\n                colors.push(color.r, color.g, color.b);\n\n                velocities.push(\n                    (Math.random() - 0.5) * 0.2,\n                    Math.random() * 0.4 + 0.1,\n                    (Math.random() - 0.5) * 0.2\n                );\n            }\n\n            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n            particles.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));\n\n            // Material\n            let material = new THREE.PointsMaterial({\n                size: 0.05,\n                vertexColors: true,\n                transparent: true,\n                opacity: 0.7\n            });\n\n            // Particle System\n            particleSystem = new THREE.Points(particles, material);\n            scene.add(particleSystem);\n\n            // Clock for animation timing\n            clock = new THREE.Clock();\n\n            // Event Listeners\n            window.addEventListener('resize', onWindowResize, false);\n            document.addEventListener('mousemove', onDocumentMouseMove, false);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            let delta = clock.getDelta();\n            let positions = particles.attributes.position.array;\n            let velocities = particles.attributes.velocity.array;\n            let colors = particles.attributes.color.array;\n\n            for (let i = 0; i < PARTICLE_COUNT; i++) {\n                let index = i * 3;\n\n                // Update particle position\n                positions[index] += velocities[index] * delta;\n                positions[index + 1] += velocities[index + 1] * delta;\n                positions[index + 2] += velocities[index + 2] * delta;\n\n                // Simple gravity\n                velocities[index + 1] -= 0.01 * delta;\n\n                // Reset particles once they fall below the 'floor'\n                if (positions[index + 1] < -2) {\n                    positions[index] = 0;\n                    positions[index + 1] = 0;\n                    positions[index + 2] = 0;\n                    velocities[index] = (Math.random() - 0.5) * 0.2;\n                    velocities[index + 1] = Math.random() * 0.4 + 0.1;\n                    velocities[index + 2] = (Math.random() - 0.5) * 0.2;\n                }\n\n                // Change color over time\n                let color = new THREE.Color();\n                color.setHSL((i + clock.getElapsedTime() * 10) % PARTICLE_COUNT / PARTICLE_COUNT, 1.0, 0.5);\n                colors[index] = color.r;\n                colors[index + 1] = color.g;\n                colors[index + 2] = color.b;\n            }\n\n            particles.attributes.position.needsUpdate = true;\n            particles.attributes.color.needsUpdate = true;\n\n            renderer.render(scene, camera);\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function onDocumentMouseMove(event) {\n            let mouseX = (event.clientX / window.innerWidth) * 2 - 1;\n            let mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n\n            // Apply simple effect of mouse movement on particles\n            particleSystem.rotation.y = mouseX * 0.5;\n            particleSystem.rotation.x = mouseY * 0.5;\n        }\n    </script>\n</body>\n</html>\n```\n\nSave this code as `particle_system.html` and open it in your browser. This code will create an animated particle system with 1000 particles that change color over time and react to mouse movements in a fountain-like pattern.",
    "model": "gpt-4o",
    "agent_name": "BenchAgent",
    "execution_time": 12.123213052749634,
    "status": "success",
    "timestamp": "2025-08-29 15:34:04"
  },
  {
    "test_name": "terrain_simulation",
    "prompt": "Create a complete HTML file with Three.js that generates and displays a 3D terrain landscape. The terrain should have hills and valleys using noise or height maps, include realistic texturing (grass, rock, etc.), and allow the user to fly through the scene with keyboard controls (WASD). Add fog effects for depth. The HTML should be self-contained with Three.js from CDN. Save the output as 'terrain_landscape.html'.",
    "response": "Below is a complete HTML file that uses Three.js to generate and display a 3D terrain landscape. The file includes a simple implementation of Perlin noise for terrain generation, realistic textures, and basic fog effects. User controls (WASD) are provided to navigate through the scene.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Terrain Landscape</title>\n    <style>\n        body { margin: 0; overflow: hidden; }\n        #info { position: absolute; top: 10px; left: 20px; color: white; }\n    </style>\n</head>\n<body>\n    <div id=\"info\">Use WASD to fly through the landscape</div>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/simplex-noise/simplex-noise.js\"></script>\n    <script>\n        // Initialization\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n        const renderer = new THREE.WebGLRenderer();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n        \n        // Fog\n        scene.fog = new THREE.FogExp2(0xcccccc, 0.002);\n\n        // Terrain\n        const size = 200;\n        const divisions = 128;\n        const geometry = new THREE.PlaneGeometry(size, size, divisions, divisions);\n        const simplex = new SimplexNoise();\n        \n        geometry.vertices.forEach(vertex => {\n            const height = simplex.noise2D(vertex.x * 0.1, vertex.y * 0.1) * 5;\n            vertex.z = height;\n        });\n        \n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n\n        // Load textures\n        const textureLoader = new THREE.TextureLoader();\n        const grassTexture = textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/wall.jpg');\n\n        const material = new THREE.MeshBasicMaterial({ map: grassTexture });\n        const terrain = new THREE.Mesh(geometry, material);\n        terrain.rotation.x = -Math.PI / 2;\n        scene.add(terrain);\n\n        // Position the camera\n        camera.position.set(0, 20, 50);\n        \n        // Controls setup\n        const controls = new function() {\n            this.velocity = new THREE.Vector3();\n            this.direction = new THREE.Vector3();\n            this.moveForward = false;\n            this.moveRight = false;\n            this.moveBackward = false;\n            this.moveLeft = false;\n        };\n\n        window.addEventListener('keydown', (event) => {\n            switch(event.key) {\n                case 'w': controls.moveForward = true; break;\n                case 'a': controls.moveLeft = true; break;\n                case 's': controls.moveBackward = true; break;\n                case 'd': controls.moveRight = true; break;\n            }\n        });\n\n        window.addEventListener('keyup', (event) => {\n            switch(event.key) {\n                case 'w': controls.moveForward = false; break;\n                case 'a': controls.moveLeft = false; break;\n                case 's': controls.moveBackward = false; break;\n                case 'd': controls.moveRight = false; break;\n            }\n        });\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            controls.velocity.x -= controls.velocity.x * 0.1;\n            controls.velocity.z -= controls.velocity.z * 0.1;\n\n            controls.direction.z = Number(controls.moveForward) - Number(controls.moveBackward);\n            controls.direction.x = Number(controls.moveRight) - Number(controls.moveLeft);\n            controls.direction.normalize();\n\n            if (controls.moveForward || controls.moveBackward) controls.velocity.z -= controls.direction.z * 0.1;\n            if (controls.moveRight || controls.moveLeft) controls.velocity.x -= controls.direction.x * 0.1;\n\n            camera.position.x += controls.velocity.x;\n            camera.position.z += controls.velocity.z;\n\n            renderer.render(scene, camera);\n        }\n\n        animate();\n        \n        // Handle window resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```\n\nIn this example:\n- The terrain is generated using the `simplex-noise` library, which provides noise functions similar to Perlin noise.\n- The WASD keys can be used to move the camera around to simulate flying.\n- A basic texture is applied to the terrain for a realistic look.\n- Modular camera movement is achieved through simple velocity and direction calculations controlled by key events.\n\nNote that a more detailed environment might require additional refinements in texturing, optimization, and control precision for a more realistic look and fluid experience.",
    "model": "gpt-4o",
    "agent_name": "BenchAgent",
    "execution_time": 14.228978872299194,
    "status": "success",
    "timestamp": "2025-08-29 15:34:18"
  }
]