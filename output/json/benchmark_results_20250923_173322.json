[
  {
    "test_name": "rotating_cube_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays a rotating 3D cube. The cube should have different colored faces, rotate continuously, and include proper lighting. The HTML file should be self-contained with Three.js loaded from CDN. Include camera controls for user interaction. Save the output as 'rotating_cube.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rotating 3D Cube with Three.js</title>\n    <style>\n        body { margin: 0; padding: 0; overflow: hidden; background: #000; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // Cube with different colored faces\n        const geometry = new THREE.BoxGeometry(1, 1, 1);\n        const materials = [\n            new THREE.MeshLambertMaterial({ color: 0xff0000 }), // Red\n            new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Green\n            new THREE.MeshLambertMaterial({ color: 0x0000ff }), // Blue\n            new THREE.MeshLambertMaterial({ color: 0xffff00 }), // Yellow\n            new THREE.MeshLambertMaterial({ color: 0xff00ff }), // Magenta\n            new THREE.MeshLambertMaterial({ color: 0x00ffff })  // Cyan\n        ];\n        const cube = new THREE.Mesh(geometry, materials);\n        scene.add(cube);\n\n        // Lighting\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n        scene.add(ambientLight);\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n        directionalLight.position.set(1, 1, 1);\n        scene.add(directionalLight);\n\n        // Camera position\n        camera.position.z = 3;\n\n        // Controls\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n        controls.dampingFactor = 0.05;\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            cube.rotation.x += 0.01;\n            cube.rotation.y += 0.01;\n            controls.update();\n            renderer.render(scene, camera);\n        }\n        animate();\n\n        // Handle window resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 5.142279863357544,
    "status": "success",
    "timestamp": "2025-09-23 17:22:28"
  },
  {
    "test_name": "solar_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that simulates a simple solar system. Include the sun (yellow sphere) at the center, Earth (blue sphere) orbiting around it, and the moon (gray sphere) orbiting around Earth. Add realistic orbital speeds and include stars in the background. The HTML should be self-contained with Three.js from CDN. Save the output as 'solar_system.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Solar System Simulation</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: black; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js\"></script>\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // Lighting\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.2);\n        scene.add(ambientLight);\n        const sunLight = new THREE.PointLight(0xffffff, 2, 100);\n        sunLight.position.set(0, 0, 0);\n        scene.add(sunLight);\n\n        // Sun\n        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);\n        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });\n        const sun = new THREE.Mesh(sunGeometry, sunMaterial);\n        scene.add(sun);\n\n        // Earth\n        const earthGeometry = new THREE.SphereGeometry(0.5, 32, 32);\n        const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });\n        const earth = new THREE.Mesh(earthGeometry, earthMaterial);\n        scene.add(earth);\n\n        // Moon\n        const moonGeometry = new THREE.SphereGeometry(0.2, 32, 32);\n        const moonMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });\n        const moon = new THREE.Mesh(moonGeometry, moonMaterial);\n        scene.add(moon);\n\n        // Stars background\n        const starsGeometry = new THREE.BufferGeometry();\n        const starsVertices = [];\n        for (let i = 0; i < 10000; i++) {\n            const x = (Math.random() - 0.5) * 2000;\n            const y = (Math.random() - 0.5) * 2000;\n            const z = (Math.random() - 0.5) * 2000;\n            starsVertices.push(x, y, z);\n        }\n        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));\n        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });\n        const stars = new THREE.Points(starsGeometry, starsMaterial);\n        scene.add(stars);\n\n        // Orbital parameters (scaled for visibility; relative speeds approximate real ratios)\n        const earthRadius = 10;\n        const moonRadius = 1.5;\n        const earthPeriod = 30; // seconds for one Earth orbit (arbitrary for visibility)\n        const moonPeriod = earthPeriod / 13.5; // Approximate 365/27 ratio\n\n        // Camera position\n        camera.position.set(0, 15, 30);\n        camera.lookAt(0, 0, 0);\n\n        // Animation loop\n        const clock = new THREE.Clock();\n        function animate() {\n            requestAnimationFrame(animate);\n            const t = clock.getElapsedTime();\n\n            // Earth orbit around sun\n            const earthAngle = (2 * Math.PI * t) / earthPeriod;\n            earth.position.x = earthRadius * Math.cos(earthAngle);\n            earth.position.z = earthRadius * Math.sin(earthAngle);\n            earth.position.y = 0;\n\n            // Moon orbit around Earth\n            const moonAngle = (2 * Math.PI * t) / moonPeriod;\n            moon.position.x = earth.position.x + moonRadius * Math.cos(moonAngle);\n            moon.position.y = earth.position.y + 0.2 * Math.sin(moonAngle * 1.2); // Slight inclination for realism\n            moon.position.z = earth.position.z + moonRadius * Math.sin(moonAngle);\n\n            // Rotate sun slightly for effect\n            sun.rotation.y += 0.01;\n\n            // Rotate Earth and Moon for self-rotation\n            earth.rotation.y += 0.02;\n            moon.rotation.y += 0.01;\n\n            renderer.render(scene, camera);\n        }\n        animate();\n\n        // Handle window resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 11.11352801322937,
    "status": "success",
    "timestamp": "2025-09-23 17:22:39"
  },
  {
    "test_name": "particle_system_simulation",
    "prompt": "Create a complete HTML file with Three.js that displays an animated particle system. The particles should move in interesting patterns (like a fountain, explosion, or flowing stream), change colors over time, and respond to mouse movement. Include at least 1000 particles with realistic physics. The HTML should be self-contained with Three.js from CDN. Save the output as 'particle_system.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Particle System with Three.js</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #000; }\n    </style>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n</head>\n<body>\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // Particle system parameters\n        const particleCount = 1000;\n        const positions = new Float32Array(particleCount * 3);\n        const colors = new Float32Array(particleCount * 3);\n        const velocities = new Float32Array(particleCount * 3);\n        const ages = new Float32Array(particleCount);\n\n        const geometry = new THREE.BufferGeometry();\n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n        const material = new THREE.PointsMaterial({\n            size: 0.05,\n            vertexColors: true,\n            transparent: true,\n            opacity: 0.8\n        });\n\n        const particles = new THREE.Points(geometry, material);\n        scene.add(particles);\n\n        // Mouse interaction\n        let mouseX = 0;\n        let mouseZ = 0;\n        document.addEventListener('mousemove', (event) => {\n            mouseX = ((event.clientX / window.innerWidth) * 2 - 1) * 5;\n            mouseZ = -((event.clientY / window.innerHeight) * 2 - 1) * 5;\n        });\n\n        // Clock for delta time\n        const clock = new THREE.Clock();\n\n        // Initialize particles\n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            // Initial positions scattered around\n            positions[i3] = (Math.random() - 0.5) * 20;\n            positions[i3 + 1] = (Math.random() - 0.5) * 20;\n            positions[i3 + 2] = (Math.random() - 0.5) * 20;\n\n            // Initial velocities\n            velocities[i3] = (Math.random() - 0.5) * 4;\n            velocities[i3 + 1] = (Math.random() - 0.5) * 4;\n            velocities[i3 + 2] = (Math.random() - 0.5) * 4;\n\n            ages[i] = Math.random() * 2;\n\n            // Initial colors\n            const progress = (ages[i] % 1);\n            const h = progress * 0.8 + 0.1; // Rainbow cycle\n            const rgb = new THREE.Color().setHSL(h, 1, 0.5);\n            colors[i3] = rgb.r;\n            colors[i3 + 1] = rgb.g;\n            colors[i3 + 2] = rgb.b;\n        }\n        geometry.attributes.position.needsUpdate = true;\n        geometry.attributes.color.needsUpdate = true;\n\n        // Lighting\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);\n        scene.add(ambientLight);\n\n        // Camera position\n        camera.position.set(0, 0, 30);\n\n        // Resize handler\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            const delta = clock.getDelta();\n\n            const posArray = geometry.attributes.position.array;\n            const colorArray = geometry.attributes.color.array;\n\n            for (let i = 0; i < particleCount; i++) {\n                const i3 = i * 3;\n\n                // Update position\n                posArray[i3] += velocities[i3] * delta;\n                posArray[i3 + 1] += velocities[i3 + 1] * delta;\n                posArray[i3 + 2] += velocities[i3 + 2] * delta;\n\n                // Apply gravity (realistic physics)\n                velocities[i3 + 1] -= 9.8 * delta;\n\n                // Check for respawn (fountain effect: reset when below ground)\n                if (posArray[i3 + 1] < -10) {\n                    // Emit new particle at mouse-influenced position\n                    posArray[i3] = mouseX + (Math.random() - 0.5) * 2;\n                    posArray[i3 + 1] = -10;\n                    posArray[i3 + 2] = mouseZ + (Math.random() - 0.5) * 2;\n\n                    // Upward velocity with some randomness (fountain)\n                    velocities[i3] = (Math.random() - 0.5) * 4;\n                    velocities[i3 + 1] = 15 + Math.random() * 10; // Strong upward burst\n                    velocities[i3 + 2] = (Math.random() - 0.5) * 4;\n\n                    ages[i] = 0;\n                } else {\n                    // Increment age for color change\n                    ages[i] += delta * 2; // Color cycle speed (1 second per cycle)\n                }\n\n                // Update color based on age (changes over time)\n                const progress = (ages[i] % 1);\n                let h = progress * 0.8 + 0.1; // Varying hue for colorful effect\n                const s = 1;\n                const l = 0.5;\n                const rgb = new THREE.Color().setHSL(h, s, l);\n                colorArray[i3] = rgb.r;\n                colorArray[i3 + 1] = rgb.g;\n                colorArray[i3 + 2] = rgb.b;\n            }\n\n            geometry.attributes.position.needsUpdate = true;\n            geometry.attributes.color.needsUpdate = true;\n\n            renderer.render(scene, camera);\n        }\n\n        animate();\n    </script>\n</body>\n</html>\n```\n\nThis HTML file has been saved as 'particle_system.html'. It creates a self-contained particle system using Three.js from CDN. The particles simulate a fountain-like explosion pattern with gravity-based physics, continuously emitting from a point that follows mouse movement in the x-z plane. Colors cycle through a rainbow hue over each particle's lifetime. The system handles 1000 particles with frame-rate independent updates for realistic motion. Open the file in a web browser to interact with it.",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 33.658987045288086,
    "status": "success",
    "timestamp": "2025-09-23 17:23:13"
  },
  {
    "test_name": "terrain_simulation",
    "prompt": "Create a complete HTML file with Three.js that generates and displays a 3D terrain landscape. The terrain should have hills and valleys using noise or height maps, include realistic texturing (grass, rock, etc.), and allow the user to fly through the scene with keyboard controls (WASD). Add fog effects for depth. The HTML should be self-contained with Three.js from CDN. Save the output as 'terrain_landscape.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Terrain Landscape</title>\n    <style>\n        body { margin: 0; overflow: hidden; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script>\n        // Simple Perlin noise implementation\n        class Perlin {\n            constructor() {\n                this.p = new Uint8Array(512);\n                for (let i = 0; i < 256; i++) {\n                    this.p[i] = i;\n                }\n                for (let i = 255; i > 0; i--) {\n                    const j = Math.floor(Math.random() * (i + 1));\n                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];\n                }\n                for (let i = 0; i < 256; i++) {\n                    this.p[256 + i] = this.p[i];\n                }\n            }\n\n            noise(x, y) {\n                const X = Math.floor(x) & 255;\n                const Y = Math.floor(y) & 255;\n                x -= Math.floor(x);\n                y -= Math.floor(y);\n                const u = this.fade(x);\n                const v = this.fade(y);\n                const A = this.p[X] + Y;\n                const AA = this.p[A];\n                const AB = this.p[A + 1];\n                const B = this.p[X + 1] + Y;\n                const BA = this.p[B];\n                const BB = this.p[B + 1];\n                return this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y),\n                    this.grad(this.p[BA], x - 1, y)),\n                    this.lerp(u, this.grad(this.p[AB], x, y - 1),\n                    this.grad(this.p[BB], x - 1, y - 1)));\n            }\n\n            fade(t) {\n                return t * t * t * (t * (t * 6 - 15) + 10);\n            }\n\n            lerp(t, a, b) {\n                return a + t * (b - a);\n            }\n\n            grad(hash, x, y) {\n                const h = hash & 15;\n                const u = h < 8 ? x : y;\n                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;\n                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n            }\n        }\n\n        const perlin = new Perlin();\n\n        // Scene setup\n        const scene = new THREE.Scene();\n        scene.fog = new THREE.Fog(0x87CEEB, 100, 1000); // Sky blue fog\n\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\n        camera.position.set(0, 50, 100);\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderer.domElement);\n\n        // Lights\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\n        scene.add(ambientLight);\n\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n        directionalLight.position.set(100, 100, 50);\n        directionalLight.castShadow = true;\n        directionalLight.shadow.mapSize.width = 2048;\n        directionalLight.shadow.mapSize.height = 2048;\n        scene.add(directionalLight);\n\n        // Terrain generation\n        const terrainSize = 256;\n        const terrainSegments = 255;\n        const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);\n        geometry.rotateX(-Math.PI / 2);\n\n        // Modify vertices with noise for hills and valleys\n        const vertices = geometry.attributes.position.array;\n        for (let i = 0; i < vertices.length; i += 3) {\n            const x = vertices[i];\n            const y = vertices[i + 1];\n            const z = vertices[i + 2];\n            const height = (perlin.noise(x / 50, z / 50) * 30 + perlin.noise(x / 20, z / 20) * 15) * 2; // Multi-octave noise\n            vertices[i + 2] = height;\n        }\n        geometry.attributes.position.needsUpdate = true;\n        geometry.computeVertexNormals();\n\n        // Generate procedural texture for grass/rock\n        const canvas = document.createElement('canvas');\n        canvas.width = 512;\n        canvas.height = 512;\n        const ctx = canvas.getContext('2d');\n\n        // Create a simple grass/rock texture\n        for (let x = 0; x < 512; x++) {\n            for (let y = 0; y < 512; y++) {\n                const noiseVal = perlin.noise(x / 20, y / 20);\n                if (noiseVal > 0.2) {\n                    ctx.fillStyle = '#228B22'; // Grass green\n                } else if (noiseVal > -0.2) {\n                    ctx.fillStyle = '#90EE90'; // Light grass\n                } else {\n                    ctx.fillStyle = '#8B4513'; // Rock brown\n                }\n                ctx.fillRect(x, y, 1, 1);\n            }\n        }\n        const texture = new THREE.CanvasTexture(canvas);\n        texture.wrapS = THREE.RepeatWrapping;\n        texture.wrapT = THREE.RepeatWrapping;\n        texture.repeat.set(8, 8);\n\n        const material = new THREE.MeshLambertMaterial({ map: texture });\n        const terrain = new THREE.Mesh(geometry, material);\n        terrain.receiveShadow = true;\n        scene.add(terrain);\n\n        // Camera controls\n        const keys = {};\n        document.addEventListener('keydown', (event) => {\n            keys[event.code] = true;\n        });\n        document.addEventListener('keyup', (event) => {\n            keys[event.code] = false;\n        });\n\n        const moveSpeed = 2;\n        const rotationSpeed = 0.02;\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // WASD controls for flying\n            const direction = new THREE.Vector3();\n            camera.getWorldDirection(direction);\n            direction.y = 0;\n            direction.normalize();\n\n            const right = new THREE.Vector3();\n            right.crossVectors(direction, camera.up).normalize();\n\n            if (keys['KeyW']) {\n                camera.position.addScaledVector(direction, moveSpeed);\n            }\n            if (keys['KeyS']) {\n                camera.position.addScaledVector(direction, -moveSpeed);\n            }\n            if (keys['KeyA']) {\n                camera.position.addScaledVector(right, -moveSpeed);\n            }\n            if (keys['KeyD']) {\n                camera.position.addScaledVector(right, moveSpeed);\n            }\n\n            // Keep camera above terrain (simple y adjustment)\n            camera.position.y = Math.max(camera.position.y, 10);\n\n            renderer.render(scene, camera);\n        }\n        animate();\n\n        // Handle resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 12.085413694381714,
    "status": "success",
    "timestamp": "2025-09-23 17:23:25"
  },
  {
    "test_name": "interactive_solar_system",
    "prompt": "Create a complete HTML file with Three.js that builds an interactive 3D solar system with textured planets, axial rotation, elliptical orbits, adjustable time speed, and click-to-reveal planet facts. Include orbit lines, lighting from a sun mesh, and responsive camera controls. The HTML file should be self-contained with Three.js loaded from CDN and include all textures as data URLs or procedural materials. Save the output as 'interactive_solar_system.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Solar System</title>\n    <style>\n        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }\n        #container { width: 100vw; height: 100vh; }\n        #ui { position: absolute; top: 10px; left: 10px; z-index: 1; background: rgba(0,0,0,0.5); color: white; padding: 10px; border-radius: 5px; }\n        #speed { width: 200px; }\n        #facts { position: absolute; top: 10px; right: 10px; background: white; padding: 15px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.5); display: none; max-width: 300px; z-index: 1; }\n        #facts h3 { margin-top: 0; }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <div id=\"ui\">\n        <label for=\"speed\">Time Speed: <span id=\"speedValue\">1</span>x</label><br>\n        <input type=\"range\" id=\"speed\" min=\"0.1\" max=\"10\" step=\"0.1\" value=\"1\">\n    </div>\n    <div id=\"facts\"></div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\n    <script>\n        // Scene setup\n        var scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x000011);\n        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\n        var renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.getElementById('container').appendChild(renderer.domElement);\n\n        var controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n        controls.dampingFactor = 0.05;\n        camera.position.set(0, 50, 150);\n        controls.update();\n\n        // Clock for delta time\n        var clock = new THREE.Clock();\n        var time = 0;\n        var timeSpeed = 1;\n\n        // Starfield\n        var starsGeometry = new THREE.BufferGeometry();\n        var starsVertices = [];\n        for (var i = 0; i < 10000; i++) {\n            starsVertices.push(THREE.MathUtils.randFloatSpread(2000), THREE.MathUtils.randFloatSpread(2000), THREE.MathUtils.randFloatSpread(2000));\n        }\n        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));\n        var starsMaterial = new THREE.PointsMaterial({ color: 0x888888, size: 0.5 });\n        var stars = new THREE.Points(starsGeometry, starsMaterial);\n        scene.add(stars);\n\n        // Lighting\n        var ambientLight = new THREE.AmbientLight(0x404040, 0.2);\n        scene.add(ambientLight);\n\n        // Sun\n        var sunGeometry = new THREE.SphereGeometry(5, 32, 32);\n        var sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });\n        var sun = new THREE.Mesh(sunGeometry, sunMaterial);\n        scene.add(sun);\n        var sunLight = new THREE.PointLight(0xffffff, 2, 0);\n        sun.add(sunLight);\n\n        // Planet data (approximate values: radius relative, a=semi-major axis, e=eccentricity, period in Earth days, rotSpeed, color, facts)\n        var planetsData = [\n            { name: 'Mercury', radius: 0.38, a: 10, e: 0.205, period: 88, rotSpeed: 0.003, color: 0x8c7853, facts: 'The smallest planet in the Solar System and the one closest to the Sun.' },\n            { name: 'Venus', radius: 0.95, a: 15, e: 0.007, period: 225, rotSpeed: -0.004, color: 0xffc649, facts: 'The hottest planet, with a thick atmosphere of mostly carbon dioxide.' },\n            { name: 'Earth', radius: 1, a: 20, e: 0.017, period: 365, rotSpeed: 0.02, color: 0x6b93d6, facts: 'The only known planet with life. It has one natural satellite, the Moon.' },\n            { name: 'Mars', radius: 0.53, a: 30, e: 0.093, period: 687, rotSpeed: 0.018, color: 0xc1440e, facts: 'Known as the Red Planet due to iron oxide on its surface. Has the largest volcano in the Solar System.' },\n            { name: 'Jupiter', radius: 11.2, a: 50, e: 0.049, period: 4333, rotSpeed: 0.041, color: 0xd8ca9d, facts: 'The largest planet, a gas giant with a Great Red Spot storm larger than Earth.' },\n            { name: 'Saturn', radius: 9.45, a: 70, e: 0.052, period: 10759, rotSpeed: 0.045, color: 0xfad5a5, facts: 'Famous for its extensive ring system composed mostly of ice particles.' },\n            { name: 'Uranus', radius: 4, a: 90, e: 0.047, period: 30687, rotSpeed: 0.03, color: 0x4fd0e7, facts: 'An ice giant that rotates on its side, possibly due to a massive collision.' },\n            { name: 'Neptune', radius: 3.88, a: 110, e: 0.009, period: 60190, rotSpeed: 0.032, color: 0x4b70dd, facts: 'The windiest planet, with the fastest winds reaching up to 2,100 km/h.' }\n        ];\n\n        // Create planets and orbits\n        var planets = [];\n        var orbitLines = [];\n        for (var i = 0; i < planetsData.length; i++) {\n            var data = planetsData[i];\n            var geometry = new THREE.SphereGeometry(data.radius, 32, 32);\n            var material = new THREE.MeshPhongMaterial({ color: data.color });\n            var planet = new THREE.Mesh(geometry, material);\n            planet.castShadow = true;\n            planet.receiveShadow = true;\n            planet.userData = { name: data.name, facts: data.facts, theta: 0, rotSpeed: data.rotSpeed, period: data.period, a: data.a, e: data.e };\n            scene.add(planet);\n            planets.push(planet);\n\n            // Orbit line (elliptical, focus at origin)\n            var points = [];\n            for (var j = 0; j <= 100; j++) {\n                var angle = (j / 100) * Math.PI * 2;\n                var r = data.a * (1 - data.e * data.e) / (1 + data.e * Math.cos(angle));\n                points.push(new THREE.Vector3(r * Math.cos(angle), 0, r * Math.sin(angle)));\n            }\n            var orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);\n            var orbitMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });\n            var orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);\n            scene.add(orbitLine);\n            orbitLines.push(orbitLine);\n        }\n\n        // UI for time speed\n        var speedSlider = document.getElementById('speed');\n        var speedValue = document.getElementById('speedValue');\n        speedSlider.oninput = function () {\n            timeSpeed = parseFloat(this.value);\n            speedValue.textContent = this.value;\n        };\n\n        // Raycaster for planet clicks\n        var raycaster = new THREE.Raycaster();\n        var mouse = new THREE.Vector2();\n        var factsDiv = document.getElementById('facts');\n        function onMouseClick(event) {\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n            raycaster.setFromCamera(mouse, camera);\n            var intersects = raycaster.intersectObjects(planets);\n            if (intersects.length > 0) {\n                var planet = intersects[0].object;\n                factsDiv.innerHTML = '<h3>' + planet.userData.name + '</h3><p>' + planet.userData.facts + '</p><button onclick=\"this.parentElement.style.display=\\'none\\'\">Close</button>';\n                factsDiv.style.display = 'block';\n            } else {\n                factsDiv.style.display = 'none';\n            }\n        }\n        window.addEventListener('click', onMouseClick, false);\n\n        // Window resize\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener('resize', onWindowResize, false);\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            var delta = clock.getDelta();\n            time += delta;\n\n            // Update planets\n            for (var i = 0; i < planets.length; i++) {\n                var planet = planets[i];\n                var data = planet.userData;\n                var theta = (time * timeSpeed * 2 * Math.PI) / data.period;\n                var r = data.a * (1 - data.e * data.e) / (1 + data.e * Math.cos(theta));\n                planet.position.x = r * Math.cos(theta);\n                planet.position.z = r * Math.sin(theta);\n                planet.position.y = 0;\n                planet.rotation.y += data.rotSpeed * timeSpeed * delta * 60; // Scaled for visibility\n            }\n\n            // Rotate sun slightly\n            sun.rotation.y += 0.005 * timeSpeed * delta;\n\n            controls.update();\n            renderer.render(scene, camera);\n        }\n        animate();\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 31.837130069732666,
    "status": "success",
    "timestamp": "2025-09-23 17:23:57"
  },
  {
    "test_name": "procedural_city_generator",
    "prompt": "Create a complete HTML file with Three.js that generates a procedural 3D city with random blocks, building heights, road grid, traffic light animations, day/night cycle with HDRI sky, and a free-fly camera. Add a mini-map overlay and a seed input to reproduce layouts. The HTML file should be self-contained with Three.js loaded from CDN and include all necessary shaders and textures inline. Save the output as 'procedural_city.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Procedural 3D City</title>\n    <style>\n        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }\n        #ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; color: white; }\n        #minimap { position: absolute; top: 10px; right: 10px; width: 200px; height: 200px; background: black; border: 1px solid white; z-index: 100; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n    <div id=\"ui\">\n        <label for=\"seed\">Seed:</label>\n        <input type=\"number\" id=\"seed\" value=\"123\" style=\"width: 60px;\">\n        <button id=\"gen\">Generate City</button>\n        <br>\n        <small>Click to lock mouse. WASD to move.</small>\n    </div>\n    <canvas id=\"minimap\"></canvas>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script>\n        let scene, camera, renderer;\n        let cityGroup, roadGroup, buildingGroup, lightGroup;\n        let trafficLights = [];\n        let rand;\n        let mapScale, mapOffset;\n        let gridSize = 10;\n        let blockSize = 50;\n        let roadWidth = 10;\n        let miniCanvas, miniCtx;\n\n        function seededRandom(seed) {\n            const m = 2147483647;\n            const a = 16807;\n            let s = Math.abs(seed) % m;\n            return function() {\n                s = (a * s) % m;\n                return s / m;\n            };\n        }\n\n        function init() {\n            scene = new THREE.Scene();\n            scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);\n\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\n            camera.position.set(0, 50, 100);\n\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            document.body.appendChild(renderer.domElement);\n\n            // Procedural sky shader\n            const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);\n            const skyMaterial = new THREE.ShaderMaterial({\n                uniforms: {\n                    time: { value: 0 }\n                },\n                vertexShader: `\n                    varying vec3 vWorldPosition;\n                    void main() {\n                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n                        vWorldPosition = worldPosition.xyz;\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                    }\n                `,\n                fragmentShader: `\n                    uniform float time;\n                    varying vec3 vWorldPosition;\n                    void main() {\n                        vec3 dir = normalize(vWorldPosition);\n                        float t = time * 0.0005;\n                        vec3 sunDir = normalize(vec3(sin(t * 6.28), cos(t * 6.28) * 0.5 + 0.5, 0.3));\n                        float sunDot = max(dot(dir, sunDir), 0.0);\n                        vec3 dayColor = mix(vec3(0.1, 0.3, 0.8), vec3(0.8, 0.9, 1.0), pow(sunDot, 2.0));\n                        vec3 nightColor = vec3(0.0, 0.0, 0.1);\n                        float sunIntensity = max(0.0, sunDir.y);\n                        vec3 color = mix(nightColor, dayColor, sunIntensity);\n                        gl_FragColor = vec4(color, 1.0);\n                    }\n                `,\n                side: THREE.BackSide\n            });\n            const sky = new THREE.Mesh(skyGeometry, skyMaterial);\n            scene.add(sky);\n\n            // Lights\n            const sunLight = new THREE.DirectionalLight(0xffffff, 1);\n            sunLight.position.set(100, 100, 50);\n            sunLight.castShadow = true;\n            sunLight.shadow.mapSize.width = 2048;\n            sunLight.shadow.mapSize.height = 2048;\n            scene.add(sunLight);\n\n            const ambient = new THREE.AmbientLight(0x404040, 0.4);\n            scene.add(ambient);\n\n            // Free-fly controls\n            let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;\n            let prevTime = performance.now();\n            const velocity = new THREE.Vector3();\n            const direction = new THREE.Vector3();\n            const euler = new THREE.Euler(0, 0, 0, 'YXZ');\n            const PI_2 = Math.PI / 2;\n\n            const onMouseMove = (event) => {\n                if (document.pointerLockElement === renderer.domElement || document.mozPointerLockElement === renderer.domElement) {\n                    camera.rotation.y -= event.movementX * 0.002;\n                    camera.rotation.x -= event.movementY * 0.002;\n                    camera.rotation.x = Math.max(-PI_2, Math.min(PI_2, camera.rotation.x));\n                }\n            };\n\n            const onKeyDown = (event) => {\n                switch (event.code) {\n                    case 'ArrowUp':\n                    case 'KeyW': moveForward = true; break;\n                    case 'ArrowLeft':\n                    case 'KeyA': moveLeft = true; break;\n                    case 'ArrowDown':\n                    case 'KeyS': moveBackward = true; break;\n                    case 'ArrowRight':\n                    case 'KeyD': moveRight = true; break;\n                }\n            };\n\n            const onKeyUp = (event) => {\n                switch (event.code) {\n                    case 'ArrowUp':\n                    case 'KeyW': moveForward = false; break;\n                    case 'ArrowLeft':\n                    case 'KeyA': moveLeft = false; break;\n                    case 'ArrowDown':\n                    case 'KeyS': moveBackward = false; break;\n                    case 'ArrowRight':\n                    case 'KeyD': moveRight = false; break;\n                }\n            };\n\n            renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());\n            document.addEventListener('mousemove', onMouseMove);\n            document.addEventListener('keydown', onKeyDown);\n            document.addEventListener('keyup', onKeyUp);\n\n            // Minimap\n            miniCanvas = document.getElementById('minimap');\n            miniCtx = miniCanvas.getContext('2d');\n\n            // Events\n            document.getElementById('gen').addEventListener('click', generateCity);\n            window.addEventListener('resize', onWindowResize);\n\n            generateCity();\n            animate();\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function generateCity() {\n            const seedValue = document.getElementById('seed').value;\n            const seed = parseInt(seedValue) || 123;\n            rand = seededRandom(seed);\n\n            // Clear\n            if (cityGroup) scene.remove(cityGroup);\n            cityGroup = new THREE.Group();\n            scene.add(cityGroup);\n            trafficLights = [];\n            buildingGroup = new THREE.Group();\n            cityGroup.add(buildingGroup);\n\n            const step = blockSize + roadWidth;\n            const numBlocks = gridSize;\n            const halfBlocks = numBlocks / 2;\n            const citySize = numBlocks * step;\n            mapScale = 180 / citySize;\n            mapOffset = citySize / 2;\n\n            // Roads\n            roadGroup = new THREE.Group();\n            cityGroup.add(roadGroup);\n            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });\n            for (let i = 0; i <= numBlocks; i++) {\n                // Horizontal\n                const hPosZ = (i - halfBlocks) * step;\n                const hGeometry = new THREE.PlaneGeometry(citySize, roadWidth);\n                const hRoad = new THREE.Mesh(hGeometry, roadMaterial);\n                hRoad.rotation.x = -Math.PI / 2;\n                hRoad.position.set(0, 0.01, hPosZ);\n                roadGroup.add(hRoad);\n\n                // Vertical\n                const vPosX = (i - halfBlocks) * step;\n                const vGeometry = new THREE.PlaneGeometry(roadWidth, citySize);\n                const vRoad = new THREE.Mesh(vGeometry, roadMaterial);\n                vRoad.rotation.x = -Math.PI / 2;\n                vRoad.position.set(vPosX, 0.01, 0);\n                roadGroup.add(vRoad);\n            }\n\n            // Buildings\n            for (let ix = 0; ix < numBlocks; ix++) {\n                for (let iz = 0; iz < numBlocks; iz++) {\n                    const blockX = (ix - halfBlocks + 0.5) * step;\n                    const blockZ = (iz - halfBlocks + 0.5) * step;\n                    const width = blockSize * (0.4 + rand() * 0.6);\n                    const depth = blockSize * (0.4 + rand() * 0.6);\n                    const height = 20 + rand() * 80;\n                    const geometry = new THREE.BoxGeometry(width, height, depth);\n                    const material = new THREE.MeshLambertMaterial({ color: new THREE.Color().setHSL(rand(), 0.5 + rand() * 0.5, 0.4 + rand() * 0.4) });\n                    const building = new THREE.Mesh(geometry, material);\n                    building.position.set(blockX, height / 2, blockZ);\n                    building.castShadow = true;\n                    building.receiveShadow = true;\n                    buildingGroup.add(building);\n                }\n            }\n\n            // Traffic lights\n            lightGroup = new THREE.Group();\n            cityGroup.add(lightGroup);\n            for (let ix = 0; ix <= numBlocks; ix++) {\n                for (let iz = 0; iz <= numBlocks; iz++) {\n                    const posX = (ix - halfBlocks) * step;\n                    const posZ = (iz - halfBlocks) * step;\n                    // Pole\n                    const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 6);\n                    const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });\n                    const pole = new THREE.Mesh(poleGeometry, poleMaterial);\n                    pole.position.set(posX, 3, posZ);\n                    lightGroup.add(pole);\n\n                    // Light head\n                    const headGeometry = new THREE.BoxGeometry(1, 3, 0.5);\n                    const head = new THREE.Mesh(headGeometry, new THREE.MeshLambertMaterial({ color: 0x444444 }));\n                    head.position.set(pole.position.x, pole.position.y + 3.5, pole.position.z);\n                    lightGroup.add(head);\n\n                    // Bulbs\n                    const bulbGeometry = new THREE.SphereGeometry(0.3);\n                    const redBulb = new THREE.Mesh(bulbGeometry, new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 }));\n                    redBulb.position.set(head.position.x, head.position.y + 0.75, head.position.z + 0.6);\n                    lightGroup.add(redBulb);\n\n                    const yellowBulb = new THREE.Mesh(bulbGeometry, new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0 }));\n                    yellowBulb.position.set(head.position.x, head.position.y, head.position.z + 0.6);\n                    lightGroup.add(yellowBulb);\n\n                    const greenBulb = new THREE.Mesh(bulbGeometry, new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0 }));\n                    greenBulb.position.set(head.position.x, head.position.y - 0.75, head.position.z + 0.6);\n                    lightGroup.add(greenBulb);\n\n                    const tl = { red: redBulb, yellow: yellowBulb, green: greenBulb, phase: rand() * 30 };\n                    trafficLights.push(tl);\n                }\n            }\n\n            updateMinimap();\n        }\n\n        function updateTrafficLights(currentTime) {\n            trafficLights.forEach(tl => {\n                let phase = ((currentTime * 0.001) % 30 + tl.phase) % 30;\n                tl.red.material.opacity = (phase < 12) ? 1 : 0;\n                tl.yellow.material.opacity = (phase >= 10 && phase < 13) ? 1 : 0;\n                tl.green.material.opacity = (phase >= 13 && phase < 25) ? 1 : 0;\n            });\n        }\n\n        function updateMinimap() {\n            miniCtx.fillStyle = '#000';\n            miniCtx.fillRect(0, 0, 200, 200);\n\n            // Roads\n            miniCtx.strokeStyle = '#333';\n            miniCtx.lineWidth = 1;\n            const step = blockSize + roadWidth;\n            const numBlocks = gridSize;\n            for (let i = 0; i <= numBlocks; i++) {\n                const mapZ = ( (i - numBlocks / 2) * step - mapOffset ) * mapScale + 100;\n                miniCtx.beginPath();\n                miniCtx.moveTo(10, mapZ);\n                miniCtx.lineTo(190, mapZ);\n                miniCtx.stroke();\n\n                const mapX = ( (i - numBlocks / 2) * step - mapOffset ) * mapScale + 100;\n                miniCtx.beginPath();\n                miniCtx.moveTo(mapX, 10);\n                miniCtx.lineTo(mapX, 190);\n                miniCtx.stroke();\n            }\n\n            // Buildings\n            miniCtx.fillStyle = '#666';\n            buildingGroup.children.forEach(building => {\n                const mapX = (building.position.x - mapOffset) * mapScale + 100;\n                const mapZ = (building.position.z - mapOffset) * mapScale + 100;\n                const halfW = building.geometry.parameters.width * mapScale / 2;\n                const halfD = building.geometry.parameters.depth * mapScale / 2;\n                miniCtx.fillRect(mapX - halfW, mapZ - halfD, halfW * 2, halfD * 2);\n            });\n\n            // Camera\n            const camMapX = (camera.position.x - mapOffset) * mapScale + 100;\n            const camMapZ = (camera.position.z - mapOffset) * mapScale + 100;\n            miniCtx.fillStyle = '#f00';\n            miniCtx.fillRect(camMapX - 2, camMapZ - 2, 4, 4);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const time = performance.now();\n            const delta = (time - prevTime) / 1000;\n\n            // Movement\n            velocity.x -= velocity.x * 10 * delta;\n            velocity.z -= velocity.z * 10 * delta;\n            direction.z = Number(moveForward) - Number(moveBackward);\n            direction.x = Number(moveRight) - Number(moveLeft);\n            direction.normalize();\n            if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;\n            if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;\n            euler.setFromRotationMatrix(camera.matrix);\n            const updatedVelocity = velocity.clone().applyEuler(euler);\n            camera.position.add(updatedVelocity.multiplyScalar(delta));\n            prevTime = time;\n\n            // Day/night cycle\n            const skyMat = scene.children[0].material; // sky\n            skyMat.uniforms.time.value = time;\n            const sunAngle = (time * 0.0005) % (Math.PI * 2);\n            const sunPos = new THREE.Vector3(500 * Math.cos(sunAngle), 500 * Math.sin(sunAngle), 0);\n            sunLight.position.copy(sunPos);\n            sunLight.intensity = Math.max(0, Math.sin(sunAngle));\n            ambient.intensity = 0.2 + 0.6 * Math.max(0, Math.sin(sunAngle));\n\n            updateTrafficLights(time);\n            updateMinimap();\n            renderer.render(scene, camera);\n        }\n\n        // Global prevTime\n        let prevTime = performance.now();\n        init();\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 94.65043091773987,
    "status": "success",
    "timestamp": "2025-09-23 17:25:32"
  },
  {
    "test_name": "terrain_flight_mode",
    "prompt": "Create a complete HTML file with Three.js that generates procedural terrain using heightmaps or Perlin noise with rivers, trees (instanced meshes), and LOD. Add a simple 'drone/plane' controller to fly above terrain with pitch/roll/yaw, speed boost, and collision avoidance. The HTML file should be self-contained with Three.js loaded from CDN and include all terrain generation code inline. Save the output as 'terrain_flight.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Terrain Flight Simulator</title>\n    <style>\n        body { margin: 0; overflow: hidden; }\n        canvas { display: block; }\n        #info {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            color: white;\n            font-family: Arial, sans-serif;\n            background: rgba(0,0,0,0.5);\n            padding: 10px;\n            border-radius: 5px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"info\">\n        Controls:<br>\n        W/S: Pitch up/down<br>\n        A/D: Roll left/right<br>\n        Q/E: Yaw left/right<br>\n        Arrow Up/Down: Forward/Backward<br>\n        Arrow Left/Right: Strafe left/right<br>\n        Space/Shift: Up/Down<br>\n        Hold Shift + W: Speed boost<br>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script>\n        // Perlin Noise Implementation (Classic Perlin Noise)\n        // Copied from a public domain implementation for simplicity\n        class Perlin {\n            constructor() {\n                this.p = new Uint8Array(512);\n                this.permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n                    190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,\n                    175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,\n                    65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,\n                    217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,\n                    248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,\n                    246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,\n                    184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n                for (let i = 0; i < 256; i++) {\n                    this.p[256 + i] = this.p[i] = this.permutation[i];\n                }\n            }\n\n            fade(t) {\n                return t * t * t * (t * (t * 6 - 15) + 10);\n            }\n\n            lerp(t, a, b) {\n                return a + t * (b - a);\n            }\n\n            grad(hash, x, y, z) {\n                const h = hash & 15;\n                const u = h < 8 ? x : y;\n                const v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n                return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n            }\n\n            noise(x, y, z) {\n                const X = Math.floor(x) & 255;\n                const Y = Math.floor(y) & 255;\n                const Z = Math.floor(z) & 255;\n                x -= Math.floor(x);\n                y -= Math.floor(y);\n                z -= Math.floor(z);\n                const u = this.fade(x);\n                const v = this.fade(y);\n                const w = this.fade(z);\n                const A = this.p[X] + Y;\n                const AA = this.p[A] + Z;\n                const AB = this.p[A + 1] + Z;\n                const B = this.p[X + 1] + Y;\n                const BA = this.p[B] + Z;\n                const BB = this.p[B + 1] + Z;\n                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z),\n                    this.grad(this.p[BA], x - 1, y, z)),\n                    this.lerp(u, this.grad(this.p[AB], x, y - 1, z),\n                    this.grad(this.p[BB], x - 1, y - 1, z))),\n                    this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),\n                    this.grad(this.p[BA + 1], x - 1, y, z - 1)),\n                    this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),\n                    this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));\n            }\n        }\n\n        const perlin = new Perlin();\n\n        // Terrain parameters\n        const TERRAIN_SIZE = 512;\n        const TERRAIN_SEGMENTS = 128;\n        const NOISE_SCALE = 0.01;\n        const HEIGHT_SCALE = 50;\n        const RIVER_WIDTH = 20;\n        const RIVER_DEPTH = 10;\n        const TREE_COUNT = 1000;\n        const TREE_HEIGHT = 10;\n\n        // Drone parameters\n        const DRONE_SPEED = 2;\n        const BOOST_SPEED = 5;\n        const SENSITIVITY = 0.01;\n\n        // Global variables\n        let scene, camera, renderer;\n        let terrain, trees;\n        let dronePosition = new THREE.Vector3(0, 100, 0);\n        let droneVelocity = new THREE.Vector3(0, 0, 0);\n        let droneEuler = new THREE.Euler(0, 0, 0, 'YXZ');\n        let keys = {};\n        let isBoosting = false;\n        let currentSpeed = DRONE_SPEED;\n\n        // Initialize scene\n        function init() {\n            scene = new THREE.Scene();\n            scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);\n\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);\n            camera.position.copy(dronePosition);\n\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            document.body.appendChild(renderer.domElement);\n\n            // Lighting\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\n            scene.add(ambientLight);\n\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(100, 100, 50);\n            directionalLight.castShadow = true;\n            directionalLight.shadow.mapSize.width = 2048;\n            directionalLight.shadow.mapSize.height = 2048;\n            scene.add(directionalLight);\n\n            generateTerrain();\n            generateTrees();\n\n            // Event listeners\n            document.addEventListener('keydown', onKeyDown);\n            document.addEventListener('keyup', onKeyUp);\n            window.addEventListener('resize', onWindowResize);\n\n            animate();\n        }\n\n        // Generate heightmap using Perlin noise with rivers\n        function generateHeightmap() {\n            const heightmap = new Float32Array((TERRAIN_SEGMENTS + 1) * (TERRAIN_SEGMENTS + 1));\n\n            for (let z = 0; z <= TERRAIN_SEGMENTS; z++) {\n                for (let x = 0; x <= TERRAIN_SEGMENTS; x++) {\n                    const worldX = (x / TERRAIN_SEGMENTS - 0.5) * TERRAIN_SIZE;\n                    const worldZ = (z / TERRAIN_SEGMENTS - 0.5) * TERRAIN_SIZE;\n\n                    // Base terrain height with multiple octaves\n                    let height = 0;\n                    let amplitude = 1;\n                    let frequency = NOISE_SCALE;\n                    for (let i = 0; i < 4; i++) {\n                        height += perlin.noise(worldX * frequency, worldZ * frequency, 0) * amplitude;\n                        amplitude *= 0.5;\n                        frequency *= 2;\n                    }\n                    height *= HEIGHT_SCALE;\n\n                    // River: simple sinusoidal river along Z axis in the middle\n                    const riverDist = Math.abs(worldX) / RIVER_WIDTH;\n                    if (riverDist < 1) {\n                        const riverHeight = Math.sin(worldZ * 0.1) * 5 - RIVER_DEPTH * (1 - riverDist);\n                        height = Math.min(height, riverHeight);\n                    }\n\n                    heightmap[z * (TERRAIN_SEGMENTS + 1) + x] = height;\n                }\n            }\n\n            return heightmap;\n        }\n\n        // Get height at world position (bilinear interpolation)\n        function getHeightAt(worldX, worldZ) {\n            const size = TERRAIN_SIZE / 2;\n            const segSize = TERRAIN_SIZE / TERRAIN_SEGMENTS;\n            const x = Math.max(0, Math.min(TERRAIN_SEGMENTS, Math.floor((worldX + size) / segSize)));\n            const z = Math.max(0, Math.min(TERRAIN_SEGMENTS, Math.floor((worldZ + size) / segSize)));\n\n            const heights = [\n                heightmap[z * (TERRAIN_SEGMENTS + 1) + x],\n                heightmap[z * (TERRAIN_SEGMENTS + 1) + Math.min(x + 1, TERRAIN_SEGMENTS)],\n                heightmap[Math.min(z + 1, TERRAIN_SEGMENTS) * (TERRAIN_SEGMENTS + 1) + x],\n                heightmap[Math.min(z + 1, TERRAIN_SEGMENTS) * (TERRAIN_SEGMENTS + 1) + Math.min(x + 1, TERRAIN_SEGMENTS)]\n            ];\n\n            const fx = ((worldX + size) / segSize) - x;\n            const fz = ((worldZ + size) / segSize) - z;\n\n            const hx0 = THREE.MathUtils.lerp(heights[0], heights[1], fx);\n            const hx1 = THREE.MathUtils.lerp(heights[2], heights[3], fx);\n            return THREE.MathUtils.lerp(hx0, hx1, fz);\n        }\n\n        let heightmap; // Global for access in getHeightAt\n\n        function generateTerrain() {\n            heightmap = generateHeightmap();\n\n            const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS);\n            geometry.rotateX(-Math.PI / 2);\n\n            const vertices = geometry.attributes.position.array;\n            for (let i = 0, j = 0; j < vertices.length; i++, j += 3) {\n                const x = (i % (TERRAIN_SEGMENTS + 1)) / TERRAIN_SEGMENTS * TERRAIN_SIZE - TERRAIN_SIZE / 2;\n                const z = Math.floor(i / (TERRAIN_SEGMENTS + 1)) / TERRAIN_SEGMENTS * TERRAIN_SIZE - TERRAIN_SIZE / 2;\n                vertices[j + 2] = getHeightAt(x, z); // Use interpolated height\n            }\n            geometry.attributes.position.needsUpdate = true;\n            geometry.computeVertexNormals();\n\n            const material = new THREE.MeshLambertMaterial({ color: 0x228B22, flatShading: false });\n            terrain = new THREE.Mesh(geometry, material);\n            terrain.receiveShadow = true;\n            scene.add(terrain);\n\n            // LOD for terrain (simple: add a low-res version for distance)\n            const lowResGeometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, 32, 32);\n            lowResGeometry.rotateX(-Math.PI / 2);\n\n            const lowVertices = lowResGeometry.attributes.position.array;\n            for (let i = 0, j = 0; j < lowVertices.length; i++, j += 3) {\n                const x = (i % 33) / 32 * TERRAIN_SIZE - TERRAIN_SIZE / 2;\n                const z = Math.floor(i / 33) / 32 * TERRAIN_SIZE - TERRAIN_SIZE / 2;\n                lowVertices[j + 2] = getHeightAt(x, z);\n            }\n            lowResGeometry.attributes.position.needsUpdate = true;\n            lowResGeometry.computeVertexNormals();\n\n            const lowResMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });\n            const lowResTerrain = new THREE.Mesh(lowResGeometry, lowResMaterial);\n            lowResTerrain.position.copy(terrain.position);\n            lowResTerrain.visible = false;\n            scene.add(lowResTerrain);\n\n            // LOD group for terrain (switch based on camera distance)\n            const lod = new THREE.LOD();\n            lod.addLevel(terrain, 0);\n            lod.addLevel(lowResTerrain, 300); // Switch to low res beyond 300 units\n            lod.position.set(0, 0, 0);\n            scene.add(lod);\n            terrain = lod; // Replace terrain with LOD\n        }\n\n        function generateTrees() {\n            const treeGeometry = new THREE.CylinderGeometry(0.5, 1, TREE_HEIGHT, 8);\n            treeGeometry.translate(0, TREE_HEIGHT / 2, 0);\n\n            // Simple leaves: another cylinder or sphere, but keep simple\n            const leavesGeometry = new THREE.SphereGeometry(3, 8, 6);\n            leavesGeometry.translate(0, TREE_HEIGHT + 2, 0);\n\n            const treeMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });\n            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });\n\n            const instancedTrees = new THREE.Group();\n            const trunk = new THREE.Mesh(treeGeometry, treeMaterial);\n            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);\n\n            const matrix = new THREE.Matrix4();\n            for (let i = 0; i < TREE_COUNT; i++) {\n                const tree = new THREE.Group();\n                tree.add(trunk.clone());\n                tree.add(leaves.clone());\n\n                const x = (Math.random() - 0.5) * TERRAIN_SIZE * 0.8;\n                const z = (Math.random() - 0.5) * TERRAIN_SIZE * 0.8;\n                const y = getHeightAt(x, z) + TREE_HEIGHT / 2;\n\n                tree.position.set(x, y, z);\n\n                // Avoid rivers (height low)\n                if (y > -5) {\n                    instancedTrees.add(tree);\n                }\n            }\n\n            // For LOD on trees: simple distance culling (hide if far)\n            instancedTrees.userData.lodDistance = 200;\n            scene.add(instancedTrees);\n            trees = instancedTrees;\n        }\n\n        // Keyboard controls\n        function onKeyDown(event) {\n            keys[event.code] = true;\n            if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') isBoosting = true;\n        }\n\n        function onKeyUp(event) {\n            keys[event.code] = false;\n            if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') isBoosting = false;\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        // Update drone\n        function updateDrone() {\n            // Speed\n            currentSpeed = isBoosting ? BOOST_SPEED : DRONE_SPEED;\n\n            // Input handling\n            const forward = new THREE.Vector3(0, 0, -1).applyEuler(droneEuler);\n            const right = new THREE.Vector3(1, 0, 0).applyEuler(droneEuler);\n            const up = new THREE.Vector3(0, 1, 0).applyEuler(droneEuler);\n\n            if (keys['KeyW']) droneEuler.x -= SENSITIVITY; // Pitch up\n            if (keys['KeyS']) droneEuler.x += SENSITIVITY; // Pitch down\n            if (keys['KeyA']) droneEuler.z += SENSITIVITY; // Roll left\n            if (keys['KeyD']) droneEuler.z -= SENSITIVITY; // Roll right\n            if (keys['KeyQ']) droneEuler.y += SENSITIVITY; // Yaw left\n            if (keys['KeyE']) droneEuler.y -= SENSITIVITY; // Yaw right\n\n            // Movement\n            if (keys['ArrowUp']) droneVelocity.add(forward.clone().multiplyScalar(currentSpeed));\n            if (keys['ArrowDown']) droneVelocity.add(forward.clone().multiplyScalar(-currentSpeed * 0.5));\n            if (keys['ArrowLeft']) droneVelocity.add(right.clone().multiplyScalar(-currentSpeed * 0.5));\n            if (keys['ArrowRight']) droneVelocity.add(right.clone().multiplyScalar(currentSpeed * 0.5));\n            if (keys['Space']) droneVelocity.add(up.clone().multiplyScalar(currentSpeed * 0.5));\n            if (keys['ShiftLeft'] && !isBoosting) droneVelocity.add(up.clone().multiplyScalar(-currentSpeed * 0.5)); // Use Shift for down if not boosting\n\n            // Apply velocity to position\n            dronePosition.add(droneVelocity);\n            droneVelocity.multiplyScalar(0.9); // Damping\n\n            // Collision avoidance: sample height below drone\n            const checkPos = dronePosition.clone();\n            checkPos.y = 0; // Project to ground plane\n            const terrainHeight = getHeightAt(checkPos.x, checkPos.z);\n            const clearance = 20; // Min height above terrain\n            if (dronePosition.y < terrainHeight + clearance) {\n                dronePosition.y = terrainHeight + clearance;\n                droneVelocity.y = 0; // Stop downward velocity\n            }\n\n            // Limit pitch/roll\n            droneEuler.x = THREE.MathUtils.clamp(droneEuler.x, -Math.PI/2, Math.PI/2);\n            droneEuler.z = THREE.MathUtils.clamp(droneEuler.z, -Math.PI/4, Math.PI/4);\n\n            // Update camera\n            camera.position.copy(dronePosition);\n            camera.quaternion.setFromEuler(droneEuler);\n\n            // LOD updates\n            if (terrain) {\n                terrain.update(camera);\n            }\n            if (trees) {\n                const dist = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));\n                trees.visible = dist < trees.userData.lodDistance;\n            }\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            updateDrone();\n            renderer.render(scene, camera);\n        }\n\n        init();\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 29.273921966552734,
    "status": "success",
    "timestamp": "2025-09-23 17:26:01"
  },
  {
    "test_name": "product_configurator",
    "prompt": "Create a complete HTML file with Three.js that implements a 3D product configurator. Create a 3D model (like a car, chair, or phone) with color, material, texture, and part toggles. Add environment reflections, soft shadows, and camera bookmarks. Include export current config as JSON and PNG snapshot functionality. The HTML file should be self-contained with Three.js loaded from CDN and include all 3D models as procedural geometry. Save the output as 'product_configurator.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Chair Configurator</title>\n    <style>\n        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }\n        #ui {\n            position: absolute; top: 10px; left: 10px; width: 280px; background: rgba(255, 255, 255, 0.9);\n            color: black; padding: 15px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n            z-index: 100; overflow-y: auto; max-height: calc(100vh - 20px);\n        }\n        button { display: block; width: 100%; margin: 5px 0; padding: 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }\n        button:hover { background: #e0e0e0; }\n        label { display: block; margin: 8px 0; }\n        input[type=\"color\"], select { margin-left: 10px; padding: 2px; }\n        h2 { margin-top: 0; }\n        h3 { margin: 15px 0 10px 0; font-size: 14px; }\n        div > div { border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px; }\n    </style>\n</head>\n<body>\n    <div id=\"ui\">\n        <h2>Chair Configurator</h2>\n        <div>\n            <h3>Parts</h3>\n            <button id=\"toggle-legs\">Legs <span id=\"legs-vis\">On</span></button>\n            <button id=\"toggle-seat\">Seat <span id=\"seat-vis\">On</span></button>\n            <button id=\"toggle-back\">Back <span id=\"back-vis\">On</span></button>\n        </div>\n        <div>\n            <h3>Legs</h3>\n            <label>Color: <input type=\"color\" id=\"legs-color\" value=\"#8B4513\"></label>\n            <label>Material: <select id=\"legs-material\">\n                <option value=\"lambert\" selected>Lambert</option>\n                <option value=\"phong\">Phong</option>\n                <option value=\"standard\">Standard</option>\n            </select></label>\n            <label>Texture: <select id=\"legs-texture\">\n                <option value=\"none\" selected>None</option>\n                <option value=\"checker\">Checker</option>\n                <option value=\"wood\">Wood</option>\n            </select></label>\n        </div>\n        <div>\n            <h3>Seat</h3>\n            <label>Color: <input type=\"color\" id=\"seat-color\" value=\"#A0522D\"></label>\n            <label>Material: <select id=\"seat-material\">\n                <option value=\"lambert\">Lambert</option>\n                <option value=\"phong\" selected>Phong</option>\n                <option value=\"standard\">Standard</option>\n            </select></label>\n            <label>Texture: <select id=\"seat-texture\">\n                <option value=\"none\" selected>None</option>\n                <option value=\"checker\">Checker</option>\n                <option value=\"wood\">Wood</option>\n            </select></label>\n        </div>\n        <div>\n            <h3>Backrest</h3>\n            <label>Color: <input type=\"color\" id=\"back-color\" value=\"#CD853F\"></label>\n            <label>Material: <select id=\"back-material\">\n                <option value=\"lambert\">Lambert</option>\n                <option value=\"phong\">Phong</option>\n                <option value=\"standard\" selected>Standard</option>\n            </select></label>\n            <label>Texture: <select id=\"back-texture\">\n                <option value=\"none\" selected>None</option>\n                <option value=\"checker\">Checker</option>\n                <option value=\"wood\">Wood</option>\n            </select></label>\n        </div>\n        <div>\n            <h3>Views</h3>\n            <button id=\"view-front\">Front</button>\n            <button id=\"view-side\">Side</button>\n            <button id=\"view-top\">Top</button>\n            <button id=\"view-iso\">Iso</button>\n        </div>\n        <div>\n            <h3>Export</h3>\n            <button id=\"export-json\">Export Config JSON</button>\n            <button id=\"take-snapshot\">Take PNG Snapshot</button>\n        </div>\n    </div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js\"></script>\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0xbfd1e5);\n\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.position.set(0, 0.3, 1.5);\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderer.domElement);\n\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n        controls.target.set(0, 0.2, 0);\n        controls.update();\n\n        // Lighting\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);\n        scene.add(ambientLight);\n\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n        directionalLight.position.set(5, 5, 5);\n        directionalLight.castShadow = true;\n        directionalLight.shadow.mapSize.width = 2048;\n        directionalLight.shadow.mapSize.height = 2048;\n        directionalLight.shadow.camera.near = 0.1;\n        directionalLight.shadow.camera.far = 50;\n        directionalLight.shadow.camera.left = -5;\n        directionalLight.shadow.camera.right = 5;\n        directionalLight.shadow.camera.top = 5;\n        directionalLight.shadow.camera.bottom = -5;\n        scene.add(directionalLight);\n\n        // Ground\n        const groundGeometry = new THREE.PlaneGeometry(10, 10);\n        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });\n        const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n        ground.rotation.x = -Math.PI / 2;\n        ground.position.y = -0.3;\n        ground.receiveShadow = true;\n        scene.add(ground);\n\n        // Chair model\n        const chairGroup = new THREE.Group();\n        const parts = {};\n\n        // Legs\n        parts.legs = [];\n        const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4);\n        const legPositions = [\n            [-0.15, -0.2, -0.15],\n            [0.15, -0.2, -0.15],\n            [-0.15, -0.2, 0.15],\n            [0.15, -0.2, 0.15]\n        ];\n        legPositions.forEach(pos => {\n            const leg = new THREE.Mesh(legGeometry, null);\n            leg.position.set(...pos);\n            leg.castShadow = true;\n            leg.receiveShadow = true;\n            parts.legs.push(leg);\n            chairGroup.add(leg);\n        });\n\n        // Seat\n        const seatGeometry = new THREE.BoxGeometry(0.3, 0.05, 0.3);\n        parts.seat = new THREE.Mesh(seatGeometry, null);\n        parts.seat.position.set(0, 0, 0);\n        parts.seat.castShadow = true;\n        parts.seat.receiveShadow = true;\n        chairGroup.add(parts.seat);\n\n        // Backrest\n        const backGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.05);\n        parts.back = new THREE.Mesh(backGeometry, null);\n        parts.back.position.set(0, 0.2, 0.175);\n        parts.back.castShadow = true;\n        parts.back.receiveShadow = true;\n        chairGroup.add(parts.back);\n\n        scene.add(chairGroup);\n\n        // Config\n        const config = {\n            parts: { legs: true, seat: true, back: true },\n            colors: { legs: '#8B4513', seat: '#A0522D', back: '#CD853F' },\n            materials: { legs: 'lambert', seat: 'phong', back: 'standard' },\n            textures: { legs: 'none', seat: 'none', back: 'none' }\n        };\n\n        const materialInstances = {}; // Shared materials per part\n\n        // Texture generator\n        function getTexture(type, color) {\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            let tex;\n\n            if (type === 'checker') {\n                canvas.width = canvas.height = 256;\n                const darkColor = color.clone().multiplyScalar(0.7);\n                for (let x = 0; x < 256; x += 64) {\n                    for (let y = 0; y < 256; y += 64) {\n                        const isDark = ((Math.floor(x / 64) + Math.floor(y / 64)) % 2 === 0);\n                        ctx.fillStyle = isDark ? '#' + darkColor.getHexString() : '#' + color.getHexString();\n                        ctx.fillRect(x, y, 64, 64);\n                    }\n                }\n                tex = new THREE.CanvasTexture(canvas);\n                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\n                tex.repeat.set(4, 4);\n            } else if (type === 'wood') {\n                canvas.width = 512;\n                canvas.height = 256;\n                const darkColor = color.clone().multiplyScalar(0.6);\n                ctx.fillStyle = '#' + darkColor.getHexString();\n                ctx.fillRect(0, 0, 512, 256);\n                ctx.strokeStyle = '#' + color.getHexString();\n                ctx.lineWidth = 3;\n                for (let i = 0; i < 20; i++) {\n                    const y = (i * 13) % 256;\n                    ctx.beginPath();\n                    ctx.moveTo(0, y);\n                    let wave = 0;\n                    for (let x = 0; x < 512; x += 4) {\n                        wave += 0.3;\n                        const dy = Math.sin(wave) * 8;\n                        ctx.lineTo(x, y + dy);\n                    }\n                    ctx.stroke();\n                }\n                tex = new THREE.CanvasTexture(canvas);\n                tex.wrapS = THREE.RepeatWrapping;\n                tex.wrapT = THREE.MirroredRepeatWrapping;\n                tex.repeat.set(2, 1);\n            } else {\n                return null;\n            }\n            return tex;\n        }\n\n        // Update part\n        function updatePart(part) {\n            const color = new THREE.Color(config.colors[part]);\n            const type = config.materials[part];\n            const texType = config.textures[part];\n            const matClass = type === 'lambert' ? THREE.MeshLambertMaterial :\n                             type === 'phong' ? THREE.MeshPhongMaterial :\n                             THREE.MeshStandardMaterial;\n            const opts = { color: color };\n            if (texType !== 'none') {\n                opts.map = getTexture(texType, color);\n                opts.color.setHex(0xffffff);\n            }\n            if (type === 'standard') {\n                opts.envMapIntensity = 1.0;\n            }\n            const newMat = new matClass(opts);\n            materialInstances[part] = newMat;\n\n            const meshes = Array.isArray(parts[part]) ? parts[part] : [parts[part]];\n            meshes.forEach(m => {\n                m.material = newMat;\n                m.material.needsUpdate = true;\n            });\n        }\n\n        // Init materials\n        ['legs', 'seat', 'back'].forEach(part => updatePart(part));\n\n        // Environment\n        const pmremGenerator = new THREE.PMREMGenerator(renderer);\n        pmremGenerator.compileEquirectangularShader();\n        const rgbeLoader = new THREE.RGBELoader();\n        rgbeLoader.load('https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr', (texture) => {\n            const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n            scene.background = envMap;\n            scene.environment = envMap;\n            texture.dispose();\n            pmremGenerator.dispose();\n            // Update standard materials\n            ['legs', 'seat', 'back'].forEach(part => {\n                if (config.materials[part] === 'standard') {\n                    updatePart(part);\n                }\n            });\n        });\n\n        // UI Event Listeners\n        const partNames = ['legs', 'seat', 'back'];\n        partNames.forEach(part => {\n            // Toggle\n            document.getElementById(`toggle-${part}`).addEventListener('click', () => {\n                config.parts[part] = !config.parts[part];\n                const meshes = Array.isArray(parts[part]) ? parts[part] : [parts[part]];\n                meshes.forEach(m => m.visible = config.parts[part]);\n                document.getElementById(`${part}-vis`).textContent = config.parts[part] ? 'On' : 'Off';\n            });\n\n            // Color\n            const colorInput = document.getElementById(`${part}-color`);\n            colorInput.value = config.colors[part];\n            colorInput.addEventListener('input', (e) => {\n                config.colors[part] = e.target.value;\n                updatePart(part);\n            });\n\n            // Material\n            const matSelect = document.getElementById(`${part}-material`);\n            matSelect.value = config.materials[part];\n            matSelect.addEventListener('change', (e) => {\n                config.materials[part] = e.target.value;\n                updatePart(part);\n            });\n\n            // Texture\n            const texSelect = document.getElementById(`${part}-texture`);\n            texSelect.value = config.textures[part];\n            texSelect.addEventListener('change', (e) => {\n                config.textures[part] = e.target.value;\n                updatePart(part);\n            });\n        });\n\n        // Views\n        const bookmarks = {\n            front: { pos: new THREE.Vector3(0, 0.3, 1.5), tar: new THREE.Vector3(0, 0.2, 0) },\n            side: { pos: new THREE.Vector3(1.5, 0.5, 0), tar: new THREE.Vector3(0, 0.2, 0) },\n            top: { pos: new THREE.Vector3(0, 2, 0), tar: new THREE.Vector3(0, 0.2, 0) },\n            iso: { pos: new THREE.Vector3(1, 0.5, 1), tar: new THREE.Vector3(0, 0.2, 0) }\n        };\n        ['front', 'side', 'top', 'iso'].forEach(view => {\n            document.getElementById(`view-${view}`).addEventListener('click', () => {\n                const b = bookmarks[view];\n                camera.position.copy(b.pos);\n                controls.target.copy(b.tar);\n                controls.update();\n            });\n        });\n\n        // Export\n        document.getElementById('export-json').addEventListener('click', () => {\n            const jsonStr = JSON.stringify(config, null, 2);\n            const blob = new Blob([jsonStr], { type: 'application/json' });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = 'chair-config.json';\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n        });\n\n        document.getElementById('take-snapshot').addEventListener('click', () => {\n            const dataUrl = renderer.domElement.toDataURL('image/png');\n            const a = document.createElement('a');\n            a.href = dataUrl;\n            a.download = 'chair-snapshot.png';\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n        });\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            controls.update();\n            renderer.render(scene, camera);\n        }\n        animate();\n\n        // Resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 87.89184498786926,
    "status": "success",
    "timestamp": "2025-09-23 17:27:29"
  },
  {
    "test_name": "webxr_art_gallery",
    "prompt": "Create a complete HTML file with Three.js and WebXR that builds a VR gallery with teleport navigation, hand/controller rays to select artworks, modal info panels, spatial audio, baked/lightmapped room, and performance budget for stable frame rate. Include fallback for non-VR devices with mouse controls. The HTML file should be self-contained with Three.js and WebXR libraries loaded from CDN. Save the output as 'webxr_gallery.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>VR Art Gallery</title>\n    <style>\n        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }\n        canvas { display: block; }\n        #info-panel {\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            background: rgba(0, 0, 0, 0.8);\n            color: white;\n            padding: 20px;\n            border-radius: 10px;\n            max-width: 300px;\n            z-index: 100;\n            display: none;\n        }\n        #close-info { position: absolute; top: 5px; right: 10px; cursor: pointer; }\n        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; z-index: 200; }\n    </style>\n</head>\n<body>\n    <div id=\"loading\">Loading Gallery...</div>\n    <div id=\"info-panel\">\n        <span id=\"close-info\" onclick=\"document.getElementById('info-panel').style.display='none';\">&times;</span>\n        <h2 id=\"art-title\"></h2>\n        <p id=\"art-description\"></p>\n    </div>\n\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.158.0/build/three.module.js?module\",\n                \"three/addons/\": \"https://unpkg.com/three@0.158.0/examples/jsm/\"\n            }\n        }\n    </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { VRButton } from 'three/addons/webxr/VRButton.js';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';\n        import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';\n\n        let container, renderer, scene, camera, dolly;\n        let controls = null;\n        let raycaster, intersectedObject = null;\n        let artworks = [];\n        let artInfos = [\n            { title: 'Abstract Blue', description: 'A vibrant abstract painting in blue tones representing the ocean depths.' },\n            { title: 'Red Sunset', description: 'A serene sunset over mountains, capturing the warmth of the evening sky.' },\n            { title: 'Green Forest', description: 'A lush forest scene with detailed foliage and sunlight filtering through trees.' },\n            { title: 'Yellow Fields', description: 'Vast fields of golden wheat under a bright sun, evoking rural tranquility.' }\n        ];\n        let audioListener, sounds = [];\n        let controller1, controller2, controllerGrip1, controllerGrip2;\n        let line1, line2, teleportLine;\n        let floorIntersects = [];\n        let isTeleporting = false;\n        let teleportDirection = new THREE.Vector3();\n        let teleportPosition = new THREE.Vector3();\n\n        init();\n        animate();\n\n        function init() {\n            container = document.body;\n\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x505050);\n            scene.fog = new THREE.Fog(0x505050, 0, 100);\n\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);\n            camera.position.set(0, 1.6, 0); // Eye level\n\n            dolly = new THREE.Group();\n            dolly.position.set(0, 0, 10);\n            dolly.add(camera);\n            scene.add(dolly);\n\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setPixelRatio(window.devicePixelRatio);\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.outputEncoding = THREE.sRGBEncoding;\n            renderer.toneMapping = THREE.ACESFilmicToneMapping;\n            renderer.toneMappingExposure = 1;\n            renderer.xr.enabled = true;\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            container.appendChild(renderer.domElement);\n\n            // Lighting - Simulate baked lighting with ambient and directional\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\n            scene.add(ambientLight);\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(1, 1, 0);\n            directionalLight.castShadow = true;\n            directionalLight.shadow.mapSize.width = 2048;\n            directionalLight.shadow.mapSize.height = 2048;\n            scene.add(directionalLight);\n\n            // Audio setup\n            audioListener = new THREE.AudioListener();\n            camera.add(audioListener);\n\n            // Room - Simple baked-like room using textured boxes (procedural textures for self-contained)\n            createRoom();\n\n            // Artworks\n            createArtworks();\n\n            // Spatial Audio - Generate simple tones for each artwork\n            createSpatialAudio();\n\n            // Raycaster for selection\n            raycaster = new THREE.Raycaster();\n\n            // Controllers for VR\n            setupControllers();\n\n            // VR Button\n            const button = VRButton.createButton(renderer);\n            if (button) {\n                document.body.appendChild(button);\n            }\n\n            // Fallback for non-VR (desktop mouse controls)\n            if (!navigator.xr) {\n                controls = new OrbitControls(camera, renderer.domElement);\n                controls.target.set(0, 1.6, 0);\n                controls.update();\n                setupMouseControls();\n                document.getElementById('loading').style.display = 'none';\n            } else {\n                document.getElementById('loading').style.display = 'none';\n            }\n\n            window.addEventListener('resize', onWindowResize);\n        }\n\n        function createRoom() {\n            const roomSize = 20;\n            const roomHeight = 5;\n\n            // Floor\n            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);\n            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa }); // Simulate baked floor\n            const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n            floor.rotation.x = -Math.PI / 2;\n            floor.receiveShadow = true;\n            scene.add(floor);\n\n            // Walls - Simple colored for baked look\n            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xdddddd });\n            const wallGeometry = new THREE.PlaneGeometry(roomSize, roomHeight);\n\n            // Back wall\n            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);\n            backWall.position.set(0, roomHeight / 2, -roomSize / 2);\n            scene.add(backWall);\n\n            // Side walls\n            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);\n            leftWall.rotation.y = Math.PI / 2;\n            leftWall.position.set(-roomSize / 2, roomHeight / 2, 0);\n            scene.add(leftWall);\n\n            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);\n            rightWall.rotation.y = -Math.PI / 2;\n            rightWall.position.set(roomSize / 2, roomHeight / 2, 0);\n            scene.add(rightWall);\n\n            // Ceiling\n            const ceilingGeometry = new THREE.PlaneGeometry(roomSize, roomSize);\n            const ceiling = new THREE.Mesh(ceilingGeometry, wallMaterial);\n            ceiling.rotation.x = Math.PI / 2;\n            ceiling.position.set(0, roomHeight, 0);\n            scene.add(ceiling);\n        }\n\n        function createArtworks() {\n            const artPositions = [\n                { x: -4, z: -4 },\n                { x: 4, z: -4 },\n                { x: -4, z: 4 },\n                { x: 4, z: 4 }\n            ];\n\n            artPositions.forEach((pos, index) => {\n                // Create simple \"art\" as colored planes (procedural for self-contained)\n                const canvas = document.createElement('canvas');\n                canvas.width = 256;\n                canvas.height = 256;\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = `hsl(${index * 90}, 70%, 50%)`;\n                ctx.fillRect(0, 0, 256, 256);\n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 20px Arial';\n                ctx.fillText(artInfos[index].title, 80, 130);\n                const texture = new THREE.CanvasTexture(canvas);\n\n                const artGeometry = new THREE.PlaneGeometry(2, 2);\n                const artMaterial = new THREE.MeshLambertMaterial({ map: texture });\n                const art = new THREE.Mesh(artGeometry, artMaterial);\n                art.position.set(pos.x, 2, pos.z);\n                art.lookAt(0, 2, 0); // Face center\n                art.userData = { index };\n                scene.add(art);\n                artworks.push(art);\n            });\n        }\n\n        function createSpatialAudio() {\n            // Generate a simple tone buffer using Web Audio API\n            function generateTone(frequency, duration) {\n                const sampleRate = 44100;\n                const bufferSize = sampleRate * duration;\n                const offlineContext = new OfflineAudioContext(1, bufferSize, sampleRate);\n                const oscillator = offlineContext.createOscillator();\n                oscillator.frequency.setValueAtTime(frequency, 0);\n                oscillator.connect(offlineContext.destination);\n                oscillator.start(0);\n                oscillator.stop(duration);\n                return offlineContext.startRendering();\n            }\n\n            Promise.all(artInfos.map((_, index) => generateTone(200 + index * 100, 2))).then(buffers => {\n                buffers.forEach((buffer, index) => {\n                    const sound = new THREE.PositionalAudio(audioListener);\n                    sound.setBuffer(buffer);\n                    sound.setRefDistance(5);\n                    sound.setDirectionalCone(180, 230, 0.1);\n                    artworks[index].add(sound);\n                    sounds.push(sound);\n                    // Play on hover/select, but for demo, play once on load with delay\n                    setTimeout(() => sound.play(), index * 1000);\n                });\n            });\n        }\n\n        function setupControllers() {\n            controller1 = renderer.xr.getController(0); // Left - Select\n            controller1.addEventListener('selectstart', onSelectStart);\n            controller1.addEventListener('selectend', onSelectEnd);\n            scene.add(controller1);\n\n            controller2 = renderer.xr.getController(1); // Right - Teleport\n            controller2.addEventListener('selectstart', onTeleportStart);\n            controller2.addEventListener('selectend', onTeleportEnd);\n            scene.add(controller2);\n\n            // Grips for models\n            controllerGrip1 = renderer.xr.getControllerGrip(0);\n            controllerGrip2 = renderer.xr.getControllerGrip(1);\n            const controllerModelFactory = new XRControllerModelFactory();\n\n            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));\n            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));\n            scene.add(controllerGrip1);\n            scene.add(controllerGrip2);\n\n            // Selection ray (laser) for left controller\n            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);\n            const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });\n            line1 = new THREE.Line(geometry, material);\n            controller1.add(line1.clone());\n\n            // Teleport ray for right controller (blue)\n            const teleportMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });\n            teleportLine = new THREE.Line(geometry, teleportMaterial);\n            controller2.add(teleportLine.clone());\n        }\n\n        function onSelectStart(event) {\n            const controller = event.target;\n            if (controller === controller1) {\n                selectArtwork();\n            }\n        }\n\n        function onSelectEnd() {\n            // End selection if needed\n        }\n\n        function onTeleportStart(event) {\n            const controller = event.target;\n            if (controller === controller2) {\n                performTeleport();\n            }\n        }\n\n        function onTeleportEnd() {}\n\n        function selectArtwork() {\n            const tempMatrix = new THREE.Matrix4();\n            controller1.updateMatrixWorld();\n            tempMatrix.extractRotation(controller1.matrixWorld);\n            raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);\n            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n\n            const intersects = raycaster.intersectObjects(artworks);\n            if (intersects.length > 0) {\n                const selectedArt = intersects[0].object;\n                showInfoPanel(selectedArt.userData.index);\n                // Play sound\n                if (sounds[selectedArt.userData.index]) {\n                    sounds[selectedArt.userData.index].play();\n                }\n            }\n        }\n\n        function performTeleport() {\n            if (isTeleporting) return;\n\n            const tempMatrix = new THREE.Matrix4();\n            controller2.updateMatrixWorld();\n            tempMatrix.extractRotation(controller2.matrixWorld);\n            raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);\n            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n\n            // Raycast to floor (y=0 plane)\n            raycaster.ray.origin.y = 1.6; // Controller height\n            raycaster.ray.direction.y = -1;\n            const distanceToFloor = (1.6 - 0) / 1;\n            const floorPos = raycaster.ray.origin.clone().add(raycaster.ray.direction.clone().multiplyScalar(distanceToFloor));\n\n            // Limit teleport distance\n            const teleportDist = 5;\n            if (floorPos.distanceTo(camera.position) > teleportDist) return;\n\n            teleportPosition.copy(floorPos);\n            teleportPosition.y = 0;\n            dolly.position.copy(teleportPosition);\n            camera.position.set(0, 1.6, 0); // Reset camera relative to dolly\n        }\n\n        function showInfoPanel(index) {\n            document.getElementById('art-title').textContent = artInfos[index].title;\n            document.getElementById('art-description').textContent = artInfos[index].description;\n            document.getElementById('info-panel').style.display = 'block';\n        }\n\n        function setupMouseControls() {\n            const mouse = new THREE.Vector2();\n            window.addEventListener('click', onMouseClick);\n\n            function onMouseClick(event) {\n                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n                raycaster.setFromCamera(mouse, camera);\n                const intersects = raycaster.intersectObjects(artworks);\n                if (intersects.length > 0) {\n                    const selectedArt = intersects[0].object;\n                    showInfoPanel(selectedArt.userData.index);\n                }\n            }\n        }\n\n        function animate() {\n            renderer.setAnimationLoop(render);\n        }\n\n        function render() {\n            if (controls) controls.update();\n\n            // Update rays in VR\n            if (renderer.xr.isPresenting) {\n                // Selection ray update\n                const positions1 = line1.geometry.attributes.position;\n                positions1.array[3] = positions1.array[0]; // x\n                positions1.array[4] = positions1.array[1]; // y\n                positions1.array[5] = positions1.array[2] - 5; // z\n                line1.geometry.attributes.position.needsUpdate = true;\n\n                // Teleport ray similar\n                const positions2 = teleportLine.geometry.attributes.position;\n                positions2.array[3] = positions2.array[0];\n                positions2.array[4] = positions2.array[1];\n                positions2.array[5] = positions2.array[2] - 10; // Longer for floor\n                teleportLine.geometry.attributes.position.needsUpdate = true;\n\n                // Check intersections for hover\n                if (controller1) {\n                    const tempMatrix = new THREE.Matrix4();\n                    controller1.updateMatrixWorld();\n                    tempMatrix.extractRotation(controller1.matrixWorld);\n                    raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);\n                    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n                    const intersects = raycaster.intersectObjects(artworks);\n                    if (intersects.length > 0) {\n                        if (intersectedObject !== intersects[0].object) {\n                            // Hover effect: scale up\n                            if (intersectedObject) intersectedObject.scale.set(1, 1, 1);\n                            intersectedObject = intersects[0].object;\n                            intersectedObject.scale.set(1.1, 1.1, 1.1);\n                        }\n                    } else {\n                        if (intersectedObject) {\n                            intersectedObject.scale.set(1, 1, 1);\n                            intersectedObject = null;\n                        }\n                    }\n                }\n            }\n\n            // Performance: Limit FPS if needed, but Three.js handles\n            renderer.render(scene, camera);\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            if (controls) controls.update();\n        }\n    </script>\n</body>\n</html>\n```\n\nThis is a complete, self-contained HTML file named `webxr_gallery.html`. Save the above content to a file with that name. It includes:\n\n- **Three.js and WebXR from CDN** via importmap for modules.\n- **VR Gallery Setup**: Simple room with floor/walls/ceiling using basic materials to simulate a lightmapped/baked look (procedural colors, no external textures).\n- **Teleport Navigation**: Right controller raycasts to floor and teleports on select (limited distance for performance).\n- **Hand/Controller Rays**: Left controller laser for selecting/hovering artworks (green ray), with visual feedback (scale on hover).\n- **Modal Info Panels**: 2D HTML overlay shown on selection, with title and description.\n- **Spatial Audio**: Generates simple tones using OfflineAudioContext for each artwork, positional at art locations, plays on load and select.\n- **Baked/Lightmapped Room**: Simulated with ambient + directional lights and neutral materials for a pre-lit feel; kept simple/low-poly for performance.\n- **Performance Budget**: Low-poly geometry (planes/boxes), no complex shaders, shadow maps at 2048, tone mapping for stable 60fps on modern devices. No external assets.\n- **Fallback for Non-VR**: OrbitControls for mouse navigation, raycast on click for selection.\n\nTest in a WebXR-compatible browser (e.g., Chrome with VR headset). For desktop, it falls back to mouse/orbit controls.",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 35.95480513572693,
    "status": "success",
    "timestamp": "2025-09-23 17:28:05"
  },
  {
    "test_name": "physics_playground",
    "prompt": "Create a complete HTML file with Three.js integrated with a lightweight physics engine (cannon-es or similar) that includes stackable boxes, spheres, hinge joints, ragdoll, and interactive dragging with the mouse. Add reset button, gravity slider, and slow-motion toggle. The HTML file should be self-contained with Three.js and physics engine loaded from CDN. Save the output as 'physics_playground.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Physics Playground</title>\n    <style>\n        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }\n        #container { width: 100vw; height: 100vh; }\n        #ui {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            background: rgba(0,0,0,0.5);\n            color: white;\n            padding: 10px;\n            border-radius: 5px;\n            z-index: 100;\n        }\n        #ui label { display: block; margin: 5px 0; }\n        #ui input[type=\"range\"] { width: 100px; }\n        button { margin: 5px 0; padding: 5px 10px; }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <div id=\"ui\">\n        <button id=\"reset\">Reset</button>\n        <label>Gravity: <input type=\"range\" id=\"gravity\" min=\"-20\" max=\"0\" step=\"0.1\" value=\"-9.8\"></label>\n        <span id=\"gravityValue\">-9.8</span>\n        <label>Slow Motion: <input type=\"checkbox\" id=\"slowmo\"></label>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js\"></script>\n    <script type=\"module\">\n        import * as CANNON from 'https://cdn.skypack.dev/cannon-es';\n\n        // Scene setup\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x87CEEB);\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.position.set(0, 10, 15);\n        camera.lookAt(0, 0, 0);\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.getElementById('container').appendChild(renderer.domElement);\n\n        // Lights\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n        scene.add(ambientLight);\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n        directionalLight.position.set(10, 10, 5);\n        directionalLight.castShadow = true;\n        directionalLight.shadow.mapSize.width = 2048;\n        directionalLight.shadow.mapSize.height = 2048;\n        scene.add(directionalLight);\n\n        // Physics world\n        const world = new CANNON.World();\n        world.gravity.set(0, -9.82, 0);\n        world.broadphase = new CANNON.NaiveBroadphase();\n        world.solver.iterations = 10;\n\n        // Materials\n        const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });\n        const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });\n        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });\n        const ragdollMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });\n\n        // Arrays to sync\n        const meshes = [];\n        const bodies = [];\n\n        // Mouse interaction\n        const mouse = new THREE.Vector2();\n        const raycaster = new THREE.Raycaster();\n        let selectedBody = null;\n        let selectedMesh = null;\n        const dragForce = 100;\n        const dragDistance = new THREE.Vector3();\n\n        // UI\n        const gravitySlider = document.getElementById('gravity');\n        const gravityValue = document.getElementById('gravityValue');\n        const slowmoCheckbox = document.getElementById('slowmo');\n        const resetButton = document.getElementById('reset');\n\n        gravitySlider.oninput = (e) => {\n            const value = parseFloat(e.target.value);\n            world.gravity.set(0, value, 0);\n            gravityValue.textContent = value.toFixed(1);\n        };\n        slowmoCheckbox.onchange = (e) => {\n            timeScale = e.target.checked ? 0.1 : 1;\n        };\n        resetButton.onclick = resetScene;\n\n        // Event listeners for mouse\n        renderer.domElement.addEventListener('mousedown', onMouseDown);\n        renderer.domElement.addEventListener('mousemove', onMouseMove);\n        renderer.domElement.addEventListener('mouseup', onMouseUp);\n        window.addEventListener('resize', onWindowResize);\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function onMouseDown(event) {\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n            raycaster.setFromCamera(mouse, camera);\n            const intersects = raycaster.intersectObjects(meshes.filter(m => m.userData.body.mass > 0)); // Only dynamic bodies\n\n            if (intersects.length > 0) {\n                selectedMesh = intersects[0].object;\n                selectedBody = selectedMesh.userData.body;\n                renderer.domElement.style.cursor = 'grabbing';\n            }\n        }\n\n        function onMouseMove(event) {\n            if (selectedBody) {\n                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n                raycaster.setFromCamera(mouse, camera);\n\n                // Intersect with a horizontal plane at the body's y position for dragging\n                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -selectedBody.position.y);\n                const intersectPoint = new THREE.Vector3();\n                raycaster.ray.intersectPlane(plane, intersectPoint);\n\n                if (intersectPoint) {\n                    dragDistance.copy(intersectPoint).sub(selectedBody.position);\n                    const force = dragDistance.normalize().multiplyScalar(dragForce);\n                    selectedBody.applyForce(new CANNON.Vec3(force.x, force.y, force.z), selectedBody.position);\n                }\n            } else {\n                // Update mouse for potential hover, but skip for simplicity\n            }\n        }\n\n        function onMouseUp() {\n            selectedBody = null;\n            selectedMesh = null;\n            renderer.domElement.style.cursor = 'default';\n        }\n\n        // Create ground\n        function createGround() {\n            const groundShape = new CANNON.Plane();\n            const groundBody = new CANNON.Body({ mass: 0 });\n            groundBody.addShape(groundShape);\n            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);\n            world.addBody(groundBody);\n\n            const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), groundMaterial);\n            groundMesh.rotation.x = -Math.PI / 2;\n            groundMesh.receiveShadow = true;\n            scene.add(groundMesh);\n            meshes.push(groundMesh);\n            groundMesh.userData.body = groundBody; // Even static\n        }\n\n        // Create box\n        function createBox(size, position, material = boxMaterial, mass = 1) {\n            const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));\n            const body = new CANNON.Body({ mass });\n            body.addShape(shape);\n            body.position.set(position.x, position.y, position.z);\n            world.addBody(body);\n            bodies.push(body);\n\n            const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);\n            const mesh = new THREE.Mesh(geometry, material);\n            mesh.position.copy(body.position);\n            mesh.castShadow = true;\n            scene.add(mesh);\n            meshes.push(mesh);\n            mesh.userData.body = body;\n            return { body, mesh };\n        }\n\n        // Create sphere\n        function createSphere(radius, position, material = sphereMaterial, mass = 1) {\n            const shape = new CANNON.Sphere(radius);\n            const body = new CANNON.Body({ mass });\n            body.addShape(shape);\n            body.position.set(position.x, position.y, position.z);\n            world.addBody(body);\n            bodies.push(body);\n\n            const geometry = new THREE.SphereGeometry(radius);\n            const mesh = new THREE.Mesh(geometry, material);\n            mesh.position.copy(body.position);\n            mesh.castShadow = true;\n            scene.add(mesh);\n            meshes.push(mesh);\n            mesh.userData.body = body;\n            return { body, mesh };\n        }\n\n        // Create hinge constraint\n        function createHinge(bodyA, pivotA, bodyB, pivotB, axis = new CANNON.Vec3(0, 1, 0)) {\n            const constraint = new CANNON.HingeConstraint(bodyA, pivotA, bodyB, pivotB, axis);\n            world.addConstraint(constraint);\n            return constraint;\n        }\n\n        // Create simple ragdoll\n        function createRagdoll(x = -5, y = 1) {\n            // Torso\n            const torso = createBox({x: 1, y: 2, z: 0.5}, {x, y: y+1, z: 0}, ragdollMaterial, 1);\n            torso.mesh.name = 'torso';\n\n            // Head\n            const head = createSphere(0.5, {x, y: y+3, z: 0}, ragdollMaterial, 0.5);\n            head.mesh.name = 'head';\n            // Hinge head to torso top\n            createHinge(torso.body, new CANNON.Vec3(0, 1, 0), head.body, new CANNON.Vec3(0, -0.5, 0), new CANNON.Vec3(1, 0, 0));\n\n            // Left arm\n            const leftArm = createBox({x: 0.5, y: 2, z: 0.2}, {x: x-1.25, y: y+2, z: 0}, ragdollMaterial, 0.3);\n            leftArm.mesh.name = 'leftArm';\n            createHinge(torso.body, new CANNON.Vec3(-0.5, 0, 0), leftArm.body, new CANNON.Vec3(0.25, 0, 0), new CANNON.Vec3(0, 0, 1));\n\n            // Right arm\n            const rightArm = createBox({x: 0.5, y: 2, z: 0.2}, {x: x+1.25, y: y+2, z: 0}, ragdollMaterial, 0.3);\n            rightArm.mesh.name = 'rightArm';\n            createHinge(torso.body, new CANNON.Vec3(0.5, 0, 0), rightArm.body, new CANNON.Vec3(-0.25, 0, 0), new CANNON.Vec3(0, 0, 1));\n\n            // Left leg\n            const leftLeg = createBox({x: 0.5, y: 2, z: 0.2}, {x: x-0.25, y, z: 0}, ragdollMaterial, 0.5);\n            leftLeg.mesh.name = 'leftLeg';\n            createHinge(torso.body, new CANNON.Vec3(-0.25, -1, 0), leftLeg.body, new CANNON.Vec3(0.25, 1, 0), new CANNON.Vec3(0, 0, 1));\n\n            // Right leg\n            const rightLeg = createBox({x: 0.5, y: 2, z: 0.2}, {x: x+0.25, y, z: 0}, ragdollMaterial, 0.5);\n            rightLeg.mesh.name = 'rightLeg';\n            createHinge(torso.body, new CANNON.Vec3(0.25, -1, 0), rightLeg.body, new CANNON.Vec3(-0.25, 1, 0), new CANNON.Vec3(0, 0, 1));\n\n            return { torso, head, leftArm, rightArm, leftLeg, rightLeg };\n        }\n\n        // Initial scene setup\n        function initScene() {\n            createGround();\n\n            // Stackable boxes\n            for (let i = 0; i < 5; i++) {\n                createBox({x:1, y:1, z:1}, {x: 0, y: (i + 1), z: 0});\n            }\n\n            // Spheres\n            createSphere(0.5, {x: 3, y: 5, z: 0});\n            createSphere(0.5, {x: 4, y: 4, z: 2});\n            createSphere(0.5, {x: 2, y: 3, z: -1});\n\n            // Hinge joint example: two boxes connected\n            const box1 = createBox({x:1, y:1, z:1}, {x: 5, y: 2, z: -0.5}, boxMaterial, 1);\n            const box2 = createBox({x:1, y:1, z:1}, {x: 5, y: 2, z: 0.5}, boxMaterial, 1);\n            createHinge(box1.body, new CANNON.Vec3(0.5, 0, 0), box2.body, new CANNON.Vec3(-0.5, 0, 0), new CANNON.Vec3(0, 1, 0));\n\n            // Ragdoll\n            createRagdoll(-5, 0.5);\n        }\n\n        // Reset function\n        function resetScene() {\n            // Remove all dynamic bodies and meshes\n            bodies.forEach(body => world.removeBody(body));\n            meshes.forEach(mesh => scene.remove(mesh));\n            bodies.length = 0;\n            meshes.length = 0;\n\n            // Recreate ground and initial objects\n            initScene();\n        }\n\n        // Animation\n        const clock = new THREE.Clock();\n        let timeScale = 1;\n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            const delta = clock.getDelta();\n            world.step(1 / 60, delta * timeScale, 3);\n\n            // Sync meshes to bodies\n            meshes.forEach((mesh, index) => {\n                if (mesh.userData.body) {\n                    mesh.position.copy(mesh.userData.body.position);\n                    mesh.quaternion.copy(mesh.userData.body.quaternion);\n                }\n            });\n\n            renderer.render(scene, camera);\n        }\n\n        // Initialize\n        initScene();\n        animate();\n    </script>\n</body>\n</html>\n```\n\nThis is the complete content for `physics_playground.html`. Save it as a file with that name and open in a browser. It includes:\n\n- **Stackable boxes**: Initial stack of 5 boxes that can be dragged and restack.\n- **Spheres**: A few rolling spheres.\n- **Hinge joints**: Two boxes connected by a hinge at x=5.\n- **Ragdoll**: Simple ragdoll with torso, head, arms, and legs connected by hinges at x=-5.\n- **Interactive dragging**: Click and drag dynamic objects (boxes, spheres, ragdoll parts) with the mouse; applies force to simulate dragging.\n- **Reset button**: Clears and recreates the initial scene.\n- **Gravity slider**: Adjusts gravity from -20 to 0.\n- **Slow-motion toggle**: Slows down the simulation by 10x when checked.\n\nThe file is self-contained, loading Three.js and cannon-es from CDNs. No additional files needed.",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 31.02366018295288,
    "status": "success",
    "timestamp": "2025-09-23 17:28:36"
  },
  {
    "test_name": "data_driven_dashboard",
    "prompt": "Create a complete HTML file with Three.js that creates a 3D analytics scene turning a random dataset into bars, scatter points, and ribbons on a 3D grid. Include axis helpers, tooltips on hover, camera tween to views, theme toggle (dark/light), and CSV export of generated data. The HTML file should be self-contained with Three.js loaded from CDN and include sample data generation. Save the output as 'data_dashboard.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>3D Data Dashboard</title>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            font-family: Arial, sans-serif;\n        }\n        #ui {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            z-index: 100;\n            background: rgba(0, 0, 0, 0.5);\n            padding: 10px;\n            border-radius: 5px;\n            color: white;\n        }\n        button {\n            margin: 5px;\n            padding: 8px 12px;\n            border: none;\n            border-radius: 3px;\n            cursor: pointer;\n            background: #333;\n            color: white;\n        }\n        button:hover {\n            background: #555;\n        }\n        #tooltip {\n            position: absolute;\n            background: rgba(0, 0, 0, 0.8);\n            color: white;\n            padding: 8px;\n            border-radius: 4px;\n            pointer-events: none;\n            display: none;\n            z-index: 200;\n            font-size: 12px;\n        }\n    </style>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r161/three.min.js\"></script>\n    <script src=\"https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.min.js\"></script>\n</head>\n<body>\n    <div id=\"ui\">\n        <button id=\"toggleTheme\">Toggle Theme</button>\n        <button id=\"exportCSV\">Export CSV</button>\n        <button id=\"viewFront\">Front View</button>\n        <button id=\"viewTop\">Top View</button>\n        <button id=\"viewSide\">Side View</button>\n    </div>\n    <div id=\"tooltip\"></div>\n\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderer.domElement);\n\n        // Controls\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true;\n        controls.dampingFactor = 0.05;\n\n        // Lights\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\n        scene.add(ambientLight);\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n        directionalLight.position.set(10, 10, 5);\n        directionalLight.castShadow = true;\n        scene.add(directionalLight);\n\n        // Grid and axes\n        const grid = new THREE.GridHelper(20, 20);\n        scene.add(grid);\n        const axes = new THREE.AxesHelper(10);\n        scene.add(axes);\n\n        // Generate sample data on grid\n        const data = [];\n        const size = 8;\n        const step = 5;\n        for (let i = 0; i < size; i++) {\n            for (let j = 0; j < size; j++) {\n                const x = (i - size / 2 + 0.5) * step;\n                const y = (j - size / 2 + 0.5) * step;\n                const z = Math.random() * 10 + 1;\n                data.push({ x, y, z, i, j });\n            }\n        }\n\n        // Bars\n        const bars = [];\n        const barGeo = new THREE.BoxGeometry(0.8, 0.8, 1);\n        data.forEach(d => {\n            const height = d.z;\n            const material = new THREE.MeshLambertMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5) });\n            const bar = new THREE.Mesh(barGeo, material);\n            bar.position.set(d.x, d.y, height / 2);\n            bar.castShadow = true;\n            bar.receiveShadow = true;\n            bar.userData = d;\n            scene.add(bar);\n            bars.push(bar);\n        });\n\n        // Scatter points\n        const points = [];\n        const sphereGeo = new THREE.SphereGeometry(0.3, 16, 16);\n        data.forEach(d => {\n            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n            const point = new THREE.Mesh(sphereGeo, material);\n            point.position.set(d.x, d.y, d.z);\n            point.userData = d;\n            scene.add(point);\n            points.push(point);\n        });\n\n        // Ribbons (tubes connecting rows)\n        const ribbons = [];\n        for (let j = 0; j < size; j++) {\n            const rowData = data.filter(d => d.j === j);\n            rowData.sort((a, b) => a.i - b.i);\n            const curvePoints = rowData.map(d => new THREE.Vector3(d.x, d.y, d.z));\n            const curve = new THREE.CatmullRomCurve3(curvePoints);\n            const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.4, 8, false);\n            const material = new THREE.MeshLambertMaterial({\n                color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),\n                transparent: true,\n                opacity: 0.6\n            });\n            const tube = new THREE.Mesh(tubeGeo, material);\n            tube.userData = { type: 'ribbon', row: j };\n            scene.add(tube);\n            ribbons.push(tube);\n        }\n\n        // Interactive objects\n        const interactive = [...bars, ...points];\n\n        // Tooltip\n        const tooltip = document.getElementById('tooltip');\n        const raycaster = new THREE.Raycaster();\n        const mouse = new THREE.Vector2();\n        let INTERSECTED = null;\n\n        function onMouseMove(event) {\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n            raycaster.setFromCamera(mouse, camera);\n            const intersects = raycaster.intersectObjects(interactive);\n\n            if (intersects.length > 0) {\n                const obj = intersects[0].object;\n                const d = obj.userData;\n                tooltip.innerHTML = `Grid: (${d.i}, ${d.j})<br>X: ${d.x.toFixed(1)} Y: ${d.y.toFixed(1)} Z: ${d.z.toFixed(1)}`;\n                tooltip.style.display = 'block';\n                tooltip.style.left = (event.clientX + 10) + 'px';\n                tooltip.style.top = (event.clientY + 10) + 'px';\n\n                if (INTERSECTED !== obj) {\n                    if (INTERSECTED) {\n                        // Reset previous\n                        if (scene.getObjectById(INTERSECTED.object.id)) {\n                            scene.getObjectById(INTERSECTED.object.id).material.emissive.setHex(0x000000);\n                        }\n                    }\n                    INTERSECTED = obj;\n                    obj.material.emissive.setHex(0x222222);\n                }\n            } else {\n                tooltip.style.display = 'none';\n                if (INTERSECTED) {\n                    INTERSECTED.material.emissive.setHex(0x000000);\n                    INTERSECTED = null;\n                }\n            }\n        }\n        document.addEventListener('mousemove', onMouseMove, false);\n\n        // Camera setup\n        camera.position.set(20, 20, 20);\n        camera.lookAt(0, 0, 0);\n\n        // Theme\n        let isDark = true;\n        function toggleTheme() {\n            isDark = !isDark;\n            scene.background = new THREE.Color(isDark ? 0x000011 : 0xeeeeff);\n            ambientLight.color.setHex(isDark ? 0x404040 : 0x404040);\n            directionalLight.color.setHex(isDark ? 0xdddddd : 0xffffff);\n            grid.material.color.setHex(isDark ? 0x333333 : 0x888888);\n            axes.material.color.setHex(isDark ? 0x888888 : 0x333333);\n        }\n        toggleTheme(); // Initial dark\n\n        // Camera tween views\n        function tweenToView(viewName) {\n            let targetPos;\n            if (viewName === 'front') targetPos = new THREE.Vector3(0, 0, 40);\n            else if (viewName === 'top') targetPos = new THREE.Vector3(0, 40, 0);\n            else if (viewName === 'side') targetPos = new THREE.Vector3(40, 0, 0);\n            else return;\n\n            controls.enabled = false;\n            new TWEEN.Tween(camera.position)\n                .to(targetPos, 1500)\n                .easing(TWEEN.Easing.Quintic.InOut)\n                .onUpdate(() => {\n                    camera.lookAt(0, 0, 0);\n                })\n                .onComplete(() => {\n                    controls.enabled = true;\n                })\n                .start();\n        }\n\n        // CSV Export\n        function exportCSV() {\n            let csv = 'x,y,z,i,j\\n';\n            data.forEach(d => {\n                csv += `${d.x},${d.y},${d.z},${d.i},${d.j}\\n`;\n            });\n            const blob = new Blob([csv], { type: 'text/csv' });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = 'data_dashboard.csv';\n            a.click();\n            URL.revokeObjectURL(url);\n        }\n\n        // Event listeners\n        document.getElementById('toggleTheme').addEventListener('click', toggleTheme);\n        document.getElementById('exportCSV').addEventListener('click', exportCSV);\n        document.getElementById('viewFront').addEventListener('click', () => tweenToView('front'));\n        document.getElementById('viewTop').addEventListener('click', () => tweenToView('top'));\n        document.getElementById('viewSide').addEventListener('click', () => tweenToView('side'));\n\n        // Resize\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            TWEEN.update();\n            controls.update();\n            renderer.render(scene, camera);\n        }\n        animate();\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 37.4413628578186,
    "status": "success",
    "timestamp": "2025-09-23 17:29:13"
  },
  {
    "test_name": "molecular_explorer",
    "prompt": "Create a complete HTML file with Three.js that renders molecules from a provided or random molecular structure with ball-and-stick and space-filling modes, bond inference, atom coloring by element, section clipping, explode animation, and snapshot export. Include sample molecules (water, caffeine, DNA segment). The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'molecular_explorer.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Molecular Explorer</title>\n    <style>\n        body { margin: 0; overflow: hidden; }\n        canvas { display: block; }\n        #ui {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            z-index: 100;\n            background: rgba(255,255,255,0.8);\n            padding: 10px;\n            border-radius: 5px;\n        }\n        #ui button { margin: 2px; }\n        #pdbInput { width: 400px; height: 100px; margin-top: 10px; }\n        #clipZ { width: 100px; }\n    </style>\n</head>\n<body>\n    <div id=\"ui\">\n        <button onclick=\"loadSample('water')\">Water</button>\n        <button onclick=\"loadSample('caffeine')\">Caffeine</button>\n        <button onclick=\"loadSample('dna')\">DNA Segment</button>\n        <button onclick=\"randomMolecule()\">Random Chain</button>\n        <button onclick=\"toggleMode()\">Toggle Mode (Ball-and-Stick / Space-Filling)</button>\n        <button onclick=\"explode()\">Explode</button>\n        <button onclick=\"resetExplode()\">Reset Explode</button>\n        <button onclick=\"exportSnapshot()\">Export Snapshot</button>\n        <br>\n        <label>Clip Plane Z: <input type=\"range\" id=\"clipZ\" min=\"-20\" max=\"20\" value=\"0\" step=\"0.1\" oninput=\"updateClip()\"></label>\n        <br>\n        <button onclick=\"loadFromInput()\">Load Provided PDB</button>\n        <textarea id=\"pdbInput\" placeholder=\"Paste PDB content here...\"></textarea>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\n    <script>\n        let scene, camera, renderer, controls;\n        let moleculeGroup, atomsGroup, bondsGroup;\n        let isBallStick = true;\n        let exploded = false;\n        let explodeStartTime = 0;\n        let currentAtomsData, currentBondsData;\n        let clipPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);\n\n        const elementColors = {\n            'H': 0xffffff,\n            'C': 0x333333,\n            'N': 0x8F8FFF,\n            'O': 0xFF8C00,  // corrected to orange-red for O\n            'P': 0xFFA500,\n            // Add more as needed\n        };\n\n        const atomicRadii = {  // Ball-and-stick radii (scaled)\n            'H': 0.2,\n            'C': 0.3,\n            'N': 0.3,\n            'O': 0.3,\n            'P': 0.4,\n        };\n\n        const vdwRadii = {  // Space-filling (van der Waals, scaled down for view)\n            'H': 0.6,\n            'C': 0.85,\n            'N': 0.75,\n            'O': 0.7,\n            'P': 1.0,\n        };\n\n        const samplePDB = {\n            water: `\nATOM      1  O   WAT A   1       0.000   0.000   0.000  1.00  0.00           O\nATOM      2  H1  WAT A   1       0.757   0.000   0.586  1.00  0.00           H\nATOM      3  H2  WAT A   1      -0.757   0.000   0.586  1.00  0.00           H\n            `,\n            caffeine: `\nATOM      1  C1  CAF A   1      -0.440   0.031  -0.100  1.00 20.00           C\nATOM      2  C2  CAF A   1       0.641   0.022   0.922  1.00 20.00           C\nATOM      3  N3  CAF A   1       1.628   0.035   0.782  1.00 20.00           N\nATOM      4  C4  CAF A   1       1.732  -0.939   0.069  1.00 20.00           C\nATOM      5  C5  CAF A   1       2.819  -0.950  -0.749  1.00 20.00           C\nATOM      6  C6  CAF A   1       3.652  -0.043  -0.850  1.00 20.00           C\nATOM      7  N7  CAF A   1       3.764   1.019  -0.161  1.00 20.00           N\nATOM      8  C8  CAF A   1       2.803   1.010  -0.932  1.00 20.00           C\nATOM      9  N9  CAF A   1       1.968   0.977  -0.561  1.00 20.00           N\nATOM     10  C10  CAF A   1       0.199   1.016   0.171  1.00 20.00           C\nATOM     11  O11  CAF A   1      -0.771   1.035   0.305  1.00 20.00           O\nATOM     12  N12  CAF A   1      -0.921  -1.053   0.115  1.00 20.00           N\nATOM     13  C13  CAF A   1      -2.007  -1.058  -0.653  1.00 20.00           C\nATOM     14  C14  CAF A   1      -2.899  -0.144  -0.754  1.00 20.00           C\nATOM     15  N15  CAF A   1      -3.023   0.882  -0.065  1.00 20.00           N\nATOM     16  C16  CAF A   1      -2.062   0.881  -0.630  1.00 20.00           C\nATOM     17  C17  CAF A   1      -1.170   0.012  -0.431  1.00 20.00           C\nATOM     18  C18  CAF A   1      -2.007  -2.047  -1.337  1.00 20.00           C\nATOM     19  O19  CAF A   1      -3.011  -2.060  -1.472  1.00 20.00           O\nATOM     20  C20  CAF A   1      -0.938  -2.046  -0.797  1.00 20.00           C\nATOM     21  C21  CAF A   1       0.011  -1.035  -0.896  1.00 20.00           C\nATOM     22  N22  CAF A   1       0.032   0.018  -1.627  1.00 20.00           N\nATOM     23  C23  CAF A   1       1.107  -0.975  -1.719  1.00 20.00           C\nATOM     24  C24  CAF A   1       1.136   0.046  -2.867  1.00 20.00           C\n            `,\n            dna: `\nATOM      1  P   DT  A   1       0.000   0.000   0.000  1.00  0.00           P\nATOM      2  O1P DT  A   1      -1.500   0.000   0.000  1.00  0.00           O\nATOM      3  O2P DT  A   1       1.500   0.000   0.000  1.00  0.00           O\nATOM      4  O5' DT  A   1       0.000   2.000   0.000  1.00  0.00           O\nATOM      5  C5' DT  A   1       0.000   3.000   0.000  1.00  0.00           C\nATOM      6  C4' DT  A   1       0.000   3.500   1.000  1.00  0.00           C\nATOM      7  N1  DT  A   1       0.000   5.000   2.000  1.00  0.00           N\nATOM      8  C2  DT  A   1       0.000   5.500   3.000  1.00  0.00           C\nATOM      9  O2  DT  A   1       0.000   6.000   4.000  1.00  0.00           O\nATOM     10  N3  DT  A   1       1.000   5.000   2.000  1.00  0.00           N\nATOM     11  C4  DT  A   1       2.000   5.500   2.000  1.00  0.00           C\nATOM     12  O4  DT  A   1       3.000   5.000   2.000  1.00  0.00           O\n# Simplified thymine base pair segment (H atoms omitted)\n            `\n        };\n\n        function init() {\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0xf0f0f0);\n\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.localClippingEnabled = true;\n            document.body.appendChild(renderer.domElement);\n\n            controls = new THREE.OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\n            scene.add(ambientLight);\n\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(10, 10, 5);\n            scene.add(directionalLight);\n\n            camera.position.set(0, 0, 10);\n\n            window.addEventListener('resize', onWindowResize, false);\n            animate();\n\n            loadSample('water');\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            controls.update();\n\n            if (exploded) {\n                const elapsed = (Date.now() - explodeStartTime) / 1000;\n                const progress = Math.min(elapsed, 1);\n                if (atomsGroup) {\n                    atomsGroup.children.forEach((atom) => {\n                        if (atom.userData.originalPos && atom.userData.explodeDir) {\n                            const target = atom.userData.originalPos.clone().add(atom.userData.explodeDir);\n                            atom.position.lerpVectors(atom.userData.originalPos, target, progress);\n                        }\n                    });\n                }\n            }\n\n            renderer.render(scene, camera);\n        }\n\n        function parsePDB(pdbString) {\n            const atoms = [];\n            const lines = pdbString.split('\\n').filter(line => line.trim());\n            lines.forEach(line => {\n                if (line.substring(0, 6).trim() === 'ATOM' || line.substring(0, 6).trim() === 'HETATM') {\n                    const x = parseFloat(line.substring(30, 38));\n                    const y = parseFloat(line.substring(38, 46));\n                    const z = parseFloat(line.substring(46, 54));\n                    const atomName = line.substring(12, 16).replace(/\\s/g, '');\n                    let el;\n                    if (atomName.length >= 2 && /[a-z]/.test(atomName[1])) {\n                        el = atomName.substring(0, 2).toUpperCase();\n                    } else {\n                        el = atomName.substring(0, 1).toUpperCase();\n                    }\n                    atoms.push({ el, pos: [x * 0.5, y * 0.5, z * 0.5] });  // Scale for better view\n                }\n            });\n            return { atoms, bonds: null };\n        }\n\n        function inferBonds(positions, maxDist = 1.8) {\n            const bonds = [];\n            for (let i = 0; i < positions.length; i++) {\n                for (let j = i + 1; j < positions.length; j++) {\n                    if (positions[i].distanceTo(positions[j]) < maxDist) {\n                        bonds.push([i, j]);\n                    }\n                }\n            }\n            return bonds;\n        }\n\n        function createAtom(el, pos, radius) {\n            const geometry = new THREE.SphereGeometry(radius, 24, 24);\n            const color = elementColors[el] || 0x808080;\n            const material = new THREE.MeshLambertMaterial({ color });\n            material.clippingPlanes = [clipPlane];\n            const sphere = new THREE.Mesh(geometry, material);\n            sphere.position.fromArray(pos);\n            return sphere;\n        }\n\n        function createBond(atom1, atom2, bondRadius = 0.15) {\n            const pos1 = atom1.position.clone();\n            const pos2 = atom2.position.clone();\n            const midPoint = pos1.clone().add(pos2).divideScalar(2);\n            const direction = pos2.clone().sub(pos1).normalize();\n            const distance = pos1.distanceTo(pos2);\n\n            const geometry = new THREE.CylinderGeometry(bondRadius, bondRadius, 1, 8);\n            const material = new THREE.MeshLambertMaterial({ color: 0x333333 });\n            material.clippingPlanes = [clipPlane];\n            const cylinder = new THREE.Mesh(geometry, material);\n\n            cylinder.position.copy(midPoint);\n            cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);\n            cylinder.scale.y = distance;\n\n            return cylinder;\n        }\n\n        function loadMolecule(atomsData, bondsData, mode = 'ballstick') {\n            if (moleculeGroup) {\n                scene.remove(moleculeGroup);\n            }\n            moleculeGroup = new THREE.Group();\n            atomsGroup = new THREE.Group();\n            bondsGroup = new THREE.Group();\n            moleculeGroup.add(atomsGroup);\n            moleculeGroup.add(bondsGroup);\n\n            const atomMeshes = [];\n            for (const atomData of atomsData) {\n                let radius = mode === 'spacefilling' ? (vdwRadii[atomData.el] || 1.0) : (atomicRadii[atomData.el] || 0.5);\n                const atom = createAtom(atomData.el, atomData.pos, radius);\n                atomMeshes.push(atom);\n                atomsGroup.add(atom);\n            }\n\n            if (mode === 'ballstick') {\n                let finalBonds = bondsData;\n                if (!finalBonds) {\n                    const positions = atomsData.map(d => new THREE.Vector3(...d.pos));\n                    finalBonds = inferBonds(positions);\n                }\n                for (const bond of finalBonds) {\n                    const b = createBond(atomMeshes[bond[0]], atomMeshes[bond[1]]);\n                    bondsGroup.add(b);\n                }\n                bondsGroup.visible = true;\n            } else {\n                bondsGroup.visible = false;\n            }\n\n            // Center the molecule\n            const center = new THREE.Vector3();\n            atomsData.forEach(d => center.add(new THREE.Vector3(...d.pos)));\n            center.divideScalar(atomsData.length);\n            moleculeGroup.position.sub(center);\n\n            scene.add(moleculeGroup);\n            controls.target.set(0, 0, 0);\n            controls.update();\n        }\n\n        function loadSample(name) {\n            const pdb = samplePDB[name];\n            if (pdb) {\n                const data = parsePDB(pdb);\n                currentAtomsData = data.atoms;\n                currentBondsData = data.bonds;\n                loadMolecule(currentAtomsData, currentBondsData, isBallStick ? 'ballstick' : 'spacefilling');\n            }\n        }\n\n        function randomMolecule() {\n            const numAtoms = Math.floor(Math.random() * 15) + 5;\n            const atoms = [];\n            let prevPos = new THREE.Vector3(0, 0, 0);\n            const els = ['C', 'N', 'O', 'H'];\n            for (let i = 0; i < numAtoms; i++) {\n                const el = els[Math.floor(Math.random() * els.length)];\n                const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();\n                prevPos.add(dir.multiplyScalar(1.2 + Math.random() * 0.6));\n                atoms.push({ el, pos: [prevPos.x, prevPos.y, prevPos.z] });\n            }\n            currentAtomsData = atoms;\n            currentBondsData = null;  // Will infer\n            loadMolecule(atoms, null, isBallStick ? 'ballstick' : 'spacefilling');\n        }\n\n        function toggleMode() {\n            isBallStick = !isBallStick;\n            if (currentAtomsData) {\n                loadMolecule(currentAtomsData, currentBondsData, isBallStick ? 'ballstick' : 'spacefilling');\n            }\n        }\n\n        function explode() {\n            if (exploded || !atomsGroup) return;\n            exploded = true;\n            explodeStartTime = Date.now();\n            const center = new THREE.Vector3();\n            atomsGroup.children.forEach(a => center.add(a.position));\n            center.divideScalar(atomsGroup.children.length);\n            atomsGroup.children.forEach(atom => {\n                atom.userData.originalPos = atom.position.clone();\n                const dirVec = atom.position.clone().sub(center).normalize().multiplyScalar(4);  // Explode distance\n                atom.userData.explodeDir = dirVec;\n            });\n            bondsGroup.visible = false;  // Hide bonds during explode\n        }\n\n        function resetExplode() {\n            exploded = false;\n            if (atomsGroup) {\n                atomsGroup.children.forEach(atom => {\n                    if (atom.userData.originalPos) {\n                        atom.position.copy(atom.userData.originalPos);\n                    }\n                });\n            }\n            if (bondsGroup && isBallStick) {\n                bondsGroup.visible = true;\n            }\n            controls.update();\n        }\n\n        function updateClip() {\n            const z = parseFloat(document.getElementById('clipZ').value);\n            clipPlane.constant = -z;\n            // Re-apply to materials if needed, but since set on create, okay for static.\n        }\n\n        function exportSnapshot() {\n            renderer.render(scene, camera);\n            const dataURL = renderer.domElement.toDataURL('image/png');\n            const link = document.createElement('a');\n            link.download = 'molecule_snapshot.png';\n            link.href = dataURL;\n            link.click();\n        }\n\n        function loadFromInput() {\n            const input = document.getElementById('pdbInput').value;\n            if (input.trim()) {\n                const data = parsePDB(input);\n                currentAtomsData = data.atoms;\n                currentBondsData = data.bonds;\n                loadMolecule(currentAtomsData, data.bonds, isBallStick ? 'ballstick' : 'spacefilling');\n            }\n        }\n\n        init();\n    </script>\n</body>\n</html>\n```\n\nSave the output as 'molecular_explorer.html'. This self-contained HTML file loads Three.js from CDN and implements all requested features: rendering from samples (water, approximate caffeine structure without H atoms, simple DNA segment), random chain generation, ball-and-stick/space-filling toggle, bond inference via distance, element-based coloring, Z-section clipping with slider, explode animation (atoms only, hides bonds), and PNG snapshot export. PDB parsing is basic for ATOM lines (elements inferred from atom names, positions scaled for view). Interaction via OrbitControls.",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 76.11875510215759,
    "status": "success",
    "timestamp": "2025-09-23 17:30:29"
  },
  {
    "test_name": "space_shooter_prototype",
    "prompt": "Create a complete HTML file with Three.js that builds a simple on-rails space shooter with starfield background, enemy waves (instanced meshes), laser projectiles, hit effects (GPU particles), health/score UI, and post-processing bloom. Provide difficulty scaling and mobile touch controls. The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'space_shooter.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>Space Shooter</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <style>\n        body { margin: 0; overflow: hidden; background: black; }\n        #ui { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; z-index: 100; }\n        #score { font-size: 24px; }\n        #health { font-size: 24px; margin-top: 10px; }\n        #gameover { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; display: none; font-family: Arial; }\n        #gameover h1 { font-size: 48px; margin: 0; }\n        #gameover p { font-size: 24px; }\n        #gameover button { font-size: 20px; padding: 10px 20px; background: #333; color: white; border: none; cursor: pointer; }\n    </style>\n</head>\n<body>\n    <div id=\"ui\">\n        <div id=\"score\">Score: 0</div>\n        <div id=\"health\">Health: 100</div>\n    </div>\n    <div id=\"gameover\">\n        <h1>Game Over</h1>\n        <p>Final Score: <span id=\"finalscore\">0</span></p>\n        <button onclick=\"location.reload()\">Restart</button>\n    </div>\n\n    <script type=\"importmap\">\n    {\n        \"imports\": {\n            \"three\": \"https://unpkg.com/three@0.158.0/build/three.module.js\",\n            \"three/addons/\": \"https://unpkg.com/three@0.158.0/examples/jsm/\"\n        }\n    }\n    </script>\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n\n        let scene, camera, renderer, composer;\n        let ship;\n        let stars;\n        let enemies;\n        let lasers = [];\n        let particles = [];\n        let score = 0;\n        let health = 100;\n        let gameRunning = true;\n        let enemySpeed = 20; // units per second\n        let laserSpeed = 100;\n        let starSpeed = 30;\n        let waveTimer = 0;\n        let waveInterval = 5000; // ms\n        let mouse = new THREE.Vector2();\n        let lastShoot = 0;\n        let shootCooldown = 200; // ms\n        const clock = new THREE.Clock();\n        const nullMatrix = new THREE.Matrix4();\n\n        function init() {\n            scene = new THREE.Scene();\n            scene.fog = new THREE.Fog(0x000000, 10, 1000);\n\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n            camera.position.z = -10;\n\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n            document.body.appendChild(renderer.domElement);\n\n            // Post-processing\n            composer = new EffectComposer(renderer);\n            const renderPass = new RenderPass(scene, camera);\n            composer.addPass(renderPass);\n            const bloomPass = new UnrealBloomPass(\n                new THREE.Vector2(window.innerWidth, window.innerHeight),\n                1.5, 0.4, 0.85\n            );\n            composer.addPass(bloomPass);\n\n            // Starfield\n            const starCount = 5000;\n            const starGeometry = new THREE.BufferGeometry();\n            const positions = new Float32Array(starCount * 3);\n            for (let i = 0; i < starCount; i++) {\n                positions[i * 3] = (Math.random() - 0.5) * 2000;\n                positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;\n                positions[i * 3 + 2] = Math.random() * 500 + 50;\n            }\n            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2, sizeAttenuation: true });\n            stars = new THREE.Points(starGeometry, starMaterial);\n            scene.add(stars);\n\n            // Player ship\n            const shipGeometry = new THREE.BoxGeometry(1, 0.5, 2);\n            const shipMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });\n            ship = new THREE.Mesh(shipGeometry, shipMaterial);\n            ship.position.z = 0;\n            scene.add(ship);\n\n            // Lighting for basic\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);\n            scene.add(ambientLight);\n\n            // Enemies instanced\n            const enemyCount = 200;\n            const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);\n            const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });\n            enemies = new THREE.InstancedMesh(enemyGeometry, enemyMaterial, enemyCount);\n            // Hide all initially\n            for (let i = 0; i < enemyCount; i++) {\n                enemies.setMatrixAt(i, nullMatrix);\n            }\n            scene.add(enemies);\n\n            // Initial wave\n            spawnWave();\n\n            // Events\n            window.addEventListener('pointermove', onPointerMove);\n            window.addEventListener('click', onShoot);\n            window.addEventListener('pointerdown', onShoot);\n            window.addEventListener('resize', onResize);\n\n            updateUI();\n            animate();\n        }\n\n        function getFreeInstance() {\n            for (let i = 0; i < enemies.count; i++) {\n                let isFree = true;\n                for (let e of activeEnemies) {\n                    if (e.index === i) {\n                        isFree = false;\n                        break;\n                    }\n                }\n                if (isFree) return i;\n            }\n            return -1;\n        }\n\n        let activeEnemies = [];\n\n        function spawnWave() {\n            const numEnemies = 3 + Math.floor(Math.sqrt(score / 100));\n            for (let i = 0; i < numEnemies; i++) {\n                const index = getFreeInstance();\n                if (index !== -1) {\n                    const pos = new THREE.Vector3(\n                        (Math.random() - 0.5) * 40,\n                        (Math.random() - 0.5) * 20,\n                        100 + Math.random() * 50\n                    );\n                    const matrix = new THREE.Matrix4().setPosition(pos);\n                    enemies.setMatrixAt(index, matrix);\n                    activeEnemies.push({ index, pos: pos.clone() });\n                }\n            }\n        }\n\n        const laserMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1 });\n\n        function onShoot() {\n            const now = Date.now();\n            if (now - lastShoot < shootCooldown || !gameRunning) return;\n            lastShoot = now;\n\n            const laserGeometry = new THREE.BoxGeometry(0.2, 0.2, 1);\n            const laser = new THREE.Mesh(laserGeometry, laserMaterial);\n            laser.position.copy(ship.position);\n            laser.position.z += 1;\n            scene.add(laser);\n            lasers.push(laser);\n        }\n\n        function createHitParticles(hitPos) {\n            const particleCount = 50;\n            const pGeometry = new THREE.BufferGeometry();\n            const pPositions = new Float32Array(particleCount * 3);\n            const velocities = [];\n            const ages = new Array(particleCount).fill(0);\n            for (let i = 0; i < particleCount; i++) {\n                const dir = new THREE.Vector3(\n                    Math.random() - 0.5,\n                    Math.random() - 0.5,\n                    Math.random() - 0.5\n                ).normalize();\n                dir.multiplyScalar(10 + Math.random() * 20); // per second\n                velocities.push(dir);\n                pPositions[i * 3] = hitPos.x + (Math.random() - 0.5) * 0.5;\n                pPositions[i * 3 + 1] = hitPos.y + (Math.random() - 0.5) * 0.5;\n                pPositions[i * 3 + 2] = hitPos.z + (Math.random() - 0.5) * 0.5;\n            }\n            pGeometry.setAttribute('position', new THREE.BufferAttribute(pPositions, 3));\n            const pMaterial = new THREE.PointsMaterial({\n                color: 0xffff00,\n                size: 0.2,\n                transparent: true,\n                opacity: 1,\n                sizeAttenuation: true\n            });\n            const particleSystem = new THREE.Points(pGeometry, pMaterial);\n            scene.add(particleSystem);\n\n            particles.push({\n                system: particleSystem,\n                positionsAttr: pGeometry.attributes.position,\n                velocities,\n                ages\n            });\n        }\n\n        function updateParticles(delta) {\n            for (let i = particles.length - 1; i >= 0; i--) {\n                const p = particles[i];\n                let alive = false;\n                const positions = p.positionsAttr.array;\n                for (let j = 0; j < p.ages.length; j++) {\n                    p.ages[j] += delta;\n                    if (p.ages[j] < 1.5) {\n                        alive = true;\n                        const idx = j * 3;\n                        const vel = p.velocities[j];\n                        positions[idx] += vel.x * delta;\n                        positions[idx + 1] += vel.y * delta;\n                        positions[idx + 2] += vel.z * delta;\n                    }\n                }\n                p.positionsAttr.needsUpdate = true;\n                const avgAge = p.ages.reduce((a, b) => a + b, 0) / p.ages.length;\n                p.system.material.opacity = Math.max(0, 1 - avgAge / 1.5);\n                if (!alive) {\n                    scene.remove(p.system);\n                    p.positionsAttr.array = null; // cleanup\n                    particles.splice(i, 1);\n                }\n            }\n        }\n\n        function onPointerMove(event) {\n            if (!gameRunning) return;\n            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n        }\n\n        function onResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            composer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function updateUI() {\n            document.getElementById('score').textContent = `Score: ${score}`;\n            document.getElementById('health').textContent = `Health: ${health}`;\n        }\n\n        function gameOver() {\n            gameRunning = false;\n            document.getElementById('finalscore').textContent = score;\n            document.getElementById('gameover').style.display = 'block';\n        }\n\n        function animate() {\n            requestAnimationFrame(animate);\n            if (!gameRunning) return;\n\n            const delta = clock.getDelta();\n            const deltaMs = delta * 1000;\n\n            // Ship position\n            ship.position.x = THREE.MathUtils.clamp(mouse.x * 10, -8, 8);\n            ship.position.y = THREE.MathUtils.clamp(mouse.y * 8, -6, 6);\n\n            // Stars\n            const starPos = stars.geometry.attributes.position.array;\n            for (let i = 0; i < starPos.length; i += 3) {\n                starPos[i + 2] -= starSpeed * delta;\n                if (starPos[i + 2] < -50) {\n                    starPos[i + 2] = 200 + Math.random() * 100;\n                    starPos[i] = (Math.random() - 0.5) * 200;\n                    starPos[i + 1] = (Math.random() - 0.5) * 200;\n                }\n            }\n            stars.geometry.attributes.position.needsUpdate = true;\n\n            // Lasers\n            for (let i = lasers.length - 1; i >= 0; i--) {\n                const l = lasers[i];\n                l.position.z += laserSpeed * delta;\n                if (l.position.z > 200) {\n                    scene.remove(l);\n                    lasers.splice(i, 1);\n                }\n            }\n\n            // Enemies\n            for (let i = activeEnemies.length - 1; i >= 0; i--) {\n                const e = activeEnemies[i];\n                e.pos.z -= enemySpeed * delta;\n                const matrix = new THREE.Matrix4().setPosition(e.pos);\n                enemies.setMatrixAt(e.index, matrix);\n                enemies.instanceMatrix.needsUpdate = true;\n\n                // Hit player?\n                if (e.pos.distanceTo(ship.position) < 2) {\n                    health -= 10;\n                    updateUI();\n                    enemies.setMatrixAt(e.index, nullMatrix);\n                    activeEnemies.splice(i, 1);\n                    enemies.instanceMatrix.needsUpdate = true;\n                    if (health <= 0) {\n                        gameOver();\n                        return;\n                    }\n                    continue;\n                }\n            }\n\n            // Collisions\n            for (let li = lasers.length - 1; li >= 0; li--) {\n                const l = lasers[li];\n                for (let ei = activeEnemies.length - 1; ei >= 0; ei--) {\n                    const e = activeEnemies[ei];\n                    if (l.position.distanceTo(e.pos) < 1.5) {\n                        score += 10;\n                        updateUI();\n                        createHitParticles(e.pos.clone());\n                        enemies.setMatrixAt(e.index, nullMatrix);\n                        activeEnemies.splice(ei, 1);\n                        enemies.instanceMatrix.needsUpdate = true;\n                        scene.remove(l);\n                        lasers.splice(li, 1);\n                        break;\n                    }\n                }\n            }\n\n            // Waves\n            waveTimer += deltaMs;\n            if (waveTimer > waveInterval) {\n                spawnWave();\n                waveTimer = 0;\n                // Difficulty scaling\n                enemySpeed += 2;\n                waveInterval = Math.max(1000, waveInterval - 500);\n            }\n\n            // Particles\n            updateParticles(delta);\n\n            composer.render();\n        }\n\n        init();\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 81.49189805984497,
    "status": "success",
    "timestamp": "2025-09-23 17:31:51"
  },
  {
    "test_name": "architectural_walkthrough",
    "prompt": "Create a complete HTML file with Three.js that creates an interactive walkthrough for a procedurally generated house with first-person controls with collision detection, baked/IBL lighting, light probes, room-based culling, interactive hotspots that toggle materials/furniture, and a minimap. Include multiple rooms and furniture. The HTML file should be self-contained with Three.js loaded from CDN. Save the output as 'architectural_walkthrough.html'.",
    "response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Architectural Walkthrough</title>\n    <style>\n        body { margin: 0; overflow: hidden; }\n        #minimap {\n            position: absolute;\n            top: 10px;\n            right: 10px;\n            width: 200px;\n            height: 200px;\n            border: 1px solid black;\n            background: white;\n        }\n        #instructions {\n            position: absolute;\n            top: 50%;\n            width: 100%;\n            text-align: center;\n            color: white;\n            font-family: Arial;\n            font-size: 20px;\n            z-index: 100;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"instructions\">Click to start walkthrough<br/>WASD to move, Mouse to look around<br/>Click on green hotspots to interact with furniture</div>\n    <canvas id=\"minimap\"></canvas>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js\"></script>\n    <script>\n        // Scene setup\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderer.domElement);\n\n        // Simple IBL setup with procedural equirectangular texture\n        const canvas = document.createElement('canvas');\n        canvas.width = 512;\n        canvas.height = 256;\n        const ctx = canvas.getContext('2d');\n        const gradient = ctx.createLinearGradient(0, 0, 0, 256);\n        gradient.addColorStop(0, '#87ceeb');\n        gradient.addColorStop(1, '#443322');\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, 512, 256);\n        const equiTexture = new THREE.CanvasTexture(canvas);\n        const pmremGenerator = new THREE.PMREMGenerator(renderer);\n        pmremGenerator.compileEquirectangularShader();\n        const envMap = pmremGenerator.fromEquirectangular(equiTexture).texture;\n        scene.environment = envMap;\n        scene.background = new THREE.Color(0x87ceeb);\n        pmremGenerator.dispose();\n\n        // Lighting\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);\n        scene.add(ambientLight);\n        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x443322, 0.6);\n        scene.add(hemisphereLight);\n\n        // Light probe\n        const lightProbe = new THREE.LightProbe();\n        lightProbe.position.set(0, 1.5, 0);\n        scene.add(lightProbe);\n\n        // Procedurally generated house (simple layout with 3 rooms)\n        const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });\n        const floorMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });\n        const walls = [];\n        const floors = [];\n        const furnitures = [];\n        const hotspots = [];\n        const rooms = [\n            { id: 0, min: new THREE.Vector3(-15, -1, -6), max: new THREE.Vector3(-5, 4, 6), adjacent: [1] },\n            { id: 1, min: new THREE.Vector3(-5, -1, -6), max: new THREE.Vector3(5, 4, 6), adjacent: [0, 2] },\n            { id: 2, min: new THREE.Vector3(5, -1, -6), max: new THREE.Vector3(15, 4, 6), adjacent: [1] }\n        ];\n\n        // Full floor and ceiling\n        const fullFloorGeo = new THREE.PlaneGeometry(30, 12);\n        const fullFloor = new THREE.Mesh(fullFloorGeo, floorMat);\n        fullFloor.rotation.x = -Math.PI / 2;\n        fullFloor.position.y = 0;\n        scene.add(fullFloor);\n        floors.push(fullFloor);\n        fullFloor.userData.roomId = -1;\n\n        const ceiling = fullFloor.clone();\n        ceiling.position.y = 3;\n        scene.add(ceiling);\n        floors.push(ceiling);\n        ceiling.userData.roomId = -1;\n\n        // Outer walls\n        const backWallGeo = new THREE.BoxGeometry(30, 3, 0.2);\n        const backWall = new THREE.Mesh(backWallGeo, wallMat);\n        backWall.position.set(0, 1.5, -6);\n        scene.add(backWall);\n        walls.push(backWall);\n        backWall.userData.roomId = -1;\n\n        const frontWall = backWall.clone();\n        frontWall.position.z = 6;\n        scene.add(frontWall);\n        walls.push(frontWall);\n        frontWall.userData.roomId = -1;\n\n        const sideWallGeo = new THREE.BoxGeometry(0.2, 3, 12);\n        const leftWall = new THREE.Mesh(sideWallGeo, wallMat);\n        leftWall.position.set(-15, 1.5, 0);\n        scene.add(leftWall);\n        walls.push(leftWall);\n        leftWall.userData.roomId = -1;\n\n        const rightWall = leftWall.clone();\n        rightWall.position.x = 15;\n        scene.add(rightWall);\n        walls.push(rightWall);\n        rightWall.userData.roomId = -1;\n\n        // Internal walls with door gaps (at x=-5 and x=5, gap z=-1 to 1)\n        const internalWallGeo = new THREE.BoxGeometry(0.2, 3, 5);\n        // Wall at x=-5, lower segment\n        const internalLeft1 = new THREE.Mesh(internalWallGeo, wallMat);\n        internalLeft1.position.set(-5, 1.5, -3.5);\n        scene.add(internalLeft1);\n        walls.push(internalLeft1);\n        internalLeft1.userData.roomId = -1;\n\n        // Upper segment\n        const internalLeft2 = internalLeft1.clone();\n        internalLeft2.position.z = 3.5;\n        scene.add(internalLeft2);\n        walls.push(internalLeft2);\n        internalLeft2.userData.roomId = -1;\n\n        // Wall at x=5\n        const internalRight1 = internalLeft1.clone();\n        internalRight1.position.x = 5;\n        internalRight1.position.z = -3.5;\n        scene.add(internalRight1);\n        walls.push(internalRight1);\n        internalRight1.userData.roomId = -1;\n\n        const internalRight2 = internalRight1.clone();\n        internalRight2.position.z = 3.5;\n        scene.add(internalRight2);\n        walls.push(internalRight2);\n        internalRight2.userData.roomId = -1;\n\n        // Furniture\n        // Table in room 0 (living room)\n        const tableOriginalMat = new THREE.MeshStandardMaterial({ color: 0x654321 });\n        const tableAltMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });\n        const tableTopGeo = new THREE.BoxGeometry(2, 0.1, 2);\n        const tableTop = new THREE.Mesh(tableTopGeo, tableOriginalMat);\n        tableTop.position.set(-10, 1.05, 0);\n        scene.add(tableTop);\n        furnitures.push(tableTop);\n        tableTop.userData.roomId = 0;\n\n        const tableLegGeo = new THREE.BoxGeometry(0.1, 1, 0.1);\n        const tableLeg1 = new THREE.Mesh(tableLegGeo, tableOriginalMat);\n        tableLeg1.position.set(-10.75, 0.5, -0.75);\n        scene.add(tableLeg1);\n        furnitures.push(tableLeg1);\n        tableLeg1.userData.roomId = 0;\n\n        const tableLeg2 = tableLeg1.clone();\n        tableLeg2.position.x = -9.25;\n        scene.add(tableLeg2);\n        furnitures.push(tableLeg2);\n        tableLeg2.userData.roomId = 0;\n\n        const tableLeg3 = tableLeg1.clone();\n        tableLeg3.position.z = 0.75;\n        scene.add(tableLeg3);\n        furnitures.push(tableLeg3);\n        tableLeg3.userData.roomId = 0;\n\n        const tableLeg4 = tableLeg3.clone();\n        tableLeg4.position.x = -9.25;\n        scene.add(tableLeg4);\n        furnitures.push(tableLeg4);\n        tableLeg4.userData.roomId = 0;\n\n        // Chair in room 1 (kitchen)\n        const chair = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.5), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));\n        chair.position.set(0, 0.5, 3);\n        scene.add(chair);\n        furnitures.push(chair);\n        chair.userData.roomId = 1;\n\n        // Bed in room 2 (bedroom)\n        const bedOriginalMat = new THREE.MeshStandardMaterial({ color: 0xffffff });\n        const bedAltMat = new THREE.MeshStandardMaterial({ color: 0x0000ff });\n        const bed = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 2), bedOriginalMat);\n        bed.position.set(10, 0.25, 0);\n        scene.add(bed);\n        furnitures.push(bed);\n        bed.userData.roomId = 2;\n\n        // Hotspots (invisible spheres for interaction)\n        const hotspotGeo = new THREE.SphereGeometry(1);\n        const hotspotMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0 });\n\n        // Table hotspot (toggle material)\n        const tableHotspot = new THREE.Mesh(hotspotGeo, hotspotMat);\n        tableHotspot.position.set(-10, 1, 0);\n        scene.add(tableHotspot);\n        hotspots.push({\n            mesh: tableHotspot,\n            meshes: [tableTop, tableLeg1, tableLeg2, tableLeg3, tableLeg4],\n            originalMat: tableOriginalMat,\n            altMat: tableAltMat,\n            isAlt: false\n        });\n        tableHotspot.userData.roomId = 0;\n\n        // Chair hotspot (toggle visibility)\n        const chairHotspot = new THREE.Mesh(hotspotGeo, hotspotMat);\n        chairHotspot.position.set(0, 0.5, 3);\n        scene.add(chairHotspot);\n        hotspots.push({\n            mesh: chairHotspot,\n            target: chair,\n            type: 'toggle'\n        });\n        chairHotspot.userData.roomId = 1;\n\n        // Bed hotspot (toggle material)\n        const bedHotspot = new THREE.Mesh(hotspotGeo, hotspotMat);\n        bedHotspot.position.set(10, 0.25, 0);\n        scene.add(bedHotspot);\n        hotspots.push({\n            mesh: bedHotspot,\n            meshes: [bed],\n            originalMat: bedOriginalMat,\n            altMat: bedAltMat,\n            isAlt: false\n        });\n        bedHotspot.userData.roomId = 2;\n\n        // Colliders\n        const colliders = walls.map(w => {\n            const box = new THREE.Box3().setFromObject(w);\n            return box;\n        });\n\n        // Room-based culling\n        function getCurrentRoom(pos) {\n            for (let room of rooms) {\n                if (pos.x >= room.min.x && pos.x <= room.max.x &&\n                    pos.z >= room.min.z && pos.z <= room.max.z) {\n                    return room.id;\n                }\n            }\n            return 0;\n        }\n\n        function updateCulling() {\n            const pos = camera.position;\n            const cur = getCurrentRoom(pos);\n            const visibleRooms = [cur, ...rooms[cur].adjacent];\n            scene.traverse((obj) => {\n                if (obj.userData.roomId !== undefined) {\n                    if (obj.userData.roomId === -1) {\n                        obj.visible = true;\n                    } else {\n                        obj.visible = visibleRooms.includes(obj.userData.roomId);\n                    }\n                }\n            });\n        }\n\n        // First-person controls with collision\n        camera.position.set(0, 1.6, 0);\n        const euler = new THREE.Euler(0, 0, 0, 'YXZ');\n        const direction = new THREE.Vector3();\n        const keys = {};\n        const clock = new THREE.Clock();\n        let isLocked = false;\n\n        document.addEventListener('keydown', (e) => { keys[e.code] = true; });\n        document.addEventListener('keyup', (e) => { keys[e.code] = false; });\n\n        document.addEventListener('click', () => {\n            document.body.requestPointerLock();\n            document.getElementById('instructions').style.display = 'none';\n        });\n\n        document.addEventListener('pointerlockchange', () => {\n            isLocked = document.pointerLockElement === document.body;\n        });\n\n        document.addEventListener('mousemove', (e) => {\n            if (isLocked) {\n                const sensitivity = 0.002;\n                euler.y -= e.movementX * sensitivity;\n                euler.x -= e.movementY * sensitivity;\n                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));\n                camera.quaternion.setFromEuler(euler);\n            }\n        });\n\n        function canMove(newPos) {\n            const playerBox = new THREE.Box3().setFromCenterAndSize(\n                new THREE.Vector3(newPos.x, 1, newPos.z),\n                new THREE.Vector3(0.3, 1.8, 0.3)\n            );\n            for (let collider of colliders) {\n                if (playerBox.intersectsBox(collider)) {\n                    return false;\n                }\n            }\n            // Boundary check\n            if (newPos.x < -14.7 || newPos.x > 14.7 || newPos.z < -5.8 || newPos.z > 5.8) {\n                return false;\n            }\n            return true;\n        }\n\n        // Minimap\n        const minimapCanvas = document.getElementById('minimap');\n        const minimapCtx = minimapCanvas.getContext('2d');\n        const scale = 6;\n        const minX = -15, maxX = 15, minZ = -6, maxZ = 6;\n        const houseWidth = maxX - minX;\n        const houseDepth = maxZ - minZ;\n        const offsetX = (200 - houseWidth * scale) / 2;\n        const offsetZ = (200 - houseDepth * scale) / 2;\n\n        function worldToMap(wx, wz) {\n            const mx = offsetX + (wx - minX) * scale;\n            const my = offsetZ + (wz - minZ) * scale;\n            return { x: mx, y: my };\n        }\n\n        function updateMinimap() {\n            minimapCtx.clearRect(0, 0, 200, 200);\n            minimapCtx.strokeStyle = 'black';\n            minimapCtx.lineWidth = 2;\n\n            // Draw outer walls\n            // Back (z=-6)\n            let p1 = worldToMap(minX, minZ);\n            let p2 = worldToMap(maxX, minZ);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Front (z=6)\n            p1 = worldToMap(minX, maxZ);\n            p2 = worldToMap(maxX, maxZ);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Left (x=-15)\n            p1 = worldToMap(minX, minZ);\n            p2 = worldToMap(minX, maxZ);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Right (x=15)\n            p1 = worldToMap(maxX, minZ);\n            p2 = worldToMap(maxX, maxZ);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Internal wall at x=-5\n            // Lower segment z=-6 to -1\n            p1 = worldToMap(-5, -6);\n            p2 = worldToMap(-5, -1);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Upper segment z=1 to 6\n            p1 = worldToMap(-5, 1);\n            p2 = worldToMap(-5, 6);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Internal wall at x=5\n            // Lower\n            p1 = worldToMap(5, -6);\n            p2 = worldToMap(5, -1);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Upper\n            p1 = worldToMap(5, 1);\n            p2 = worldToMap(5, 6);\n            minimapCtx.beginPath();\n            minimapCtx.moveTo(p1.x, p1.y);\n            minimapCtx.lineTo(p2.x, p2.y);\n            minimapCtx.stroke();\n\n            // Player dot\n            const playerPos = worldToMap(camera.position.x, camera.position.z);\n            minimapCtx.fillStyle = 'red';\n            minimapCtx.beginPath();\n            minimapCtx.arc(playerPos.x, playerPos.y, 3, 0, Math.PI * 2);\n            minimapCtx.fill();\n        }\n\n        // Raycaster for hotspots\n        const raycaster = new THREE.Raycaster();\n\n        document.addEventListener('click', (e) => {\n            if (isLocked) {\n                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);\n                const intersects = raycaster.intersectObjects(hotspots.map(h => h.mesh), true);\n                if (intersects.length > 0) {\n                    const clickedMesh = intersects[0].object;\n                    const hotspotData = hotspots.find(h => h.mesh === clickedMesh);\n                    if (hotspotData) {\n                        if (hotspotData.type === 'toggle') {\n                            hotspotData.target.visible = !hotspotData.target.visible;\n                        } else if (hotspotData.meshes) {\n                            hotspotData.isAlt = !hotspotData.isAlt;\n                            hotspotData.meshes.forEach(mesh => {\n                                mesh.material = hotspotData.isAlt ? hotspotData.altMat : hotspotData.originalMat;\n                            });\n                        }\n                    }\n                }\n            }\n        });\n\n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            const delta = clock.getDelta();\n\n            // Movement\n            direction.z = Number(keys['KeyW']) - Number(keys['KeyS']);\n            direction.x = Number(keys['KeyD']) - Number(keys['KeyA']);\n            if (direction.length() > 0) {\n                direction.normalize();\n                const moveDir = new THREE.Vector3();\n                const quaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, euler.y, 0));\n                moveDir.set(direction.x, 0, direction.z).applyQuaternion(quaternion);\n                moveDir.y = 0;\n                moveDir.normalize();\n                const speed = 20 * delta;\n                moveDir.multiplyScalar(speed);\n                const newPos = camera.position.clone().add(moveDir);\n                if (canMove(newPos)) {\n                    camera.position.copy(newPos);\n                }\n            }\n\n            updateCulling();\n            updateMinimap();\n            renderer.render(scene, camera);\n        }\n\n        // Initial culling\n        updateCulling();\n        animate();\n\n        // Resize handler\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>\n```",
    "model": {
      "max_tokens": 100000,
      "model": "xai/grok-4-fast-reasoning"
    },
    "agent_name": "BenchAgent",
    "execution_time": 91.34037184715271,
    "status": "success",
    "timestamp": "2025-09-23 17:33:22"
  }
]