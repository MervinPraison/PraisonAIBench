<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Product Configurator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            z-index: 100;
        }
        .control-group {
            margin-bottom: 15px;
        }
        h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        select, input, button {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            background: #4285f4;
            color: white;
            border: none;
            cursor: pointer;
            padding: 8px;
            margin-top: 10px;
        }
        button:hover {
            background: #3367d6;
        }
        #camera-bookmarks {
            margin-top: 15px;
        }
        .bookmark-btn {
            width: auto;
            margin-right: 5px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <div class="control-group">
            <h3>Chair Configurator</h3>
        </div>
        
        <div class="control-group">
            <label for="chair-color">Chair Color:</label>
            <select id="chair-color">
                <option value="#8B4513">Brown</option>
                <option value="#FF0000">Red</option>
                <option value="#0000FF">Blue</option>
                <option value="#00FF00">Green</option>
                <option value="#FFFF00">Yellow</option>
                <option value="#808080">Gray</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="material-type">Material:</label>
            <select id="material-type">
                <option value="matte">Matte</option>
                <option value="glossy">Glossy</option>
                <option value="metal">Metal</option>
                <option value="fabric">Fabric</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="texture-type">Texture:</label>
            <select id="texture-type">
                <option value="none">None</option>
                <option value="wood">Wood</option>
                <option value="leather">Leather</option>
                <option value="fabric">Fabric Pattern</option>
            </select>
        </div>
        
        <div class="control-group">
            <h3>Parts Toggle</h3>
            <label><input type="checkbox" id="toggle-seat" checked> Seat</label>
            <label><input type="checkbox" id="toggle-back" checked> Backrest</label>
            <label><input type="checkbox" id="toggle-legs" checked> Legs</label>
            <label><input type="checkbox" id="toggle-arms" checked> Armrests</label>
        </div>
        
        <div class="control-group" id="camera-bookmarks">
            <h3>Camera Views</h3>
            <button class="bookmark-btn" id="front-view">Front</button>
            <button class="bookmark-btn" id="side-view">Side</button>
            <button class="bookmark-btn" id="top-view">Top</button>
            <button class="bookmark-btn" id="angled-view">Angled</button>
        </div>
        
        <div class="control-group">
            <h3>Export</h3>
            <button id="export-json">Export Config (JSON)</button>
            <button id="export-png">Save Snapshot (PNG)</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js';
        import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/loaders/RGBELoader.js';
        import { GLTFExporter } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/exporters/GLTFExporter.js';

        // Scene setup
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 2, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Environment setup
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        let envMap = null;
        
        // Load environment map for reflections
        new RGBELoader()
            .setPath('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/')
            .load('royal_esplanade_1k.hdr', function(texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                envMap = pmremGenerator.fromEquirectangular(texture).texture;
                
                // Apply envMap to all materials once loaded
                updateMaterials();
                
                pmremGenerator.dispose();
            }, undefined, function() {
                console.log('Failed to load HDR environment map, using fallback');
                // Create a simple gradient for fallback
                const gradientTexture = new THREE.CanvasTexture(generateGradientCanvas());
                gradientTexture.mapping = THREE.EquirectangularReflectionMapping;
                envMap = gradientTexture;
                updateMaterials();
            });

        function generateGradientCanvas() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#e0e0ff');
            gradient.addColorStop(0.5, '#a0a0ff');
            gradient.addColorStop(1, '#6060aa');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);
            
            return canvas;
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 30;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);

        // Add additional lights for better illumination
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(-5, 5, 5);
        scene.add(fillLight);

        const backLight = new THREE.DirectionalLight(0xffffff, 0.8);
        backLight.position.set(0, 5, -5);
        scene.add(backLight);

        // Ground plane for shadows
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x808080,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true;
        scene.add(ground);

        // Chair parts
        let chairParts = {};
        let currentConfig = {
            color: "#8B4513",
            material: "matte",
            texture: "none",
            parts: {
                seat: true,
                back: true,
                legs: true,
                arms: true
            }
        };

        // Create chair procedurally
        function createChair() {
            // Group to hold all chair parts
            const chairGroup = new THREE.Group();
            chairGroup.position.y = 0.5;
            scene.add(chairGroup);

            // Create materials
            function createMaterial(color = currentConfig.color) {
                const materialProps = {
                    color: new THREE.Color(color),
                    envMap: envMap,
                    envMapIntensity: 0.5
                };

                switch(currentConfig.material) {
                    case 'matte':
                        materialProps.roughness = 0.8;
                        materialProps.metalness = 0.1;
                        break;
                    case 'glossy':
                        materialProps.roughness = 0.2;
                        materialProps.metalness = 0.3;
                        break;
                    case 'metal':
                        materialProps.roughness = 0.1;
                        materialProps.metalness = 0.9;
                        break;
                    case 'fabric':
                        materialProps.roughness = 0.9;
                        materialProps.metalness = 0.0;
                        break;
                }

                // Apply texture if selected
                if (currentConfig.texture !== "none") {
                    materialProps.map = createTexture(currentConfig.texture);
                }

                return new THREE.MeshStandardMaterial(materialProps);
            }

            function createTexture(type) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                switch(type) {
                    case 'wood':
                        // Create wood grain effect
                        ctx.fillStyle = currentConfig.color;
                        ctx.fillRect(0, 0, 512, 512);
                        
                        for (let i = 0; i < 20; i++) {
                            ctx.strokeStyle = new THREE.Color(currentConfig.color).offsetHSL(0, 0, Math.random() * 0.2 - 0.1).getStyle();
                            ctx.lineWidth = 2 + Math.random() * 3;
                            ctx.beginPath();
                            for (let x = 0; x < 512; x += 5) {
                                const y = 20 + i * 20 + Math.sin(x * 0.05) * 5;
                                if (x === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                            ctx.stroke();
                        }
                        break;
                    
                    case 'leather':
                        // Create leather-like texture
                        ctx.fillStyle = currentConfig.color;
                        ctx.fillRect(0, 0, 512, 512);
                        
                        // Add some noise for leather grain
                        for (let i = 0; i < 5000; i++) {
                            const x = Math.random() * 512;
                            const y = Math.random() * 512;
                            const size = Math.random() * 3;
                            ctx.fillStyle = new THREE.Color(currentConfig.color).offsetHSL(0, 0, Math.random() * 0.2 - 0.1).getStyle();
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    case 'fabric':
                        // Create simple fabric pattern
                        const baseColor = new THREE.Color(currentConfig.color);
                        ctx.fillStyle = baseColor.getStyle();
                        ctx.fillRect(0, 0, 512, 512);
                        
                        // Add weave pattern
                        ctx.strokeStyle = baseColor.offsetHSL(0, 0, -0.2).getStyle();
                        ctx.lineWidth = 2;
                        
                        for (let i = 0; i < 512; i += 8) {
                            ctx.beginPath();
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i, 512);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(0, i);
                            ctx.lineTo(512, i);
                            ctx.stroke();
                        }
                        break;
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                return texture;
            }

            // Seat
            const seatGeometry = new THREE.BoxGeometry(1.2, 0.1, 1);
            const seatMaterial = createMaterial();
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.y = 0.45;
            seat.castShadow = true;
            chairGroup.add(seat);
            chairParts.seat = { mesh: seat, material: seatMaterial };

            // Backrest
            const backGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.2);
            const backMaterial = createMaterial();
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.set(0, 0.85, -0.4);
            back.castShadow = true;
            chairGroup.add(back);
            chairParts.back = { mesh: back, material: backMaterial };

            // Legs
            const legGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
            
            // Front left leg
            const leg1Material = createMaterial();
            const leg1 = new THREE.Mesh(legGeometry, leg1Material);
            leg1.position.set(-0.5, 0, 0.4);
            leg1.castShadow = true;
            chairGroup.add(leg1);
            
            // Front right leg
            const leg2Material = createMaterial();
            const leg2 = new THREE.Mesh(legGeometry, leg2Material);
            leg2.position.set(0.5, 0, 0.4);
            leg2.castShadow = true;
            chairGroup.add(leg2);
            
            // Back left leg
            const leg3Material = createMaterial();
            const leg3 = new THREE.Mesh(legGeometry, leg3Material);
            leg3.position.set(-0.5, 0, -0.4);
            leg3.castShadow = true;
            chairGroup.add(leg3);
            
            // Back right leg
            const leg4Material = createMaterial();
            const leg4 = new THREE.Mesh(legGeometry, leg4Material);
            leg4.position.set(0.5, 0, -0.4);
            leg4.castShadow = true;
            chairGroup.add(leg4);
            
            chairParts.legs = { 
                meshes: [leg1, leg2, leg3, leg4], 
                materials: [leg1Material, leg2Material, leg3Material, leg4Material] 
            };

            // Armrests
            const armGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.8);
            
            // Left armrest
            const arm1Material = createMaterial();
            const arm1 = new THREE.Mesh(armGeometry, arm1Material);
            arm1.position.set(-0.6, 0.6, 0);
            arm1.castShadow = true;
            chairGroup.add(arm1);
            
            // Right armrest
            const arm2Material = createMaterial();
            const arm2 = new THREE.Mesh(armGeometry, arm2Material);
            arm2.position.set(0.6, 0.6, 0);
            arm2.castShadow = true;
            chairGroup.add(arm2);
            
            chairParts.arms = { 
                meshes: [arm1, arm2], 
                materials: [arm1Material, arm2Material] 
            };

            return chairGroup;
        }

        const chair = createChair();

        // Update all materials when config changes
        function updateMaterials() {
            if (!chairParts.seat) return; // Wait for chair to be created
            
            const updatePartMaterial = (part) => {
                if (!part) return;
                
                if (Array.isArray(part.materials)) {
                    part.materials.forEach(material => updateMaterialProperties(material));
                } else {
                    updateMaterialProperties(part.material);
                }
            };

            updatePartMaterial(chairParts.seat);
            updatePartMaterial(chairParts.back);
            updatePartMaterial(chairParts.legs);
            updatePartMaterial(chairParts.arms);
        }

        function updateMaterialProperties(material) {
            material.color.set(currentConfig.color);
            
            switch(currentConfig.material) {
                case 'matte':
                    material.roughness = 0.8;
                    material.metalness = 0.1;
                    break;
                case 'glossy':
                    material.roughness = 0.2;
                    material.metalness = 0.3;
                    break;
                case 'metal':
                    material.roughness = 0.1;
                    material.metalness = 0.9;
                    break;
                case 'fabric':
                    material.roughness = 0.9;
                    material.metalness = 0.0;
                    break;
            }
            
            // Update texture
            if (currentConfig.texture !== "none") {
                material.map = createTexture(currentConfig.texture);
                material.map.needsUpdate = true;
            } else {
                material.map = null;
            }
            
            material.needsUpdate = true;
        }

        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            switch(type) {
                case 'wood':
                    // Create wood grain effect
                    ctx.fillStyle = currentConfig.color;
                    ctx.fillRect(0, 0, 512, 512);
                    
                    for (let i = 0; i < 20; i++) {
                        ctx.strokeStyle = new THREE.Color(currentConfig.color).offsetHSL(0, 0, Math.random() * 0.2 - 0.1).getStyle();
                        ctx.lineWidth = 2 + Math.random() * 3;
                        ctx.beginPath();
                        for (let x = 0; x < 512; x += 5) {
                            const y = 20 + i * 20 + Math.sin(x * 0.05) * 5;
                            if (x === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.stroke();
                    }
                    break;
                
                case 'leather':
                    // Create leather-like texture
                    ctx.fillStyle = currentConfig.color;
                    ctx.fillRect(0, 0, 512, 512);
                    
                    // Add some noise for leather grain
                    for (let i = 0; i < 5000; i++) {
                        const x = Math.random() * 512;
                        const y = Math.random() * 512;
                        const size = Math.random() * 3;
                        ctx.fillStyle = new THREE.Color(currentConfig.color).offsetHSL(0, 0, Math.random() * 0.2 - 0.1).getStyle();
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                
                case 'fabric':
                    // Create simple fabric pattern
                    const baseColor = new THREE.Color(currentConfig.color);
                    ctx.fillStyle = baseColor.getStyle();
                    ctx.fillRect(0, 0, 512, 512);
                    
                    // Add weave pattern
                    ctx.strokeStyle = baseColor.offsetHSL(0, 0, -0.2).getStyle();
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < 512; i += 8) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, 512);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(512, i);
                        ctx.stroke();
                    }
                    break;
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Update visibility of parts
        function updatePartsVisibility() {
            if (chairParts.seat) chairParts.seat.mesh.visible = currentConfig.parts.seat;
            if (chairParts.back) chairParts.back.mesh.visible = currentConfig.parts.back;
            
            if (chairParts.legs && chairParts.legs.meshes) {
                chairParts.legs.meshes.forEach(mesh => {
                    mesh.visible = currentConfig.parts.legs;
                });
            }
            
            if (chairParts.arms && chairParts.arms.meshes) {
                chairParts.arms.meshes.forEach(mesh => {
                    mesh.visible = currentConfig.parts.arms;
                });
            }
        }

        // Camera bookmarks
        const cameraBookmarks = {
            front: { position: new THREE.Vector3(0, 1.5, 5), target: new THREE.Vector3(0, 1, 0) },
            side: { position: new THREE.Vector3(5, 1.5, 0), target: new THREE.Vector3(0, 1, 0) },
            top: { position: new THREE.Vector3(0, 5, 0), target: new THREE.Vector3(0, 1, 0) },
            angled: { position: new THREE.Vector3(3, 2, 3), target: new THREE.Vector3(0, 1, 0) }
        };

        function setCameraBookmark(view) {
            const bookmark = cameraBookmarks[view];
            camera.position.copy(bookmark.position);
            controls.target.copy(bookmark.target);
            controls.update();
        }

        // Export functions
        function exportConfig() {
            // Get current camera position and target
            currentConfig.camera = {
                position: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                },
                target: {
                    x: controls.target.x,
                    y: controls.target.y,
                    z: controls.target.z
                }
            };
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(currentConfig, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "chair_config.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function exportSnapshot() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.download = 'chair_snapshot.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Event listeners for UI
        document.getElementById('chair-color').addEventListener('change', function(e) {
            currentConfig.color = e.target.value;
            updateMaterials();
        });

        document.getElementById('material-type').addEventListener('change', function(e) {
            currentConfig.material = e.target.value;
            updateMaterials();
        });

        document.getElementById('texture-type').addEventListener('change', function(e) {
            currentConfig.texture = e.target.value;
            updateMaterials();
        });

        document.getElementById('toggle-seat').addEventListener('change', function(e) {
            currentConfig.parts.seat = e.target.checked;
            updatePartsVisibility();
        });

        document.getElementById('toggle-back').addEventListener('change', function(e) {
            currentConfig.parts.back = e.target.checked;
            updatePartsVisibility();
        });

        document.getElementById('toggle-legs').addEventListener('change', function(e) {
            currentConfig.parts.legs = e.target.checked;
            updatePartsVisibility();
        });

        document.getElementById('toggle-arms').addEventListener('change', function(e) {
            currentConfig.parts.arms = e.target.checked;
            updatePartsVisibility();
        });

        document.getElementById('front-view').addEventListener('click', () => setCameraBookmark('front'));
        document.getElementById('side-view').addEventListener('click', () => setCameraBookmark('side'));
        document.getElementById('top-view').addEventListener('click', () => setCameraBookmark('top'));
        document.getElementById('angled-view').addEventListener('click', () => setCameraBookmark('angled'));

        document.getElementById('export-json').addEventListener('click', exportConfig);
        document.getElementById('export-png').addEventListener('click', exportSnapshot);

        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>